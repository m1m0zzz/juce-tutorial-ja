"use strict";(self.webpackChunkjuce_tutorial_ja=self.webpackChunkjuce_tutorial_ja||[]).push([[5061],{6401:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var t=o(4848),n=o(8453);const r={title:"\u30ab\u30b9\u30b1\u30fc\u30c9\u30fb\u30d7\u30e9\u30b0\u30a4\u30f3\u30fb\u30a8\u30d5\u30a7\u30af\u30c8",sidebar_position:4,tags:["\u4e2d\u7d1a"]},a="\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff1a\u30ab\u30b9\u30b1\u30fc\u30c9\u30d7\u30e9\u30b0\u30a4\u30f3\u30a8\u30d5\u30a7\u30af\u30c8",i={id:"plugins/tutorial_audio_processor_graph",title:"\u30ab\u30b9\u30b1\u30fc\u30c9\u30fb\u30d7\u30e9\u30b0\u30a4\u30f3\u30fb\u30a8\u30d5\u30a7\u30af\u30c8",description:"Create your own channel strip by learning how to daisy chain audio processors or plugins using an \u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5. Learn how to use the \u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5 in both a plugin and standalone application context.",source:"@site/docs/plugins/tutorial_audio_processor_graph.mdx",sourceDirName:"plugins",slug:"/plugins/tutorial_audio_processor_graph",permalink:"/juce-tutorial-ja/plugins/tutorial_audio_processor_graph",draft:!1,unlisted:!1,editUrl:"https://github.com/m1m0zzz/juce-tutorial-ja/tree/main/docs/plugins/tutorial_audio_processor_graph.mdx",tags:[{inline:!0,label:"\u4e2d\u7d1a",permalink:"/juce-tutorial-ja/tags/\u4e2d\u7d1a"}],version:"current",sidebarPosition:4,frontMatter:{title:"\u30ab\u30b9\u30b1\u30fc\u30c9\u30fb\u30d7\u30e9\u30b0\u30a4\u30f3\u30fb\u30a8\u30d5\u30a7\u30af\u30c8",sidebar_position:4,tags:["\u4e2d\u7d1a"]},sidebar:"tutorialSidebar",previous:{title:"\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u9069\u5207\u306a\u30d0\u30b9\u30ec\u30a4\u30a2\u30a6\u30c8\u3092\u8a2d\u5b9a\u3059\u308b",permalink:"/juce-tutorial-ja/plugins/tutorial_audio_bus_layouts"},next:{title:"\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u4f8b",permalink:"/juce-tutorial-ja/plugins/tutorial_plugin_examples"}},c={},l=[{value:"\u306f\u3058\u3081\u308b",id:"\u306f\u3058\u3081\u308b",level:2},{value:"Implementing an oscillator",id:"implementing-an-oscillator",level:2},{value:"Implementing a gain control",id:"implementing-a-gain-control",level:2},{value:"Implementing a filter",id:"implementing-a-filter",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components},{CaptionImage:o,ClassList:r,SourcePageLink:a}=s;return o||u("CaptionImage",!0),r||u("ClassList",!0),a||u("SourcePageLink",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30ab\u30b9\u30b1\u30fc\u30c9\u30d7\u30e9\u30b0\u30a4\u30f3\u30a8\u30d5\u30a7\u30af\u30c8",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff1a\u30ab\u30b9\u30b1\u30fc\u30c9\u30d7\u30e9\u30b0\u30a4\u30f3\u30a8\u30d5\u30a7\u30af\u30c8"})}),"\n",(0,t.jsx)(a,{path:"tutorial_audio_processor_graph"}),"\n",(0,t.jsxs)(s.p,{children:["Create your own channel strip by learning how to daisy chain audio processors or plugins using an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),". Learn how to use the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," in both a plugin and standalone application context."]}),"\n",(0,t.jsx)(s.p,{children:"\u30ec\u30d9\u30eb\uff1a\u4e2d\u7d1a"}),"\n",(0,t.jsx)(s.p,{children:"\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\uff1aWindows, macOS, Linux"}),"\n",(0,t.jsx)(r,{refs:["AudioProcessor","AudioProcessorPlayer","AudioProcessorGraph","AudioProcessorGraph::AudioGraphIOProcessor","AudioProcessorGraph::Node","AudioDeviceManager"]}),"\n",(0,t.jsx)(s.h2,{id:"\u306f\u3058\u3081\u308b",children:"\u306f\u3058\u3081\u308b"}),"\n",(0,t.jsxs)(s.p,{children:["Download the demo project for this tutorial here: ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/tutorials/PIPs/AudioProcessorGraphTutorial.zip",children:"\u30d4\u30c3\u30d7"})," | ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/tutorials/ZIPs/AudioProcessorGraphTutorial.zip",children:"\u30b8\u30c3\u30d7"}),". Unzip the project and open the first header file in the Projucer."]}),"\n",(0,t.jsxs)(s.p,{children:["If you need help with this step, see ",(0,t.jsx)(s.a,{href:"../../getting-started/tutorial_new_projucer_project/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebProjucer\u30d1\u30fc\u30c81\uff1aProjucer\u3092\u59cb\u3081\u308b"}),"."]}),"\n",(0,t.jsx)(s.h1,{id:"the-demo-project",children:"The demo project"}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u306e\u30c7\u30e2\u30fb\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f\u3001\u7570\u306a\u308b\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u3092\u76f4\u5217\u306b\u9069\u7528\u3067\u304d\u308b\u30c1\u30e3\u30f3\u30cd\u30eb\u30fb\u30b9\u30c8\u30ea\u30c3\u30d7\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30c8\u3057\u3066\u3044\u307e\u3059\u3002\u500b\u5225\u306b\u30d0\u30a4\u30d1\u30b9\u3067\u304d\u308b3\u3064\u306e\u30b9\u30ed\u30c3\u30c8\u3068\u3001\u30aa\u30b7\u30ec\u30fc\u30bf\u30fc\u3001\u30b2\u30a4\u30f3\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3001\u30d5\u30a3\u30eb\u30bf\u30fc\u3092\u542b\u30803\u3064\u306e\u7570\u306a\u308b\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u304b\u3089\u9078\u629e\u3067\u304d\u308b\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u5165\u529b\u3055\u308c\u305f\u30aa\u30fc\u30c7\u30a3\u30aa\u306b\u51e6\u7406\u3092\u9069\u7528\u3057\u3001\u5909\u66f4\u3055\u308c\u305f\u4fe1\u53f7\u3092\u51fa\u529b\u306b\u4f1d\u642c\u3057\u307e\u3059\u3002"}),"\n",(0,t.jsx)(o,{src:"https://docs.juce.com/master/tutorial_audio_processor_graph_screenshot1.png",caption:"The channel strip plugin window"}),"\n",(0,t.jsx)(s.h1,{id:"setting-up-the-audioprocessorgraph",children:"Setting up the AudioProcessorGraph"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," is a special type of ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," that allows us to connect several ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," objects together as nodes in a graph and play back the result of the combined processing. In order to wire-up graph nodes together, we have to add connections between channels of nodes in the order we wish to process the audio signal."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," class also offers special node types for input and output handling of audio and midi signals within the graph. An example graph of the channel strip would look something like this when connected properly:"]}),"\n",(0,t.jsx)("p",{children:(0,t.jsx)("b",{children:"\u3053\u306e\u30d6\u30e9\u30a6\u30b6\u3067\u306fSVG\u3092\u8868\u793a\u3067\u304d\u307e\u305b\u3093: \u4ee3\u308f\u308a\u306bFirefox\u3001Chrome\u3001Safari\u3001\u307e\u305f\u306fOpera\u3092\u304a\u8a66\u3057\u304f\u3060\u3055\u3044\u3002"})}),"\n",(0,t.jsxs)(s.p,{children:["Let's start by setting up the main ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," to receive incoming signals and send them back to the corresponding output unprocessed."]}),"\n",(0,t.jsxs)(s.p,{children:["In order to reduce the character count for nested classes used frequently in this tutorial, we first declare a ",(0,t.jsx)(s.code,{children:"\u4f7f\u7528\u3057\u3066"})," for the AudioGraphIOProcessor class and the Node class in the ",(0,t.jsx)(s.code,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class as follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"using AudioGraphIOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor\uff1b\n    using Node = juce::AudioProcessorGraph::Node\uff1b\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u6b21\u306b\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30af\u30e9\u30b9\u540d\u3092\u77ed\u7e2e\u3057\u3066\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30fb\u30e1\u30f3\u30d0\u30fc\u5909\u6570\u3092\u5ba3\u8a00\u3059\u308b\uff1a"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"Node::Ptr audioInputNode\uff1b\n    Node::Ptr audioOutputNode\uff1b\n    Node::Ptr midiInputNode\uff1b\n    Node::Ptr midiOutputNode\uff1b\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Here we create pointers to the main ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," as well as the input and output processor nodes which will be instantiated later on within the graph."]}),"\n",(0,t.jsxs)(s.p,{children:["Next, in the ",(0,t.jsx)(s.code,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," contructor we set the default bus properties for the plugin and instantiate the main ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," as shown here:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\n        : AudioProcessor (BusesProperties().withInput ("Input", juce::AudioChannelSet::stereo(), true)\n                                           .withOutput ("Output", juce::AudioChannelSet::stereo(), true))\u3001\n          mainProcessor (new juce::AudioProcessorGraph())\u3001\n'})}),"\n",(0,t.jsx)(s.p,{children:"\u30d7\u30e9\u30b0\u30a4\u30f3\u3092\u6271\u3046\u306e\u3067\u3001isBusesLayoutSupported()\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3092\u5b9f\u88c5\u3057\u3066\u3001\u30d7\u30e9\u30b0\u30a4\u30f3\u30db\u30b9\u30c8\u3084DAW\u306b\u3001\u3069\u306e\u30c1\u30e3\u30f3\u30cd\u30eb\u30bb\u30c3\u30c8\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u304b\u3092\u901a\u77e5\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u3001\u3053\u306e\u3088\u3046\u306b\u30e2\u30ce\u304b\u3089\u30e2\u30ce\u3001\u30b9\u30c6\u30ec\u30aa\u304b\u3089\u30b9\u30c6\u30ec\u30aa\u306e\u69cb\u6210\u306e\u307f\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3059\uff1a"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"bool isBusesLayoutSupported (const BusesLayout& layouts) const override\n    {\n        if (layouts.getMainInputChannelSet() == juce::AudioChannelSet::disabled())\n         || layouts.getMainOutputChannelSet() == juce::AudioChannelSet::disabled())\n            false \u3092\u8fd4\u3057\u307e\u3059\uff1b\n \n        if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono())\n         && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n            false \u3092\u8fd4\u3057\u307e\u3059\uff1b\n \n        return layouts.getMainInputChannelSet() == layouts.getMainOutputChannelSet()\uff1b\n    }\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["If you want to learn more about bus layouts of plugins, please refer to ",(0,t.jsx)(s.a,{href:"../tutorial_audio_bus_layouts/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u9069\u5207\u306a\u30d0\u30b9\u30ec\u30a4\u30a2\u30a6\u30c8\u3092\u8a2d\u5b9a\u3059\u308b"}),"."]})}),"\n",(0,t.jsxs)(s.p,{children:["For the ",(0,t.jsx)(s.code,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," to be able to process audio through the graph provided, we have to override the three main functions of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," class that perform signal processing namely the prepareToPlay(), releaseResources() and processBlock() functions and call the same respective functions on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Let's start with the prepareToPlay() function. First we inform the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," on the number of I/O channels, the sample rate and the number of samples per block by calling the setPlayConfigDetails() function like follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void prepareToPlay (double sampleRate, int samplesPerBlock) override\n    {\n        mainProcessor->setPlayConfigDetails\uff08getMainBusNumInputChannels()\u3001\n                                             getMainBusNumOutputChannels()\u3001\n                                             sampleRate, samplesPerBlock)\uff1b\n \n        mainProcessor->prepareToPlay (sampleRate, samplesPerBlock)\uff1b\n \n        initialiseGraph()\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["We then call the prepareToPlay() function on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," with the same information and call the ",(0,t.jsx)(s.code,{children:"initialiseGraph()"})," helper function which we define later on to create and connect the nodes in the graph."]}),"\n",(0,t.jsxs)(s.p,{children:["The releaseResources() function is self-explanatory and simply calls the same function on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," instance:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void releaseResources() override\n    {\n        mainProcessor->releaseResources()\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Finally in the processBlock() function, we clear the samples contained in any additional channels that may contain garbage data just in case and call the ",(0,t.jsx)(s.code,{children:"updateGraph()"})," helper function later defined that will rebuild the graph if the channel strip configuration was changed. The processBlock() function is eventually called on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," at the end of the function:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer& midiMessages) override\n    {\n        for (int i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); ++i)\n            buffer.clear (i, 0, buffer.getNumSamples())\uff1b\n \n        updateGraph()\uff1b\n \n        mainProcessor->processBlock (buffer, midiMessages)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"initialiseGraph()"})," function called earlier in the prepareToPlay() callback starts by clearing the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," of any nodes and connections that were previously present. This also takes care of deleting the corresponding ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," instances associated to the deleted nodes in the graph. We then proceed to instantiate the AudioGraphIOProcessor objects for the graph I/O and add the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," objects as nodes in the graph."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void initialiseGraph()\n    {\n        mainProcessor->clear();\n \n        audioInputNode  = mainProcessor->addNode (std::make_unique (AudioGraphIOProcessor::audioInputNode));\n        audioOutputNode = mainProcessor->addNode (std::make_unique (AudioGraphIOProcessor::audioOutputNode));\n        midiInputNode   = mainProcessor->addNode (std::make_unique (AudioGraphIOProcessor::midiInputNode));\n        midiOutputNode  = mainProcessor->addNode (std::make_unique(AudioGraphIOProcessor::midiOutputNode))\uff1b\n \n        connectAudioNodes()\uff1b\n        connectMidiNodes()\uff1b\n    }\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u30aa\u30fc\u30c7\u30a3\u30aa\uff0f\u30df\u30c7\u30a3\u30c7\u30fc\u30bf\u3092\u4f1d\u642c\u3059\u308b\u305f\u3081\u306b\u3001\u30b0\u30e9\u30d5\u5185\u306e\u65b0\u3057\u304f\u4f5c\u6210\u3055\u308c\u305f\u30ce\u30fc\u30c9\u9593\u306b\u63a5\u7d9a\u3092\u8ffd\u52a0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u3053\u308c\u306f\u4ee5\u4e0b\u306e\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff1a"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void connectAudioNodes()\n    {\n        for (int channel = 0; channel < 2; ++channel)\n            mainProcessor->addConnection ({ audioInputNode->nodeID, channel }\u3001\n                                            { audioOutputNode->nodeID, channel }); }.});\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Here we call the addConnection() function on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," instance by passing the source and destination nodes we wish to connect in the form of a Connection object. These require a nodeID and a channel index for building the appropriate connections and the whole process is repeated for all the required channels."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void connectMidiNodes()\n    {\n        mainProcessor->addConnection ({ midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex }\u3001\n                                        juce::AudioProcessorGraph::midiChannelIndex }, { midiOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex }.});\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The same is performed on the midi I/O nodes with the exception of the channel index argument. Since the midi signals are not sent through regular audio channels, we have to supply a special channel index specified as an enum in the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," class."]}),"\n",(0,t.jsx)(s.p,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306e\u3053\u306e\u6bb5\u968e\u3067\u306f\u3001\u4fe1\u53f7\u304c\u30b0\u30e9\u30d5\u3092\u901a\u904e\u3059\u308b\u97f3\u3092\u3001\u5909\u5316\u3055\u305b\u308b\u3053\u3068\u306a\u304f\u805e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u306f\u305a\u3060\u3002"}),"\n",(0,t.jsx)(s.admonition,{type:"warning",children:(0,t.jsx)(s.p,{children:"\u5185\u8535\u5165\u51fa\u529b\u3067\u30d7\u30e9\u30b0\u30a4\u30f3\u3092\u30c6\u30b9\u30c8\u3059\u308b\u5834\u5408\u3001\u60b2\u9cf4\u306e\u3088\u3046\u306a\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30d8\u30c3\u30c9\u30db\u30f3\u3092\u4f7f\u3048\u3070\u3053\u306e\u554f\u984c\u3092\u56de\u907f\u3067\u304d\u307e\u3059\u3002"})}),"\n",(0,t.jsx)(s.h1,{id:"implementing-different-processors",children:"Implementing different processors"}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306e\u30d1\u30fc\u30c8\u3067\u306f\u3001\u5165\u529b\u3055\u308c\u308b\u30aa\u30fc\u30c7\u30a3\u30aa\u4fe1\u53f7\u3092\u5909\u5316\u3055\u305b\u308b\u305f\u3081\u306b\u3001\u30c1\u30e3\u30f3\u30cd\u30eb\u30b9\u30c8\u30ea\u30c3\u30d7\u30d7\u30e9\u30b0\u30a4\u30f3\u5185\u3067\u4f7f\u7528\u3067\u304d\u308b\u3055\u307e\u3056\u307e\u306a\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\u4ed6\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u3092\u4f5c\u3063\u305f\u308a\u3001\u4ee5\u4e0b\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u3092\u597d\u307f\u306b\u5408\u308f\u305b\u3066\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3057\u3066\u304f\u3060\u3055\u3044\u3002"}),"\n",(0,t.jsxs)(s.p,{children:["In order to avoid repeated code for the different processors we want to create, let's start by declaring an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," base class that will be inherited by the individual processors and override the necessary functions only once for simplicity's sake."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'class ProcessorBase : public juce::AudioProcessor\n{\n\u3092\u516c\u958b\u3057\u307e\u3059\uff1a\n    //==============================================================================\n    \u30d7\u30ed\u30bb\u30c3\u30b5\u30d9\u30fc\u30b9()\n        : AudioProcessor(BusesProperties().withInput("Input", juce::AudioChannelSet::stereo())\n                                           .withOutput("Output", juce::AudioChannelSet::stereo()))\n    {}\n \n    //==============================================================================\n    void prepareToPlay (double, int) override {} \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9 {}.\n    void releaseResources() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9 {}.\n    void processBlock (juce::AudioSampleBuffer&, juce::MidiBuffer&) override {}.\n \n    //==============================================================================\n    juce::AudioProcessorEditor* createEditor() override { return nullptr; }.\n    bool hasEditor() const override { return false; }.\n \n    //==============================================================================\n    juce::String getName() override { return {}; } // juce::String getName() override { return {}; }\n    bool acceptsMidi() const override { return false; }.\n    bool producesMidi() const override { return false; }.\n    double getTailLengthSeconds() const override { return 0; }.\n \n    //==============================================================================\n    int getNumPrograms() override { return 0; }.\n    int getCurrentProgram() override { return 0; }.\n    void setCurrentProgram(int) override {}.\n    const juce::String getProgramName (int) override { return {}; }.\n    void changeProgramName (int, const juce::String&) override {}.\n \n    //==============================================================================\n    void getStateInformation (juce::MemoryBlock&) override {}\n    void setStateInformation (const void*, int) override {}.\n \n\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\uff1a\n    //==============================================================================\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ProcessorBase)\n};\n'})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["The following three processors will make use of the DSP module to facilitate implementation and if you want to learn more about DSP you can refer to ",(0,t.jsx)(s.a,{href:"../../dsp/tutorial_dsp_introduction/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebDSP\u5165\u9580"})," for a more in-depth explanation."]})}),"\n",(0,t.jsx)(s.h2,{id:"implementing-an-oscillator",children:"Implementing an oscillator"}),"\n",(0,t.jsx)(s.p,{children:"\u6700\u521d\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u306f\u3001440Hz\u306e\u4e00\u5b9a\u306e\u6b63\u5f26\u6ce2\u30c8\u30fc\u30f3\u3092\u751f\u6210\u3059\u308b\u30b7\u30f3\u30d7\u30eb\u306a\u30aa\u30b7\u30ec\u30fc\u30bf\u30fc\u3067\u3042\u308b\u3002"}),"\n",(0,t.jsxs)(s.p,{children:["We derive the ",(0,t.jsx)(s.code,{children:"\u30aa\u30b7\u30ec\u30fc\u30bf\u30fc\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class from the previously-defined ",(0,t.jsx)(s.code,{children:"\u30d7\u30ed\u30bb\u30c3\u30b5\u30d9\u30fc\u30b9"}),", override the getName() function to provide a meaningful name and declare a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Oscillator",title:"Generates a signal based on a user-supplied function.",children:"dsp::Oscillator"})," object from the DSP module:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'class OscillatorProcessor  : public ProcessorBase\n{\npublic:\n    //...\n    const juce::String getName() const override { return "Oscillator"; }\n \nprivate:\n    juce::dsp::Oscillator\u767a\u632f\u5668\n};\n'})}),"\n",(0,t.jsxs)(s.p,{children:["In the constructor, we set the frequency and the waveform of the oscillator by calling respectively the setFrequency() and initialise() functions on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Oscillator",title:"Generates a signal based on a user-supplied function.",children:"dsp::Oscillator"})," object as follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"OscillatorProcessor()\n    {\n        oscillator.setFrequency (440.0f)\uff1b\n        oscillator.initialise ([] (float x) { return std::sin (x); })\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In the prepareToPlay() function, we create a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessSpec",title:"This structure is passed into a DSP algorithm's prepare() method, and contains information about vari...",children:"dsp::ProcessSpec"})," object to describe the sample rate and number of samples per block to the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Oscillator",title:"Generates a signal based on a user-supplied function.",children:"dsp::Oscillator"})," object and pass the specifications by calling the prepare() function on it like so:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void prepareToPlay (double sampleRate, int samplesPerBlock) override\n    {\n        juce::dsp::ProcessSpec spec { sampleRate, static_cast(samplesPerBlock\uff09, 2 }\uff1b\n        oscillator.prepare (spec)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Next, in the processBlock() function we create a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1AudioBlock",title:"Minimal and lightweight data-structure which contains a list of pointers to channels containing some ...",children:"dsp::AudioBlock"})," object from the AudioSampleBuffer passed as an argument and declare the processing context from it as a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessContextReplacing",title:"Contains context information that is passed into an algorithm's process method.",children:"dsp::ProcessContextReplacing"})," object that is subsequently passed to the process() function of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Oscillator",title:"Generates a signal based on a user-supplied function.",children:"dsp::Oscillator"})," object as shown here:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override\n    {\n        juce::dsp::AudioBlock block (buffer);\n        juce::dsp::ProcessContextReplacing\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\uff08\u30d6\u30ed\u30c3\u30af\uff09\uff1b\n        oscillator.process (context)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Finally, we can reset the state of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Oscillator",title:"Generates a signal based on a user-supplied function.",children:"dsp::Oscillator"})," object by overriding the reset() function of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," and calling the same function onto it:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void reset() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        oscillator.reset()\uff1b\n    }\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u308c\u3067\u3001\u30c1\u30e3\u30f3\u30cd\u30eb\u30fb\u30b9\u30c8\u30ea\u30c3\u30d7\u30fb\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u4f7f\u3048\u308b\u30aa\u30b7\u30ec\u30fc\u30bf\u30fc\u304c\u3067\u304d\u307e\u3057\u305f\u3002"}),"\n",(0,t.jsx)(s.p,{children:"\u767a\u632f\u5668\u306einitialise()\u95a2\u6570\u3092\u5909\u66f4\u3057\u3066\u3001\u7570\u306a\u308b\u6ce2\u5f62\u3092\u751f\u6210\u3057\u3001\u30bf\u30fc\u30b2\u30c3\u30c8\u5468\u6ce2\u6570\u3092\u5909\u66f4\u3059\u308b\u3002"}),"\n",(0,t.jsx)(s.h2,{id:"implementing-a-gain-control",children:"Implementing a gain control"}),"\n",(0,t.jsx)(s.p,{children:"\u3064\u76ee\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u306f\u3001\u5165\u529b\u4fe1\u53f7\u3092-6dB\u6e1b\u8870\u3055\u305b\u308b\u30b7\u30f3\u30d7\u30eb\u306a\u30b2\u30a4\u30f3\u30fb\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3067\u3042\u308b\u3002"}),"\n",(0,t.jsxs)(s.p,{children:["We derive the ",(0,t.jsx)(s.code,{children:"\u30b2\u30a4\u30f3\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class from the previously-defined ",(0,t.jsx)(s.code,{children:"\u30d7\u30ed\u30bb\u30c3\u30b5\u30d9\u30fc\u30b9"}),", override the getName() function to provide a meaningful name and declare a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Gain",title:"Applies a gain to audio samples as single samples or AudioBlocks.",children:"dsp::Gain"})," object from the DSP module:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'class GainProcessor  : public ProcessorBase\n{\npublic:\n    //...\n    const juce::String getName() const override { return "Gain"; }\n \nprivate:\n    juce::dsp::Gain\u30b2\u30a4\u30f3\uff1b\n};\n'})}),"\n",(0,t.jsxs)(s.p,{children:["In the constructor, we set the gain in decibels of the gain control by calling the setGainDecibels() function on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Gain",title:"Applies a gain to audio samples as single samples or AudioBlocks.",children:"dsp::Gain"})," object as follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"\u30b2\u30a4\u30f3\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc()\n    {\n        gain.setGainDecibels (-6.0f)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In the prepareToPlay() function, we create a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessSpec",title:"This structure is passed into a DSP algorithm's prepare() method, and contains information about vari...",children:"dsp::ProcessSpec"})," object to describe the sample rate, number of samples per block and number of channels to the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Gain",title:"Applies a gain to audio samples as single samples or AudioBlocks.",children:"dsp::Gain"})," object and pass the specifications by calling the prepare() function on it like so:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void prepareToPlay (double sampleRate, int samplesPerBlock) override\n    {\n        juce::dsp::ProcessSpec spec { sampleRate, static_cast(samplesPerBlock\uff09, 2 }\uff1b\n        gain.prepare (spec)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Next, in the processBlock() function we create a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1AudioBlock",title:"Minimal and lightweight data-structure which contains a list of pointers to channels containing some ...",children:"dsp::AudioBlock"})," object from the AudioSampleBuffer passed as an argument and declare the processing context from it as a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessContextReplacing",title:"Contains context information that is passed into an algorithm's process method.",children:"dsp::ProcessContextReplacing"})," object that is subsequently passed to the process() function of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Gain",title:"Applies a gain to audio samples as single samples or AudioBlocks.",children:"dsp::Gain"})," object as shown here:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override\n    {\n        juce::dsp::AudioBlock block (buffer);\n        juce::dsp::ProcessContextReplacing\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\uff08\u30d6\u30ed\u30c3\u30af\uff09\uff1b\n        gain.process (context)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Finally, we can reset the state of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1Gain",title:"Applies a gain to audio samples as single samples or AudioBlocks.",children:"dsp::Gain"})," object by overriding the reset() function of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," and calling the same function onto it:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void reset() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        \u30b2\u30a4\u30f3.\u30ea\u30bb\u30c3\u30c8()\uff1b\n    }\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u308c\u3067\u3001\u30c1\u30e3\u30f3\u30cd\u30eb\u30fb\u30b9\u30c8\u30ea\u30c3\u30d7\u30fb\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u4f7f\u3048\u308b\u30b2\u30a4\u30f3\u30fb\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u304c\u3067\u304d\u307e\u3057\u305f\u3002"}),"\n",(0,t.jsx)(s.p,{children:"\u30b2\u30a4\u30f3\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u306esetGainDecibels()\u95a2\u6570\u3092\u5909\u66f4\u3057\u3066\u3001\u3055\u3089\u306b\u30b2\u30a4\u30f3\u3092\u4e0b\u3052\u305f\u308a\u3001\u4fe1\u53f7\u3092\u30d6\u30fc\u30b9\u30c8\u3057\u305f\u308a\u3059\u308b\u3002(\u30d6\u30fc\u30b9\u30c8\u3059\u308b\u3068\u304d\u306f\u3001\u30ec\u30d9\u30eb\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\uff01\uff09\u3002"}),"\n",(0,t.jsx)(s.h2,{id:"implementing-a-filter",children:"Implementing a filter"}),"\n",(0,t.jsx)(s.p,{children:"3\u3064\u76ee\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u306f\u30011kHz\u4ee5\u4e0b\u306e\u5468\u6ce2\u6570\u3092\u4e0b\u3052\u308b\u30b7\u30f3\u30d7\u30eb\u306a\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc\u3060\u3002"}),"\n",(0,t.jsxs)(s.p,{children:["We derive the ",(0,t.jsx)(s.code,{children:"\u30d5\u30a3\u30eb\u30bf\u30fc\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class from the previously-defined ",(0,t.jsx)(s.code,{children:"\u30d7\u30ed\u30bb\u30c3\u30b5\u30d9\u30fc\u30b9"}),", override the getName() function to provide a meaningful name and declare a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator",title:"Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...",children:"dsp::ProcessorDuplicator"})," object from the DSP module. This allows us to use a mono processor of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1IIR_1_1Filter",title:"A processing class that can perform IIR filtering on an audio signal, using the Transposed Direct For...",children:"dsp::IIR::Filter"})," class and convert it into a multi-channel version by providing its shared state as a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1IIR_1_1Coefficients",title:"A set of coefficients for use in an Filter object.",children:"dsp::IIR::Coefficients"})," class:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'class FilterProcessor  : public ProcessorBase\n{\npublic:\n    FilterProcessor() {}\n    //...\n    const juce::String getName() const override { return "Filter"; }\n \nprivate:\n    juce::dsp::ProcessorDuplicator, juce::dsp::IIR::Coefficients> \u30d5\u30a3\u30eb\u30bf\u30fc\uff1b\n};\n'})}),"\n",(0,t.jsxs)(s.p,{children:["In the prepareToPlay() function, we first generate the coefficients used for the filter by using the makeHighPass() function and assign it as the shared processing state to the duplicator. We then create a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessSpec",title:"This structure is passed into a DSP algorithm's prepare() method, and contains information about vari...",children:"dsp::ProcessSpec"})," object to describe the sample rate, number of samples per block and number of channels to the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator",title:"Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...",children:"dsp::ProcessorDuplicator"})," object and pass the specifications by calling the prepare() function on it like so:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void prepareToPlay (double sampleRate, int samplesPerBlock) override\n    {\n        *filter.state = *juce::dsp::IIR::Coefficients::makeHighPass (sampleRate, 1000.0f);\n \n        juce::dsp::ProcessSpec spec { sampleRate, static_cast(samplesPerBlock\uff09, 2 }\uff1b\n        filter.prepare (spec)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Next, in the processBlock() function we create a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classdsp_1_1AudioBlock",title:"Minimal and lightweight data-structure which contains a list of pointers to channels containing some ...",children:"dsp::AudioBlock"})," object from the AudioSampleBuffer passed as an argument and declare the processing context from it as a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessContextReplacing",title:"Contains context information that is passed into an algorithm's process method.",children:"dsp::ProcessContextReplacing"})," object that is subsequently passed to the process() function of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator",title:"Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...",children:"dsp::ProcessorDuplicator"})," object as shown here:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override\n    {\n        juce::dsp::AudioBlock block (buffer);\n        juce::dsp::ProcessContextReplacing\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\uff08\u30d6\u30ed\u30c3\u30af\uff09\uff1b\n        filter.process (context)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Finally, we can reset the state of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator",title:"Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...",children:"dsp::ProcessorDuplicator"})," object by overriding the reset() function of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," and calling the same function onto it:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"void reset() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        filter.reset()\uff1b\n    }\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u308c\u3067\u30c1\u30e3\u30f3\u30cd\u30eb\u30fb\u30b9\u30c8\u30ea\u30c3\u30d7\u30fb\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u4f7f\u3048\u308b\u30d5\u30a3\u30eb\u30bf\u30fc\u304c\u3067\u304d\u305f\u3002"}),"\n",(0,t.jsx)(s.p,{children:"\u30d5\u30a3\u30eb\u30bf\u306e\u4fc2\u6570\u3092\u5909\u66f4\u3057\u3066\u3001\u30ab\u30c3\u30c8\u30aa\u30d5\u5468\u6ce2\u6570\u3068\u5171\u632f\u304c\u7570\u306a\u308b\u30ed\u30fc\u30d1\u30b9\u307e\u305f\u306f\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002"}),"\n",(0,t.jsx)(s.h1,{id:"connecting-graph-nodes-together",children:"Connecting graph nodes together"}),"\n",(0,t.jsxs)(s.p,{children:["Now that we have implemented multiple processors that can be used within the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),", let's start connecting them together depending on the user selection."]}),"\n",(0,t.jsxs)(s.p,{children:["In the ",(0,t.jsx)(s.code,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class, we add three ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioParameterChoice",title:"Provides a class of AudioProcessorParameter that can be used to select an indexed,...",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d1\u30e9\u30e1\u30fc\u30bf\u9078\u629e"})," and four ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioParameterBool",title:"Provides a class of AudioProcessorParameter that can be used as a boolean value.",children:"AudioParameterBool"})," pointers as private member variables to store the parameters chosen in the channel strip and their corresponding bypass states. We also declare node pointers to the three processor slots when later instantiated within the graph and provide the selectable choices as a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classStringArray",title:"A special array for holding a list of strings.",children:"\u6587\u5b57\u5217\u914d\u5217"})," for convenience."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'    juce::StringArray processorChoices { "Empty", "Oscillator", "Gain", "Filter" };\n \n    std::unique_ptrmainProcessor\uff1b\n \n    juce::AudioParameterBool* muteInput\uff1b\n \n    juce::AudioParameterChoice* processorSlot1\uff1b\n    juce::AudioParameterChoice* processorSlot2\uff1b\n    juce::AudioParameterChoice* processorSlot3\uff1b\n \n    juce::AudioParameterBool* bypassSlot1\uff1b\n    juce::AudioParameterBool* bypassSlot2\uff1b\n    juce::AudioParameterBool* bypassSlot3\uff1b\n \n    Node::Ptr audioInputNode\uff1b\n    Node::Ptr audioOutputNode\uff1b\n    Node::Ptr midiInputNode\uff1b\n    Node::Ptr midiOutputNode\uff1b\n \n    Node::Ptr slot1Node\uff1b\n    Node::Ptr slot2Node\uff1b\n    Node::Ptr slot3Node\uff1b\n \n    //==============================================================================\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)\n};\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Then in the constructor we can instantiate the audio parameters and call the addParameter() function to tell the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," about which parameters should be available in the plugin."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\n        : AudioProcessor (BusesProperties().withInput ("Input", juce::AudioChannelSet::stereo(), true)\n                                           .withOutput ("Output", juce::AudioChannelSet::stereo(), true))\u3001\n          mainProcessor (new juce::AudioProcessorGraph())\u3001\n          muteInput (new juce::AudioParameterBool ("mute", "Mute Input", true))\u3001\n          processorSlot1 (new juce::AudioParameterChoice ("slot1", "Slot 1", processorChoices, 0))\u3001\n          processorSlot2 (new juce::AudioParameterChoice ("slot2", "Slot 2", processorChoices, 0))\u3001\n          processorSlot3 (new juce::AudioParameterChoice ("slot3", "Slot 3", processorChoices, 0))\u3001\n          bypassSlot1 (new juce::AudioParameterBool ("bypass1", "Bypass 1", false))\u3001\n          bypassSlot2 (new juce::AudioParameterBool ("bypass2", "Bypass 2", false))\u3001\n          bypassSlot3 (new juce::AudioParameterBool ("bypass3", "Bypass 3", false)))\n    {\n        addParameter (muteInput)\uff1b\n \n        addParameter (processorSlot1)\uff1b\n        addParameter (processorSlot2)\uff1b\n        addParameter (processorSlot3)\uff1b\n \n        addParameter (bypassSlot1)\uff1b\n        addParameter (bypassSlot2)\uff1b\n        addParameter (bypassSlot3)\uff1b\n    }\n'})}),"\n",(0,t.jsxs)(s.p,{children:["This tutorial makes use of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classGenericAudioProcessorEditor",title:"A type of UI component that displays the parameters of an AudioProcessor as a simple list of sliders,...",children:"GenericAudioProcessorEditor (\u30b8\u30a7\u30cd\u30ea\u30c3\u30af\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30a8\u30c7\u30a3\u30bf\u30fc)"})," class, which automatically creates a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classComboBox",title:"A component that lets the user choose from a drop-down list of choices.",children:"\u30b3\u30f3\u30dc\u30dc\u30c3\u30af\u30b9"})," for each of the parameters in the plug-in's processor that is an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioParameterChoice",title:"Provides a class of AudioProcessorParameter that can be used to select an indexed,...",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d1\u30e9\u30e1\u30fc\u30bf\u9078\u629e"})," type and a ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classToggleButton",title:"A button that can be toggled on/off.",children:"\u30c8\u30b0\u30eb\u30dc\u30bf\u30f3"})," for each ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioParameterBool",title:"Provides a class of AudioProcessorParameter that can be used as a boolean value.",children:"AudioParameterBool"})," type."]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["To learn more about audio parameters and how to customise them, please refer to ",(0,t.jsx)(s.a,{href:"../tutorial_audio_parameter/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30e9\u30b0\u30a4\u30f3\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u8ffd\u52a0"}),". For a more seamless and elegant method for saving and loading parameters, you can take a look at ",(0,t.jsx)(s.a,{href:"../tutorial_audio_processor_value_tree_state/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30e9\u30b0\u30a4\u30f3\u72b6\u614b\u306e\u4fdd\u5b58\u3068\u8aad\u307f\u8fbc\u307f"}),"."]})}),"\n",(0,t.jsxs)(s.p,{children:["In the first part of the tutorial when setting up the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),", we noticed that we call the ",(0,t.jsx)(s.code,{children:"updateGraph()"})," helper function in the processBlock() callback of the ",(0,t.jsx)(s.code,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class. The purpose of this function is to update the graph by reinstantiating the proper ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," objects and nodes as well as reconnecting the graph depending on the current choices selected by the user so let's implement that helper function like this:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    void updateGraph()\n    {\n        bool hasChanged = false;\n \n        juce::Array choices { processorSlot1,\n                                                           processorSlot2,\n                                                           processorSlot3 };\n \n        juce::Array bypasses { bypassSlot1,\n                                                          bypassSlot2,\n                                                          bypassSlot3 };\n \n        juce::ReferenceCountedArray\u30b9\u30ed\u30c3\u30c8\u3092\u8ffd\u52a0\u3057\u307e\u3059\uff1b\n        slots.add (slot1Node)\uff1b\n        slots.add (slot2Node)\uff1b\n        slots.add (slot3Node)\uff1b\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u306e\u95a2\u6570\u306f\u3001\u30b0\u30e9\u30d5\u306e\u72b6\u614b\u3092\u8868\u3059\u30ed\u30fc\u30ab\u30eb\u5909\u6570\u3068\u3001\u30aa\u30fc\u30c7\u30a3\u30aa\u30d6\u30ed\u30c3\u30af\u51e6\u7406\u306e\u6700\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u304b\u3089\u5909\u66f4\u3055\u308c\u305f\u304b\u3069\u3046\u304b\u3092\u5ba3\u8a00\u3059\u308b\u3053\u3068\u304b\u3089\u59cb\u307e\u308a\u307e\u3059\u3002\u307e\u305f\u3001\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u9078\u629e\u80a2\u3001\u30d0\u30a4\u30d1\u30b9\u306e\u72b6\u614b\u3001\u304a\u3088\u3073\u30b0\u30e9\u30d5\u5185\u306e\u5bfe\u5fdc\u3059\u308b\u30ce\u30fc\u30c9\u306e\u53cd\u5fa9\u51e6\u7406\u3092\u5bb9\u6613\u306b\u3059\u308b\u305f\u3081\u306e\u914d\u5217\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002"}),"\n",(0,t.jsxs)(s.p,{children:["In the next part, we iterate over the three available processor slots and check the options that were selected for each of the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioParameterChoice",title:"Provides a class of AudioProcessorParameter that can be used to select an indexed,...",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d1\u30e9\u30e1\u30fc\u30bf\u9078\u629e"})," objects as follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:'        for (int i = 0; i < 3; ++i)\n        {\n            auto& choice = choices.getReference (i);\n            auto  slot   = slots  .getUnchecked (i);\n \n            if (choice->getIndex() == 0)            // [1]\n            {\n                if (slot != nullptr)\n                {\n                    mainProcessor->removeNode (slot.get());\n                    slots.set (i, nullptr);\n                    hasChanged = true;\n                }\n            }\n            else if (choice->getIndex() == 1)       // [2]\n            {\n                if (slot != nullptr)\n                {\n                    if (slot->getProcessor()->getName() == "Oscillator")\n                        continue;\n \n                    mainProcessor->removeNode (slot.get());\n                }\n \n                slots.set (i, mainProcessor->addNode (std::make_unique()));\n                hasChanged = true;\n            }\n            else if (choice->getIndex() == 2)       // [3]\n            {\n                if (slot != nullptr)\n                {\n                    if (slot->getProcessor()->getName() == "Gain")\n                        continue;\n \n                    mainProcessor->removeNode (slot.get());\n                }\n \n                slots.set (i, mainProcessor->addNode (std::make_unique()));\n                hasChanged = true;\n            }\n            else if (choice->getIndex() == 3)       // [4]\n            {\n                if (slot != nullptr)\n                {\n                    if (slot->getProcessor()->getName() == "Filter")\n                        continue;\n \n                    mainProcessor->removeNode (slot.get());\n                }\n \n                slots.set (i, mainProcessor->addNode (std::make_unique()));\n                hasChanged = true\uff1b\n            }\n        }\n'})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:['[1]: If the choice remains in the "Empty" state, we first check whether the node was previously instantiated to a different processor and if so, we remove the node from the graph, clear the reference to the node and set the ',(0,t.jsx)(s.code,{children:"hasChanged"})," flag to true. Otherwise, the state has not changed and the graph does not need rebuilding."]}),"\n",(0,t.jsxs)(s.li,{children:['[2]: If the user chooses the "Oscillator" state, we first check whether the currently instantiated node is already an oscillator processor and if so, the state has not changed and we continue onto the next slot. Otherwise, if the slot was already occupied we remove the node from the graph, set the reference to a new node by instantiating the oscillator and set the ',(0,t.jsx)(s.code,{children:"hasChanged"})," flag to true."]}),"\n",(0,t.jsx)(s.li,{children:'[3]: We proceed to do the same for the "Gain" state and instantiate a gain processor if necessary.'}),"\n",(0,t.jsx)(s.li,{children:'[4]: Again, we repeat the same process for the "Filter" state and instantiate a filter processor if needed.'}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"\u6b21\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u306f\u3001\u30b0\u30e9\u30d5\u306e\u72b6\u614b\u304c\u5909\u5316\u3057\u305f\u5834\u5408\u306b\u306e\u307f\u5b9f\u884c\u3055\u308c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30ce\u30fc\u30c9\u306e\u63a5\u7d9a\u3092\u958b\u59cb\u3059\u308b\uff1a"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"        if (hasChanged)\n        {\n            for (auto connection : mainProcessor->getConnections())     // [5]\n                mainProcessor->removeConnection (connection);\n \n            juce::ReferenceCountedArray\u30a2\u30af\u30c6\u30a3\u30d6\u30b9\u30ed\u30c3\u30c8\uff1b\n \n            for (auto slot : slots)\n            {\n                if (slot != nullptr)\n                {\n                    activeSlots.add (slot); // [6].\n \n                    slot->getProcessor()->setPlayConfigDetails (getMainBusNumInputChannels()\u3001\n                                                                getMainBusNumOutputChannels()\u3001\n                                                                getSampleRate(), getBlockSize())\uff1b\n                }\n            }\n \n            if (activeSlots.isEmpty()) // [7].\n            {\n                connectAudioNodes()\uff1b\n            }\n            else\n            {\n                for (int i = 0; i < activeSlots.size() - 1; ++i) // [8].\n                {\n                    for (int channel = 0; channel < 2; ++channel)\n                        mainProcessor->addConnection ({ { activeSlots.getUnchecked (i)->nodeID, channel }\u3001\n                                                        { activeSlots.getUnchecked (i + 1)->nodeID, channel }.});\n                }\n \n                for (int channel = 0; channel < 2; ++channel) // [9].\n                {\n                    mainProcessor->addConnection ({ { audioInputNode->nodeID, channel }\u3001\n                                                    { activeSlots.getFirst()->nodeID, channel }.});\n                    mainProcessor->addConnection ({ { activeSlots.getLast()->nodeID, channel }\u3001\n                                                    { audioOutputNode->nodeID, channel }.});\n                }\n            }\n \n            connectMidiNodes()\uff1b\n \n            for (auto node : mainProcessor->getNodes()) // [10].\n                node->getProcessor()->enableAllBuses()\uff1b\n        }\n"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"[5]: First we remove all the connections in the graph to start from a blank state."}),"\n",(0,t.jsxs)(s.li,{children:["[6]: Then, we iterate over the slots and check whether they have an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," node within the graph. If so we add the node to our temporary array of active nodes and make sure to call the setPlayConfigDetails() function on the corresponding processor instance with channel, sample rate and block size information to prepare the node for future processing."]}),"\n",(0,t.jsx)(s.li,{children:'[7]: Next, if there are no active slots found this means that all the choices are in an "Empty" state and the audio I/O processor nodes can be simply connected together.'}),"\n",(0,t.jsx)(s.li,{children:"[8]: Otherwise, it means that there is at least one node that should lie between the audio I/O processor nodes. Therefore we can start connecting the active slots together in an ascending order of slot number. Notice here that the number of pairs of connections we need is only the number of active slots minus one."}),"\n",(0,t.jsx)(s.li,{children:"[9]: We can then finish connecting the graph by linking the audio input processor node to the first active slot in the chain and the last active slot to the audio output processor node."}),"\n",(0,t.jsx)(s.li,{children:"[10]: Finally, we connect the midi I/O nodes together and make sure that all the buses in the audio processors are enabled."}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"for (int i = 0; i < 3; ++i)\n        {\n            auto slot = slots .getUnchecked (i)\uff1b\n            auto& bypass = bypasses.getReference (i)\uff1b\n \n            if (slot != nullptr)\n                slot->setBypassed (bypass->get())\uff1b\n        }\n \n        audioInputNode->setBypassed (muteInput->get())\uff1b\n \n        slot1Node = slots.getUnchecked (0)\uff1b\n        slot2Node = slots.getUnchecked (1)\uff1b\n        slot3Node = slots.getUnchecked (2)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In the last section of the ",(0,t.jsx)(s.code,{children:"updateGraph()"})," helper function, we deal with the bypass state of the processors by checking whether the slot is active and bypass the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," if the check box is toggled. We also check whether to mute the input to avoid feedback loops when testing. Then, we assign back the newly-created nodes to their corresponding slots for the next iteration."]}),"\n",(0,t.jsx)(s.p,{children:"\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30b0\u30e9\u30d5\u5185\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u3092\u901a\u3057\u3066\u5165\u529b\u3055\u308c\u305f\u30aa\u30fc\u30c7\u30a3\u30aa\u3092\u51e6\u7406\u3057\u3001\u5b9f\u884c\u3055\u308c\u308b\u306f\u305a\u3067\u3059\u3002"}),"\n",(0,t.jsxs)(s.p,{children:["Create an additional processor node of your choice and add it to the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),". (For example a processor handling midi messages.)"]}),"\n",(0,t.jsx)(s.h1,{id:"convert-the-plugin-into-an-application",children:"Convert the plugin into an application"}),"\n",(0,t.jsxs)(s.p,{children:["If you are interested in using the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," within a standalone app, this optional section will delve into this in detail."]}),"\n",(0,t.jsxs)(s.p,{children:["First of all, we have to convert our main ",(0,t.jsx)(s.code,{children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc"})," class into a subclass of ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classComponent",title:"The base class for all JUCE user-interface objects.",children:"\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})," instead of ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"}),". To match the naming convention of other JUCE GUI applications we also rename the class name to ",(0,t.jsx)(s.code,{children:"\u30e1\u30a4\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})," as follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"class MainComponent : public juce::Component\u3001\n                       private juce::Timer\n{\npublic\uff1a\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:['If using a PIP file to follow this tutorial, make sure to change the "mainClass" and "type" fields to reflect the change and amend the "dependencies" field appropriately. If using the ZIP version of the project, make sure that the ',(0,t.jsx)(s.code,{children:"\u30e1\u30a4\u30f3.cpp"}),' file follows the "GUI Application" template format.']})}),"\n",(0,t.jsxs)(s.p,{children:["When creating a plugin, all the IO device management and playback functionalities are controlled by the host and therefore we don't need to worry about setting these up. However, in a standalone application we have to manage this ourselves. This is why we declare an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioDeviceManager",title:"Manages the state of some audio and midi i/o devices.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30d0\u30a4\u30b9\u30de\u30cd\u30fc\u30b8\u30e3\u30fc"})," and an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," as private member variables in the ",(0,t.jsx)(s.code,{children:"\u30e1\u30a4\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})," class to allow communication between our ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," and the audio IO devices available on the system."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"juce::AudioDeviceManager deviceManager\uff1b\n    juce::AudioProcessorPlayer player\uff1b\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioDeviceManager",title:"Manages the state of some audio and midi i/o devices.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30d0\u30a4\u30b9\u30de\u30cd\u30fc\u30b8\u30e3\u30fc"})," is a convenient class that manages audio and midi devices on all platforms and the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," allows for easy playback through an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["In the constructor, instead of initialising plugin parameters we create regular GUI components and initialise the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioDeviceManager",title:"Manages the state of some audio and midi i/o devices.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30c7\u30d0\u30a4\u30b9\u30de\u30cd\u30fc\u30b8\u30e3\u30fc"})," and the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," like so:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"\u30e1\u30a4\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\n        : mainProcessor (new juce::AudioProcessorGraph())\n    {\n"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"auto inputDevice = juce::MidiInput::getDefaultDevice()\uff1b\n        auto outputDevice = juce::MidiOutput::getDefaultDevice()\uff1b\n \n        mainProcessor->enableAllBuses()\uff1b\n \n        deviceManager.initialiseWithDefaultDevices (2, 2); // [1].\n        deviceManager.addAudioCallback (&player); // [2].\n        deviceManager.setMidiInputDeviceEnabled (inputDevice.identifier, true)\uff1b\n        deviceManager.addMidiInputDeviceCallback (inputDevice.identifier, &player); // [3].\n        deviceManager.setDefaultMidiOutputDevice (outputDevice.identifier)\uff1b\n \n        initialiseGraph()\uff1b\n \n        player.setProcessor (mainProcessor.get()); // [4] \u30d7\u30ec\u30a4\u30e4\u30fc\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u8a2d\u5b9a\u3057\u307e\u3059\u3002\n \n        setSize (600, 400)\uff1b\n        startTimer (100)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Here we first initialise the device manager with the default audio device and two inputs and outputs each [1]. We then add the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," as an audio callback to the device manager [2] and as a midi callback by using the default midi device [3]. After graph initialisation, we can set the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," as the processor to play by calling the setProcessor() function on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," [4]."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"~\u30e1\u30a4\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        auto device = juce::MidiInput::getDefaultDevice()\uff1b\n \n        deviceManager.removeAudioCallback (&player)\uff1b\n        deviceManager.setMidiInputDeviceEnabled (device.identifier, false)\uff1b\n        deviceManager.removeMidiInputDeviceCallback (device.identifier, &player)\uff1b\n    }\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Then in the destructor, we make sure to remove the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," as an audio and midi callback on application shutdown."]}),"\n",(0,t.jsxs)(s.p,{children:["Notice that unlike the plugin implementation, the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," deals with processing the audio automatically and therefore it will take care of calling the prepareToPlay() and processBlock() functions on the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," for us."]}),"\n",(0,t.jsxs)(s.p,{children:["However we still need to find a way to update the graph when the user changes parameters and we do so by deriving the ",(0,t.jsx)(s.code,{children:"\u30e1\u30a4\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})," from the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classTimer",title:"Makes repeated callbacks to a virtual method at a specified time interval.",children:"\u30bf\u30a4\u30de\u30fc"})," class and overriding the timerCallback() function like so:"]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsx)(s.p,{children:"\u30bf\u30a4\u30de\u30fc\u306e\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u306f\u3001\u6700\u3082\u52b9\u7387\u7684\u306a\u89e3\u6c7a\u7b56\u3067\u306f\u306a\u304f\u3001\u4e00\u822c\u7684\u306b\u306f\u3001\u9069\u5207\u306a\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u30ea\u30b9\u30ca\u30fc\u3068\u3057\u3066\u767b\u9332\u3059\u308b\u3053\u3068\u304c\u30d9\u30b9\u30c8\u30d7\u30e9\u30af\u30c6\u30a3\u30b9\u3067\u3042\u308b\u3002"})}),"\n",(0,t.jsxs)(s.p,{children:["Finally, we modify the ",(0,t.jsx)(s.code,{children:"updateGraph()"})," function to set the playback configuration details from the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," instead of the main ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessor",title:"Base class for audio processing classes or plugins.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5"})," since the latter was replaced by the ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"})," in our standalone app scenario:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"for (auto slot : slots)\n            {\n                if (slot != nullptr)\n                {\n                    activeSlots.add (slot)\uff1b\n \n                    slot->getProcessor()->setPlayConfigDetails (mainProcessor->getMainBusNumInputChannels()\u3001\n                                                                mainProcessor->getMainBusNumOutputChannels()\u3001\n                                                                mainProcessor->getSampleRate()\u3001\n                                                                mainProcessor->getBlockSize())\uff1b\n                }\n            }\n"})}),"\n",(0,t.jsx)(s.p,{children:"\u3053\u308c\u3089\u306e\u5909\u66f4\u5f8c\u3001\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3068\u3057\u3066\u5b9f\u884c\u3055\u308c\u308b\u306f\u305a\u3067\u3059\u3002"}),"\n",(0,t.jsxs)(s.admonition,{type:"warning",children:[(0,t.jsx)(s.p,{children:"\u7e70\u308a\u8fd4\u3057\u306b\u306a\u308b\u304c\u3001\u5185\u8535\u5165\u51fa\u529b\u3067\u30a2\u30d7\u30ea\u3092\u30c6\u30b9\u30c8\u3059\u308b\u5834\u5408\u3001\u60b2\u9cf4\u306e\u3088\u3046\u306a\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u306b\u6ce8\u610f\u3059\u308b\u3053\u3068\u3002\u30d8\u30c3\u30c9\u30d5\u30a9\u30f3\u3092\u4f7f\u3048\u3070\u3053\u306e\u554f\u984c\u3092\u56de\u907f\u3067\u304d\u308b\u3002"}),(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["The source code for this modified version of the plug-in can be found in the ",(0,t.jsx)(s.code,{children:"AudioProcessorGraphTutorial_02.h"})," file of the demo project."]})})]}),"\n",(0,t.jsx)(s.h1,{id:"\u6982\u8981",children:"\u6982\u8981"}),"\n",(0,t.jsxs)(s.p,{children:["In this tutorial, we have learnt how to manipulate an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"})," to cascade the effects of plugins. In particular, we have:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"\u4e00\u9023\u306e\u30aa\u30fc\u30c7\u30a3\u30aa\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u3067\u30c1\u30e3\u30f3\u30cd\u30eb\u30b9\u30c8\u30ea\u30c3\u30d7\u3092\u69cb\u7bc9\u3002"}),"\n",(0,t.jsxs)(s.li,{children:["Learnt how to connect nodes in an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorGraph",title:"A type of AudioProcessor which plays back a graph of other AudioProcessors.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b0\u30e9\u30d5"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Created a standalone app from the graph using an ",(0,t.jsx)(s.a,{href:"https://docs.juce.com/master/classAudioProcessorPlayer",title:"An AudioIODeviceCallback object which streams audio through an AudioProcessor.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30fb\u30d7\u30ed\u30bb\u30c3\u30b5\u30fc\u30fb\u30d7\u30ec\u30fc\u30e4\u30fc"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.h1,{id:"\u95a2\u9023\u9805\u76ee",children:"\u95a2\u9023\u9805\u76ee"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"../tutorial_audio_parameter/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30e9\u30b0\u30a4\u30f3\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u8ffd\u52a0"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"../tutorial_audio_processor_value_tree_state/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30e9\u30b0\u30a4\u30f3\u72b6\u614b\u306e\u4fdd\u5b58\u3068\u8aad\u307f\u8fbc\u307f"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"../tutorial_audio_bus_layouts/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u9069\u5207\u306a\u30d0\u30b9\u30ec\u30a4\u30a2\u30a6\u30c8\u3092\u8a2d\u5b9a\u3059\u308b"})}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function u(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,s,o)=>{o.d(s,{R:()=>a,x:()=>i});var t=o(6540);const n={},r=t.createContext(n);function a(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);