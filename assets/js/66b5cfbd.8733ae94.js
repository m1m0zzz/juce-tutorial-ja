"use strict";(self.webpackChunkjuce_tutorial_ja=self.webpackChunkjuce_tutorial_ja||[]).push([[921],{8946:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var s=a(4848),i=a(8453),n=(a(3449),a(6378));const r={title:"The ValueTree class",sidebar_position:4},o="Tutorial: The ValueTree class",c={id:"utility-classes/tutorial_value_tree",title:"The ValueTree class",description:"Learn how to use the ValueTree class to manage data effectively in your applications.",source:"@site/docs/utility-classes/tutorial_value_tree.mdx",sourceDirName:"utility-classes",slug:"/utility-classes/tutorial_value_tree",permalink:"/juce-tutorial-ja/utility-classes/tutorial_value_tree",draft:!1,unlisted:!1,editUrl:"https://github.com/m1m0zzz/juce-tutorial-ja/tree/main/docs/utility-classes/tutorial_value_tree.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"The ValueTree class",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"File reading",permalink:"/juce-tutorial-ja/utility-classes/tutorial_file_reading"},next:{title:"Using an UndoManager with a ValueTree",permalink:"/juce-tutorial-ja/utility-classes/tutorial_undo_manager_value_tree"}},l={},d=[{value:"ValueTree class overview",id:"valuetree-class-overview",level:2},{value:"Data Storage",id:"data-storage",level:3},{value:"Reference counting",id:"reference-counting",level:3},{value:"Simple interface",id:"simple-interface",level:3},{value:"Undo and redo",id:"undo-and-redo",level:3},{value:"Notifications",id:"notifications",level:3},{value:"\u6982\u8981",id:"\u6982\u8981",level:3},{value:"var class overview",id:"var-class-overview",level:2},{value:"Identifier class overview",id:"identifier-class-overview",level:2},{value:"Why not just use the String class?",id:"why-not-just-use-the-string-class",level:3},{value:"How can they be faster to compare?",id:"how-can-they-be-faster-to-compare",level:3},{value:"A special case in String comparisons",id:"a-special-case-in-string-comparisons",level:3},{value:"Exploiting the special case",id:"exploiting-the-special-case",level:3},{value:"The cost",id:"the-cost",level:3},{value:"How to minimise costs",id:"how-to-minimise-costs",level:3},{value:"Creating a ValueTree object",id:"creating-a-valuetree-object",level:2},{value:"Invalid ValueTree objects",id:"invalid-valuetree-objects",level:2},{value:"How to check if a node is invalid",id:"how-to-check-if-a-node-is-invalid",level:2},{value:"Valid ValueTree objects",id:"valid-valuetree-objects",level:2},{value:"Sharing valid ValueTree objects",id:"sharing-valid-valuetree-objects",level:2},{value:"A note about the UndoManager class",id:"a-note-about-the-undomanager-class",level:2},{value:"Receiving notifications as a Listener",id:"receiving-notifications-as-a-listener",level:2},{value:"Setting a property",id:"setting-a-property",level:2},{value:"Getting a property",id:"getting-a-property",level:2},{value:"Finding out about properties",id:"finding-out-about-properties",level:2},{value:"Adding a child",id:"adding-a-child",level:2},{value:"Getting a child",id:"getting-a-child",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.A,{path:"tutorial_value_tree"}),"\n",(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"tutorial-the-valuetree-class",children:"Tutorial: The ValueTree class"})}),"\n",(0,s.jsxs)(t.p,{children:["Learn how to use the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class to manage data effectively in your applications."]}),"\n",(0,s.jsx)(t.p,{children:"Level: Intermediate"}),"\n",(0,s.jsx)(t.p,{children:"Platforms: Windows, macOS, Linux, iOS, Android"}),"\n",(0,s.jsxs)(t.p,{children:["Classes: ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"}),", ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"}),", ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})]}),"\n",(0,s.jsx)(t.h1,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class is JUCE's secret weapon. It has the power to massively streamline the internal complexity of your applications, turning the traditionally passive data model into an active participant in runtime operation. It takes care of some of the fiddlier aspects of development, such as interfacing data with the GUI, and providing automatic undo and redo of data modifications, as well as providing a universal container for your data. It is also inherently serialisable, making the export and import process very straightforward."]}),"\n",(0,s.jsx)(t.p,{children:"You may not know about them, or perhaps you may have simply not realised their potential. This guide is intended to cover everything you need to know in order to use them."}),"\n",(0,s.jsx)(t.h1,{id:"three-essential-classes",children:"Three essential classes"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class is really an ensemble and, when working with them, you will always be interacting with at least three important classes. These are the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class itself, the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," class, and the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," class. It is impossible to do anything meaningful with ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects without encountering these, so it is useful to appreciate how (and why) you should be using them. Therefore, before we discuss the actual practicalities of manipulating such data, you should familiarise yourself with the following:"]}),"\n",(0,s.jsx)(t.h2,{id:"valuetree-class-overview",children:"ValueTree class overview"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class is the ultimate container class, capable of holding any kind of information. Whilst this may be the obvious role of the type, there are many other facets to it, taking it beyond mere structural duties."]}),"\n",(0,s.jsx)(t.h3,{id:"data-storage",children:"Data Storage"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object is a flexible, multi-purpose data object. It has a basic ",(0,s.jsx)(t.em,{children:"type"})," name, and can hold an arbitrary set of named properties. It is like a kind of ",(0,s.jsx)(t.em,{children:"universal struct"}),"; you don\u2019t need to define what (or how much) data it should hold, you can just use it for whatever you like at runtime."]}),"\n",(0,s.jsxs)(t.p,{children:["For illustrative purposes, one object (shown here as ",(0,s.jsx)(t.em,{children:"pseudo-data"}),") might hold the following information:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'Pet\n    Name = "Fluffmuff"\n    Animal = "Cat"\n    Size = 2.4\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As the name suggests, a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object may also function as a node in a tree structure. Along with its named properties, it can contain any number of child nodes (and can in turn itself be added to a parent node)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'Pet\n    Name = "Fluffmuff"\n    Animal = "Cat"\n    Size = 2.4\n    Accessories\n        Collar\n            Colour = "Pink"\n        Camera\n            HasFlash = false\n            Capacity = 32\nColourRepresents a colour, also including a transparency value.Definition juce_Colour.h:41\n'})}),"\n",(0,s.jsxs)(t.p,{children:["These structures are very similar to those formed in the XML format; an individual ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," node is very much like an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classXmlElement",title:"Used to build a tree of elements representing an XML document.",children:"XmlElement"})," object, having a name, properties, and children. The big difference is that the properties are stored as actual typed data, rather than the text-for-everything representation used by the XML format . This means they can hold more complex types of data, access it more efficiently, and be generally better suited to use in a data model (and not just serialisation). In fact, it is possible to automatically generate XML text (or a special binary format) from any given ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," node, and later restore that structure."]}),"\n",(0,s.jsx)(t.h3,{id:"reference-counting",children:"Reference counting"}),"\n",(0,s.jsxs)(t.p,{children:["Each node is reference counted, so their lifetimes are easily managed. The data itself is actually stored in a hidden shared instance, for which the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class is just a light, reference-keeping wrapper interface."]}),"\n",(0,s.jsxs)(t.p,{children:["You can pass them around quickly by value, and not have to use pointers directly; returning a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object from a function does not copy any data, only a reference, so it makes your interfaces both simple and safe."]}),"\n",(0,s.jsx)(t.p,{children:"You never have to worry about deleting them yourself; as soon as you are no longer using one anywhere, it will be automatically destroyed. This also means that the node data will never be accidentally deleted whilst you might be still using it, which is particularly handy for ensuring an asynchronous UI will never encounter dangling pointers."}),"\n",(0,s.jsx)(t.h3,{id:"simple-interface",children:"Simple interface"}),"\n",(0,s.jsxs)(t.p,{children:["It has a simple, universal interface for manipulating its properties and children. By being generic, it can have a single interface to access the content, regardless of its type or organisation. Using the universal ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," class as the common property type, it can take a variety of inputs. Using the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," class to store and retrieve these properties by name, it presents an intuitive way to organise your data."]}),"\n",(0,s.jsx)(t.h3,{id:"undo-and-redo",children:"Undo and redo"}),"\n",(0,s.jsxs)(t.p,{children:["By having such a concise set of controls, it is able to provide built-in support for undo; all of the functions which modify content incorporate predefined undoable actions, so you need only supply an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classUndoManager",title:"Manages a list of undo/redo commands.",children:"UndoManager"})," object to provide such functionality in your application. In case you weren\u2019t already convinced, this is a very compelling reason to use ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects in a data model."]}),"\n",(0,s.jsx)(t.h3,{id:"notifications",children:"Notifications"}),"\n",(0,s.jsxs)(t.p,{children:["Another very powerful feature is the ability for ValueTrees to send notifications when their contents change; this offers huge practical simplifications, particularly in keeping the UI up to date. For example, a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classComponent",title:"The base class for all JUCE user-interface objects.",children:"Component"})," object being used to display the contents of a node can simply refresh itself whenever it sees that the data has been edited\u2014you need only implement it as a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree_1_1Listener",title:"Listener class for events that happen to a ValueTree.",children:"ValueTree::Listener"})," subclass."]}),"\n",(0,s.jsx)(t.h3,{id:"\u6982\u8981",children:"\u6982\u8981"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class is like some kind of miracle class for the application data model, effortlessly providing a wealth of functionality to simplify the way the insides of your application slot together."]}),"\n",(0,s.jsx)(t.h2,{id:"var-class-overview",children:"var class overview"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," class is a universal ",(0,s.jsx)(t.em,{children:"variant"})," class, for holding data of various types. Its functionality makes it suitable for representing JSON data structures."]}),"\n",(0,s.jsxs)(t.p,{children:["Traditionally, you would have to decide in advance what type of data any given variable in your code may store (for example, if you want to hold a whole number, you would choose an ",(0,s.jsx)(t.code,{children:"int"}),", and that is all that variable is allowed to be used for). However, if you were to use a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"}),", such a decision does not have to be made, as it is compatible with a variety of types."]}),"\n",(0,s.jsxs)(t.p,{children:["It is like a generic chameleon variable, capable of representing basic numeric values (",(0,s.jsx)(t.code,{children:"int"})," or ",(0,s.jsx)(t.code,{children:"double"}),"), text (a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object), and ",(0,s.jsx)(t.code,{children:"bool"})," values, as well as a ",(0,s.jsx)(t.code,{children:"void"})," state (because ",(0,s.jsx)(t.code,{children:"0"})," or ",(0,s.jsx)(t.code,{children:"false"})," can be conceptually different to ",(0,s.jsx)(t.em,{children:"nothing"}),"). They can also hold a pointer to any class derived from the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classReferenceCountedObject",title:"A base class which provides methods for reference-counting.",children:"ReferenceCountedObject"})," class (which could be comprised of any kind of complex data you can imagine). As if that weren\u2019t enough, a single ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," object can also be used as an array of multiple ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," objects!"]}),"\n",(0,s.jsxs)(t.p,{children:["This versatility makes it ideal for use in a generic container (such as the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class), allowing its interface the luxury of not having to care what type you\u2019re giving to it (or expecting from it), as long as it can be held in a var. There is implicit casting (and overloaded assignment operators) for the basic types, making interaction in code simple. You can even automatically return a string representation of its current value (including non-text types). The only place these luxuries don\u2019t all apply is when a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," object holds a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classReferenceCountedObject",title:"A base class which provides methods for reference-counting.",children:"ReferenceCountedObject"})," object. As these are unknown types, you have to cast them yourself (you can do this safely with a ",(0,s.jsx)(t.code,{children:"dynamic_cast"}),", as this returns ",(0,s.jsx)(t.code,{children:"nullptr"})," if it is not of the correct type)."]}),"\n",(0,s.jsxs)(t.p,{children:["In a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object, all properties are held as ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," objects. By choosing this multi-purpose class as a property type, it is possible to have a single set of functions to access them, regardless of what they may be. You don\u2019t need to use one function for ",(0,s.jsx)(t.code,{children:"int"})," values and another for text; all such functions can be unified by dealing with ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," objects."]}),"\n",(0,s.jsx)(t.h2,{id:"identifier-class-overview",children:"Identifier class overview"}),"\n",(0,s.jsxs)(t.p,{children:["This class is intended as a human-readable ",(0,s.jsx)(t.em,{children:"key"}),", used to identify data."]}),"\n",(0,s.jsxs)(t.p,{children:["Essentially, an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object is a string. You can assign one from a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object, and you can also retrieve their contents as a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object. In the context of the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class, it is used both to specify a type name for the node, and also to uniquely label each of its properties."]}),"\n",(0,s.jsx)(t.h3,{id:"why-not-just-use-the-string-class",children:"Why not just use the String class?"}),"\n",(0,s.jsxs)(t.p,{children:["There are two main reasons for using a specialised class instead of the general purpose ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," class."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["It can force a limited character set: Firstly, this class enforces a limitation on the characters which can make up a valid key; it only allows alphanumeric characters and special characters ",(0,s.jsx)(t.code,{children:"_-:#$%"}),". This might sound a bit rubbish, but it makes it possible to ensure compatibility with other systems with the same limitation (for example, the XML format and scripts)."]}),"\n",(0,s.jsxs)(t.li,{children:["It can be optimised for purpose: The second (but most important) reason stems from how we want to use them. They are to act as a key to identify a single item from a list of any size, and so the most common operation to be performed with them is a comparison. However, comparisons of ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," objects can be fairly slow. We actually have to check the text, and only when we find the first different character can we say for sure that two ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," objects are not the same. For strings that are mostly the same, we may end up checking most of the letters (and strings which are a match will have had all of their characters tested). For a single comparison, that might be acceptable, but when you want to compare one string against a list (as we would when using it as a key), the whole business can take a long time."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"By using a special class, we can ensure that it is optimised to allow for quick comparisons. Because of this optimisation (and the limited character set), they are not intended to be used for general text handling, but they are perfectly suited to using string-like data as a key."}),"\n",(0,s.jsx)(t.h3,{id:"how-can-they-be-faster-to-compare",children:"How can they be faster to compare?"}),"\n",(0,s.jsxs)(t.p,{children:["It is useful to know about the optimisation of the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," class. For one thing, it will reassure you that the code is not secretly checking all the characters in each test. More importantly, however, as with many optimisations, there is a cost involved, and it helps to know where that is so you can avoid it being an issue."]}),"\n",(0,s.jsxs)(t.p,{children:["It is perfectly possible to use the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," without knowing this stuff, but you will have a better understanding of where the trade-offs occur if you do."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"The details of this optimisation may well change (this is Secondary Knowledge of a class), but it is unlikely that the implications for your implementation will."})}),"\n",(0,s.jsx)(t.h3,{id:"a-special-case-in-string-comparisons",children:"A special case in String comparisons"}),"\n",(0,s.jsxs)(t.p,{children:["To know that two ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," objects are the same, what you actually have to do is prove that they are not different. As it happens, the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," class holds reference counted text, so there is a chance that two ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," objects actually point to the same data; if that is the case, we can spot it straight away (as they will both hold the same address)."]}),"\n",(0,s.jsxs)(t.p,{children:["These special cases are much quicker, but the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," class can only take advantage of them if they happen. When the addresses are not the same, it does not prove that their content is not equivalent, and so we must still check the characters."]}),"\n",(0,s.jsx)(t.h3,{id:"exploiting-the-special-case",children:"Exploiting the special case"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," class exploits this behaviour, and makes it so that we can actually guarantee that all equivalent ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," objects will always be pointing to the same piece of data. Because of the way they are optimised, a character-for-character match of different ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," objects will never exist for different memory addresses. This means that the ",(0,s.jsx)(t.em,{children:"special case"})," of identical strings is now the only way to be equivalent, and thus proving that they are different is as simple as spotting that they hold different addresses."]}),"\n",(0,s.jsx)(t.p,{children:"This is not magic, however, as the cost is simply moved elsewhere."}),"\n",(0,s.jsxs)(t.p,{children:["In order to enforce this behaviour, all ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," objects share a single, concealed, global pool of unique strings. The strings held by every ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object used at runtime are stored in this pool. When assigning an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object from a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object, the pool is checked to see if it already contains an equivalent copy. If it does, that will be used instead; if not, the new ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object is added, ready to be found by the next ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object to look for it."]}),"\n",(0,s.jsx)(t.h3,{id:"the-cost",children:"The cost"}),"\n",(0,s.jsxs)(t.p,{children:["Thus, instantiating an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object from a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object is the most expensive part of their operation. Once one exists, if you always copy from it, you will never have to pay that price for it again. Sometimes it is unavoidable (specifically if you are acquiring an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object from input, or data held in a normal ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object), but this is far less regular an occurrence than comparing them. Every time you assign one from a bare ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classString",title:"The JUCE String class!",children:"String"})," object (either from data, or as a literal in code), a pool check is required to enforce the optimisation. If you instead assign from another existing ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object, it is guaranteed that such a check has already been done."]}),"\n",(0,s.jsx)(t.h3,{id:"how-to-minimise-costs",children:"How to minimise costs"}),"\n",(0,s.jsxs)(t.p,{children:["A good strategy is to initialise some easily-accessible ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," instances at startup. From your code, you can then use these instead of literal strings, and you will never incur any further lookup penalties from them. You could put them in a globally accessible namespace, use file static instances, or even static class members to help organise them."]}),"\n",(0,s.jsx)(t.h1,{id:"basic-valuetree-class-usage",children:"Basic ValueTree class usage"}),"\n",(0,s.jsxs)(t.p,{children:["In addition to the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," and ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," classes, there are actually many more that you will see used in conjunction with ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects, as we shall see later. These, however, are required for most of the fundamental operations in the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class."]}),"\n",(0,s.jsx)(t.p,{children:"Once you've learned about the three essential classes, you should be in a good position to proceed to pick up the basics."}),"\n",(0,s.jsxs)(t.p,{children:["This is a basic guide introducing all of the essential core functions of the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class. It covers all of the functionality you need to be able to get started using them in your code."]}),"\n",(0,s.jsx)(t.h2,{id:"creating-a-valuetree-object",children:"Creating a ValueTree object"}),"\n",(0,s.jsxs)(t.p,{children:["You can easily use ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects by simply creating an object on the stack (or as a member of a class)."]}),"\n",(0,s.jsx)(t.h2,{id:"invalid-valuetree-objects",children:"Invalid ValueTree objects"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object is, by default, ",(0,s.jsx)(t.strong,{children:"invalid"}),". That is, a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object initialised with the ",(0,s.jsx)(t.em,{children:"default constructor"})," will have no data at all. Unless you explicitly initialise it with an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," (or an existing, valid, ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object), it will hold nothing; it is an empty shell."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"juce::ValueTree myNode; // this object is invalid - it does not hold any node data\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is similar to a null pointer (in fact, internally, that's exactly what it is), but without any of the inherent dangers. Until it is assigned a valid node, it refers to nothing. The main difference here is that the interface functions can still be used, albeit largely without any effect (as there is nothing to be manipulated)."}),"\n",(0,s.jsx)(t.p,{children:"Whilst it is safe to 'accidentally' call the access functions on an invalid node, it doesn't get you very far!"}),"\n",(0,s.jsx)(t.h2,{id:"how-to-check-if-a-node-is-invalid",children:"How to check if a node is invalid"}),"\n",(0,s.jsxs)(t.p,{children:["In your code you can call the member function ",(0,s.jsx)(t.a,{href:"classValueTree.html#a9c1506afbe6b840e4ab43fabf275845a",title:"Returns true if this tree refers to some valid data.",children:"ValueTree::isValid()"})," to find out if the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," is empty:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"if (myNode.isValid())\n{\n    // This will not be reached for an invalid node\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"valid-valuetree-objects",children:"Valid ValueTree objects"}),"\n",(0,s.jsxs)(t.p,{children:["The primary means of creating a valid ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object is by initialising with a valid ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object. This is used to ",(0,s.jsx)(t.em,{children:"name"})," the new node, and represents the node\u2019s ",(0,s.jsx)(t.strong,{children:"type"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'static juce::Identifier myNodeType ("MyNode"); // pre-create an Identifier\njuce::ValueTree myNode (myNodeType);           // This is a valid node, of type "MyNode"\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["You can use a string literal instead of explicitly providing an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object, but it is better practice to use an existing ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," instance where possible. (See ",(0,s.jsx)(t.a,{href:"#tutorial_value_tree_indentifier_overview",children:"Identifier class overview"})," for more information.)"]})}),"\n",(0,s.jsxs)(t.p,{children:["By requiring that a valid node has a type, we have a mechanism of indicating what sort of data it should contain. Conversely, when faced with a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object (for example, as a parameter supplied to a function), you can check its type\u2014using the ",(0,s.jsx)(t.a,{href:"classValueTree.html#aaba6256213ee02c418e9ef3d320f0ff1",title:"Returns the type of this tree.",children:"ValueTree::getType()"})," function\u2014to determine what you might expect to find inside it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"void foo (const juce::ValueTree& someNode)\n{\n    if (someNode.getType() == myNodeType)\n    {\n        // This would be hit for nodes created as \u201cMyNode\u201d\n    }\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Once a node is created, you cannot change its type. This is intentional, as such information is not really a property of the object, it is the fundamental essence of the object."})}),"\n",(0,s.jsx)(t.h2,{id:"sharing-valid-valuetree-objects",children:"Sharing valid ValueTree objects"}),"\n",(0,s.jsxs)(t.p,{children:["The third way in which a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," can be initialised is via the copy constructor, by providing an existing ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'[1]:    juce::ValueTree myNode (myNodeType); // creates a new node of type "MyNode"\n[2]:    juce::ValueTree sameNode (myNode);   // This object points to the same data as myNode\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This results in an object which refers to ",(0,s.jsx)(t.em,{children:"the same node data"})," as the existing object."]}),"\n",(0,s.jsxs)(t.p,{children:["It is important to understand that nothing is copied here except for a reference; both objects are attached to ",(0,s.jsx)(t.strong,{children:"the same underlying instance"})," of the original node data. Changes made to either (if the shared node is valid) will be found upon inspection of the other."]}),"\n",(0,s.jsx)(t.p,{children:"You can achieve the same result (a sharing of node data) by using the assignment operator."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'[3]:    juce::ValueTree otherNode (myNodeType); // This creates a second (new) "MyNode" node...\n[4]:    otherNode = sameNode;                   // ...but the object now points to the first instance\n'})}),"\n",(0,s.jsx)(t.p,{children:"Here is a question:"}),"\n",(0,s.jsx)(t.p,{children:"What happens to the node instance created in line [3] when we replace it in line [4]?"}),"\n",(0,s.jsxs)(t.p,{children:["By the end, all three variables point to the same initial instance. There are no longer any ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects referring to the second instance, so ",(0,s.jsx)(t.strong,{children:"it is destroyed"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Whenever a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object is reassigned (or goes out of scope), the underlying data it was pointing to loses a reference. If that data is not held elsewhere, it is automatically destroyed. This may sound scary, as if you might be operating in a world where your data could self-destruct at any moment; in reality, it is very unlikely that you will inadvertently lose your nodes! It is a very robust system. Besides, if the data is important, you\u2019ll probably find that you have in fact already stored it somewhere; it is as intuitive as you could wish for."]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["This also means that you need to be careful in real-time code such as an audio callback. Reassigning a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object in an audio callback could inadvertently cause the ",(0,s.jsx)(t.code,{children:"delete"})," operator if there are no longer references to the previously assigned data."]})}),"\n",(0,s.jsx)(t.h2,{id:"a-note-about-the-undomanager-class",children:"A note about the UndoManager class"}),"\n",(0,s.jsxs)(t.p,{children:["All of the access functions in the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class understand how to use ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classUndoManager",title:"Manages a list of undo/redo commands.",children:"UndoManager"})," objects. They come ready-prepared with suitable ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classUndoableAction",title:"Used by the UndoManager class to store an action which can be done and undone.",children:"UndoableAction"})," objects; all you have to do is provide a pointer to an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classUndoManager",title:"Manages a list of undo/redo commands.",children:"UndoManager"})," object with your call, and an operational, undoable record of the modification will be added to it automatically."]}),"\n",(0,s.jsxs)(t.p,{children:["There's not a lot you need to know to manage this, but we cover it in more detail in ",(0,s.jsx)(t.a,{href:"../tutorial_undo_manager_value_tree/",children:"Tutorial: Using an UndoManager with a ValueTree"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For now, we will make use of the functions without bothering to store a history, by providing a ",(0,s.jsx)(t.code,{children:"nullptr"})," value. We will take it as read that any such modification functions must be given at least a null pointer to an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classUndoManager",title:"Manages a list of undo/redo commands.",children:"UndoManager"})," object when describing them; there will of course be ",(0,s.jsx)(t.code,{children:"nullptr"})," values visible in the examples."]}),"\n",(0,s.jsx)(t.h2,{id:"receiving-notifications-as-a-listener",children:"Receiving notifications as a Listener"}),"\n",(0,s.jsxs)(t.p,{children:["Registering as a listener to the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," allows us to be notified synchronously when the data has changed. The pointer to the listener is held in the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," instance and therefore it is usually best to take a copy of the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," before registering like so:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"struct ExampleListener  : public juce::ValueTree::Listener\n{\n    ExampleListener (juce::ValueTree v)\n        : tree (v)\n    {\n        tree.addListener (this);\n    }\n \n    juce::ValueTree tree;\n};\nAccessibilityRole::tree@ tree\n"})}),"\n",(0,s.jsx)(t.p,{children:"We can then implement the following callback functions depending on the behaviour we wish to be notified for:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["valueTreePropertyChanged(): Called when a property change occurs in the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," or any of its children."]}),"\n",(0,s.jsxs)(t.li,{children:["valueTreeChildAdded(): Called when a child node is added to the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," or any of its children."]}),"\n",(0,s.jsxs)(t.li,{children:["valueTreeChildRemoved(): Called when a child node is removed from the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," or any of its children."]}),"\n",(0,s.jsxs)(t.li,{children:["valueTreeChildOrderChanged(): Called when a child node is reordered in the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," or any of its children."]}),"\n",(0,s.jsxs)(t.li,{children:["valueTreeParentChanged(): Called when the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," is added or removed from a parent node."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Callbacks are propagated upwards in the tree hierarchy so listeners to parent nodes will also receive property change callbacks from children and therefore types and property names should be checked."}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["Since callbacks are synchronous, for any time-critical applications you should use an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classAsyncUpdater",title:"Has a callback method that is triggered asynchronously.",children:"AsyncUpdater"})," to handle property changes."]})}),"\n",(0,s.jsx)(t.h1,{id:"basic-property-access",children:"Basic property access"}),"\n",(0,s.jsx)(t.h2,{id:"setting-a-property",children:"Setting a property"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#a550e9c8780d4ee56d14d67de17f200e2",title:"Changes a named property of the tree.",children:"ValueTree::setProperty()"})," function is one direct way to set a property on a valid node. You must provide an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object to specify the name of the property you wish to set, and a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," value for it to take:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'static juce::Identifier propertyName ("name");\nmyNode.setProperty (propertyName, "Fluffmuff", nullptr);\n'})}),"\n",(0,s.jsx)(t.h2,{id:"getting-a-property",children:"Getting a property"}),"\n",(0,s.jsxs)(t.p,{children:["There are two basic ways to retrieve a property. For each approach, you must provide an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," to specify which named property you are requesting."]}),"\n",(0,s.jsxs)(t.p,{children:["Using the ",(0,s.jsx)(t.a,{href:"classValueTree.html#a97f6d4b2a0e28be73d349cba363ab7e2",title:"Returns the value of a named property.",children:"ValueTree::getProperty()"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"juce::String name (myNode.getProperty (propertyName));\nnameint UnityEventModifiers const char * nameDefinition juce_UnityPluginInterface.h:195\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Or using the subscript operator (that is, the ",(0,s.jsx)(t.a,{href:"classValueTree.html#a6cf8b3f5eac2d14f1323f5fe0f228a71",title:"Returns the value of a named property.",children:"ValueTree::operator[]"})," function):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"name = myNode[propertyName];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Both of the above lines store the same result into the ",(0,s.jsx)(t.code,{children:"name"})," variable. Remember that these properties can hold any supported ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," type. Thus, the following code is also valid:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'static juce::Identifier propertySize ("size");\nmyNode.setProperty (propertySize, 2.4, nullptr);\ndouble size = myNode[propertySize];\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Here, a property is set in the same way using a ",(0,s.jsx)(t.code,{children:"double"})," value, and is easily read back in as such. It is also possible to replace an existing property with a different type of value."]}),"\n",(0,s.jsxs)(t.p,{children:["If all you want to do is store individual values in a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," node (and nothing more complex), then you already know enough to get started!"]}),"\n",(0,s.jsx)(t.h2,{id:"finding-out-about-properties",children:"Finding out about properties"}),"\n",(0,s.jsxs)(t.p,{children:["If you were using structs, you would only have the ability to set or get these member variables directly. With a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," node, you can also (at runtime) find out what ",(0,s.jsx)(t.em,{children:"variables"})," there are."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#a018730ee95c743705aa9132a37829b32",title:"Returns the total number of properties that the tree contains.",children:"ValueTree::getNumProperties()"})," function tells you how many properties a node has:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"int numProperties = myNode.getNumProperties();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#a6ea2ce53b4759a37d58e3f99d9702e36",title:"Returns the identifier of the property with a given index.",children:"ValueTree::getPropertyName()"})," function returns an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," object giving the name of the property at the specified position. By using this in combination with the ",(0,s.jsx)(t.a,{href:"classValueTree.html#a018730ee95c743705aa9132a37829b32",title:"Returns the total number of properties that the tree contains.",children:"ValueTree::getNumProperties()"})," function, it is possible to iterate over the properties without previously knowing what they are."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"for (int i = 0; i < numProperties; ++i)\n{\n    juce::Identifier name (myNode.getPropertyName (i));\n    // \u2026\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#a0dbec0d665fb9d57b9fd7b3189ec0ee0",title:"Returns true if the tree contains a named property.",children:"ValueTree::hasProperty()"})," function simply tells you whether or not a particular named property has been set for a node:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"if (myNode.hasProperty (nameProperty))\n{\n   // property was found\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"These functions allow for what is called reflection, whereby your program is able to inspect the nature of your objects. When faced with an object to work with, your code doesn't necessarily need a definition (for example, class header) to be able to make use of it; you can check to see what members it has, and use them if they are appropriate."}),"\n",(0,s.jsx)(t.h1,{id:"basic-child-access",children:"Basic child access"}),"\n",(0,s.jsx)(t.p,{children:"If you want to create more complex structures, you will want to start using these objects as nodes in a hierarchy."}),"\n",(0,s.jsx)(t.h2,{id:"adding-a-child",children:"Adding a child"}),"\n",(0,s.jsx)(t.p,{children:"Whilst a node can have a bunch of properties attached to it, it can also contain a number of child nodes, much like an array."}),"\n",(0,s.jsxs)(t.p,{children:["If we have a node we wish to add as a child, we simply call the ",(0,s.jsx)(t.a,{href:"classValueTree.html#a93d639299ef9dfedc651544e05f06693",title:"Adds a child to this tree.",children:"ValueTree::addChild"})," () function on the node we wish to add it to. We naturally pass in the new child node, but we must also specify where it should go. If you don't need it to be inserted at any particular position, you can specify ",(0,s.jsx)(t.code,{children:"-1"})," to simply place it on the end."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"juce::ValueTree childNode (myNodeType);\nmyNode.addChild (childNode, -1, nullptr);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Here, the data held in ",(0,s.jsx)(t.code,{children:"childNode"})," node belongs to the data held in ",(0,s.jsx)(t.code,{children:"myNode"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Note that this ",(0,s.jsx)(t.em,{children:"belonging"})," is also an additional reference. If we reassign the ",(0,s.jsx)(t.code,{children:"childNode"})," variable, the existing data will not be lost."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"childNode = juce::ValueTree (myNodeType);\nmyNode.addChild (childNode, -1, nullptr);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Whilst we may no longer have any ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects in our immediate scope pointing directly to that instance, it is kept alive within the original node."]}),"\n",(0,s.jsx)(t.h2,{id:"getting-a-child",children:"Getting a child"}),"\n",(0,s.jsx)(t.p,{children:"There are a number of ways in which you can retrieve a child node. Which you should choose for any given task depends upon how your chosen structures are organised."}),"\n",(0,s.jsx)(t.p,{children:"With all of them, any requests which don't correspond to a child will return an invalid object."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#a3f89053219ec515f24997a115cfd74e5",title:"Returns one of this tree's sub-trees.",children:"ValueTree::getChild()"})," function returns the child currently sitting in the specified position within the node's internal list. If you're always adding them to the end, ",(0,s.jsx)(t.code,{children:"0"})," would correspond to the first one you put in:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"childNode = myNode.getChild (0);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#a4047208c32c4e024a1f2809d1c35be48",title:"Returns the first sub-tree with the specified type name.",children:"ValueTree::getChildWithName()"})," function returns the first child with the specified name identifier as its node type:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"childNode = myNode.getChildWithName (myNodeType);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"classValueTree.html#aa17ae8b3ef8149fe5b9cc8b37d4ebd7d",title:"Looks for the first sub-tree that has the specified property value.",children:"ValueTree::getChildWithProperty()"})," function returns the first child which has the named property set to the specified value:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'childNode = myNode.getChildWithProperty (nameProperty, "Fluffmuff");\n'})}),"\n",(0,s.jsx)(t.p,{children:"The last two, along with any other such methods you require, can of course be written using the first one; it's easy to write your own functions to retrieve a child by some other criteria (for example, a combination of matching node type and a property value)."}),"\n",(0,s.jsxs)(t.p,{children:["You can also retrieve the current owner of any given node using the ",(0,s.jsx)(t.a,{href:"classValueTree.html#ad22561c896d9bcdb763d27aacbb5815c",title:"Returns the parent tree that contains this one.",children:"ValueTree::getParent()"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"ValueTree parent (childNode.getParent());\nValueTreeA powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...Definition juce_ValueTree.h:75\n"})}),"\n",(0,s.jsx)(t.h1,{id:"\u6982\u8981-1",children:"\u6982\u8981"}),"\n",(0,s.jsxs)(t.p,{children:["This tutorial has given a detailed overview of the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," class and related classes. In particular, you should:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Know the importance of the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classvar",title:"A variant class, that can be used to hold a range of primitive values.",children:"var"})," and ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classIdentifier",title:"Represents a string identifier, designed for accessing properties by name.",children:"Identifier"})," classes."]}),"\n",(0,s.jsxs)(t.li,{children:["How to create ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects and pass them around."]}),"\n",(0,s.jsxs)(t.li,{children:["How to add and access properties of ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," objects."]}),"\n",(0,s.jsxs)(t.li,{children:["How to add and access child nodes to a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classValueTree",title:"A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...",children:"ValueTree"})," object."]}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"\u95a2\u9023\u9805\u76ee",children:"\u95a2\u9023\u9805\u76ee"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_undo_manager_value_tree/",children:"Tutorial: Using an UndoManager with a ValueTree"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_audio_processor_value_tree_state/",children:"Tutorial: Saving and loading your plug-in state"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3449:(e,t,a)=>{a.d(t,{A:()=>i});var s=a(4848);function i(e){let{src:t,caption:a,alt:i,width:n,height:r}=e;return(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:t,alt:i||a,width:n,height:r}),(0,s.jsx)("figcaption",{children:(0,s.jsx)("b",{children:a})})]})}},6378:(e,t,a)=>{a.d(t,{A:()=>i});var s=a(4848);function i(e){let{path:t}=e;return(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:`https://docs.juce.com/master/${t}.html`,children:"\ud83d\udcda Source Page"})})}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var s=a(6540);const i={},n=s.createContext(i);function r(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);