"use strict";(self.webpackChunkjuce_tutorial_ja=self.webpackChunkjuce_tutorial_ja||[]).push([[946],{3618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var r=t(4848),i=t(8453),s=t(3449);t(6378),t(5706);const a={title:"OpenGL\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d3\u30eb\u30c9",sidebar_position:5,tags:["\u4e0a\u7d1a"]},o="\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebOpenGL\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d3\u30eb\u30c9",l={id:"graphics/tutorial_open_gl_application",title:"OpenGL\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d3\u30eb\u30c9",description:"JUCE\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u9ad8\u6027\u80fd\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u3057\u3066OpenGL\u3092\u4f7f\u3044\u59cb\u3081\u308b\u65b9\u6cd5\u3092\u3054\u7d39\u4ecb\u3057\u307e\u3059\u3002\u30aa\u30fc\u30c7\u30a3\u30aa\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3084\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u3001\u7f8e\u3057\u30442D\u30843D\u306e\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3092\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3057\u307e\u3059\u3002",source:"@site/docs/graphics/tutorial_open_gl_application.mdx",sourceDirName:"graphics",slug:"/graphics/tutorial_open_gl_application",permalink:"/juce-tutorial-ja/graphics/tutorial_open_gl_application",draft:!1,unlisted:!1,editUrl:"https://github.com/m1m0zzz/juce-tutorial-ja/tree/main/docs/graphics/tutorial_open_gl_application.mdx",tags:[{label:"\u4e0a\u7d1a",permalink:"/juce-tutorial-ja/tags/\u4e0a\u7d1a"}],version:"current",sidebarPosition:5,frontMatter:{title:"OpenGL\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d3\u30eb\u30c9",sidebar_position:5,tags:["\u4e0a\u7d1a"]},sidebar:"tutorialSidebar",previous:{title:"\u30b8\u30aa\u30e1\u30c8\u30ea\u306e\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3",permalink:"/juce-tutorial-ja/graphics/tutorial_animation"},next:{title:"Interface Design",permalink:"/juce-tutorial-ja/category/interface-design"}},c={},h=[{value:"\u306f\u3058\u3081\u308b",id:"\u306f\u3058\u3081\u308b",level:2},{value:"The Vertex struct",id:"the-vertex-struct",level:2},{value:"The Attributes struct",id:"the-attributes-struct",level:2},{value:"The Uniforms struct",id:"the-uniforms-struct",level:2},{value:"The Shape struct",id:"the-shape-struct",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebopengl\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d3\u30eb\u30c9",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebOpenGL\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30d3\u30eb\u30c9"}),"\n",(0,r.jsx)(n.p,{children:"JUCE\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u9ad8\u6027\u80fd\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u3057\u3066OpenGL\u3092\u4f7f\u3044\u59cb\u3081\u308b\u65b9\u6cd5\u3092\u3054\u7d39\u4ecb\u3057\u307e\u3059\u3002\u30aa\u30fc\u30c7\u30a3\u30aa\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3084\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u3001\u7f8e\u3057\u30442D\u30843D\u306e\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3092\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u30ec\u30d9\u30eb\uff1a\u4e0a\u7d1a"}),"\n",(0,r.jsx)(n.p,{children:"\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\uff1aWindows, macOS, Linux, iOS, Android"}),"\n",(0,r.jsxs)(n.p,{children:["\u30af\u30e9\u30b9\uff1a ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"}),", ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLContext",title:"Creates an OpenGL context, which can be attached to a component.",children:"OpenGLContext"}),", ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLShaderProgram",title:"Manages an OpenGL shader program.",children:"OpenGLShaderProgramme"}),", ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLHelpers",title:"A set of miscellaneous openGL helper functions.",children:"OpenGLHelpers"}),", ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classMatrix3D",title:"A 4x4 3D transformation matrix.",children:"\u30de\u30c8\u30ea\u30c3\u30af\u30b93D"}),", ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classVector3D",title:"A three-coordinate vector.",children:"\u30d9\u30af\u30bf\u30fc3D"})]}),"\n",(0,r.jsx)(n.h2,{id:"\u306f\u3058\u3081\u308b",children:"\u306f\u3058\u3081\u308b"}),"\n",(0,r.jsxs)(n.p,{children:["This tutorial assumes basic understanding of the OpenGL graphics library. If you are not familiar with ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/OpenGL",children:"\u30aa\u30fc\u30d7\u30f3GL"}),", you should read about it first ",(0,r.jsx)(n.a,{href:"https://www.opengl.org",children:"\u3053\u308c"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Download the demo project for this tutorial here: ",(0,r.jsx)(n.a,{href:"/tutorials/PIPs/OpenGLAppTutorial.zip",children:"\u30d4\u30c3\u30d7"})," | ",(0,r.jsx)(n.a,{href:"/tutorials/ZIPs/OpenGLAppTutorial.zip",children:"\u30b8\u30c3\u30d7"}),". Unzip the project and open the first header file in the Projucer."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["If using the PIP version of this project, please make sure to copy the ",(0,r.jsx)(n.code,{children:"\u30ea\u30bd\u30fc\u30b9"})," folder into the generated Projucer project."]})}),"\n",(0,r.jsxs)(n.p,{children:["If you need help with this step, see ",(0,r.jsx)(n.a,{href:"../tutorial_new_projucer_project/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebProjucer\u30d1\u30fc\u30c81\uff1aProjucer\u3092\u59cb\u3081\u308b"}),"."]}),"\n",(0,r.jsx)(n.h1,{id:"the-demo-project",children:"The demo project"}),"\n",(0,r.jsx)(n.p,{children:'\u30c7\u30e2\u30fb\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f\u3001\u4ee5\u4e0b\u306e\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8\u306e\u3088\u3046\u306b\u3001Wavefront\u306e".obj "\u30d5\u30a1\u30a4\u30eb\u3092\u89e3\u6790\u3057\u3066\u3001\u6a19\u6e96\u7684\u306aOpenGL\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u30fb\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30923D\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3067\u8868\u793a\u3057\u307e\u3059\uff1a'}),"\n",(0,r.jsx)(s.A,{src:"https://docs.juce.com/master/tutorial_open_gl_application_screenshot1.png",caption:"The demo project app window"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The code presented here is broadly similar to the ",(0,r.jsx)(n.strong,{children:"OpenGLAppExample"})," from the JUCE Examples."]})}),"\n",(0,r.jsx)(n.h1,{id:"anatomy-of-an-opengl-app",children:"Anatomy of an OpenGL app"}),"\n",(0,r.jsx)(n.p,{children:"OpenGL API\u306f\u3001\u591a\u304f\u306e\u7570\u306a\u308b\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u3084\u30d3\u30eb\u30c9\u74b0\u5883\u3067\u52d5\u4f5c\u3059\u308b\u5f37\u529b\u3067\u6c4e\u7528\u6027\u306e\u9ad8\u3044\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u304c\u30013D\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u306b\u95a2\u3059\u308b\u539f\u5247\u306f\u3001\u3059\u3079\u3066\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u985e\u4f3c\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u3053\u3067\u8aac\u660e\u3059\u308b\u7528\u8a9e\u306e\u3044\u304f\u3064\u304b\u306f\u3001OpenGL\u304c\u3069\u306e\u3088\u3046\u306b\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u30eb\u30fc\u30c1\u30f3\u3092\u5b9f\u884c\u3059\u308b\u304b\u3092\u7406\u89e3\u3059\u308b\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u3082\u306e\u3067\u3059\uff1a"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"GL\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\uff1a\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\u306f\u521d\u671f\u5316\u6bb5\u968e\u3067\u4e00\u5ea6\u8a2d\u5b9a\u3055\u308c\u3001\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u56fa\u6709\u306e\u65b9\u6cd5\u3067\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u30ec\u30f3\u30c0\u30e9\u30fc\u306eGL\u8a2d\u5b9a\u3092\u8a18\u8ff0\u3057\u3001\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u5185\u3067\u4f7f\u7528\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306aOpenGL\u95a2\u6570\u304c\u30ed\u30fc\u30c9\u3055\u308c\u308b\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u6295\u5f71\u30de\u30c8\u30ea\u30c3\u30af\u30b9\uff1a\u6295\u5f71\u884c\u5217\u306b\u3088\u3063\u3066\u30013D\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30922D\u5e73\u9762\u306b\u5909\u63db\u3057\u3001\u30b7\u30fc\u30f3\u3092\u30b9\u30af\u30ea\u30fc\u30f3\u306b\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u30d3\u30e5\u30fc\u884c\u5217\uff1a\u30d3\u30e5\u30fc\u30de\u30c8\u30ea\u30c3\u30af\u30b9\u306b\u3088\u3063\u3066\u30013D\u74b0\u5883\u3067\u5e7e\u4f55\u5b66\u7684\u306a\u5909\u63db\u3092\u884c\u3044\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u30b7\u30fc\u30f3\u5185\u306b\u914d\u7f6e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u30b7\u30a7\u30fc\u30c0\u30fc\uff1a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5916\u89b3\u3092\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3059\u308b\u305f\u3081\u306b\u3001\u30b7\u30a7\u30fc\u30c0\u30fc\u3092\u4f7f\u7528\u3057\u3066\u3001\u8868\u9762\u306e\u5149\u6ca2\u3084\u53cd\u5c04\u30013D\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u4e0a\u306e\u5149\u3084\u5f71\u306e\u898b\u3048\u65b9\u306a\u3069\u3001\u30de\u30c6\u30ea\u30a2\u30eb\u306e\u7279\u6027\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u9802\u70b9\uff1a\u30b7\u30fc\u30f3\u5185\u3067\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b3D\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u5b9a\u7fa9\u3059\u308b3D\u30dd\u30a4\u30f3\u30c8\u3092\u8868\u3057\u307e\u3059\u3002\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\u30fc\u3067\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\uff1a\u88dc\u9593\u306b\u3088\u3063\u3066\u9802\u70b9\u3068\u9802\u70b9\u306e\u9593\u306b\u5b58\u5728\u3059\u308b\u30d4\u30af\u30bb\u30eb\u3092\u8868\u3059\u3002\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\u3084\u30d4\u30af\u30bb\u30eb\u30b7\u30a7\u30fc\u30c0\u3067\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u5c5e\u6027\uff1a\u30b7\u30a7\u30fc\u30c0\u8a00\u8a9e\u3067\u4f7f\u7528\u3055\u308c\u308b\u8272\u3084\u30c6\u30af\u30b9\u30c1\u30e3\u5ea7\u6a19\u306a\u3069\u306e\u9802\u70b9\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a18\u8ff0\u3059\u308b\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0\uff1a\u30b7\u30a7\u30fc\u30c0\u8a00\u8a9e\u3067\u4f7f\u7528\u3055\u308c\u308b\u304c\u3001\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0\u9593\u3067\u4e0d\u5909\u3067\u3042\u308b\u30b0\u30ed\u30fc\u30d0\u30eb\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a18\u8ff0\u3059\u308b\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u5909\u6570\uff1a\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0\u3068\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u9593\u3067\u5171\u6709\u3055\u308c\u308b\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u30b7\u30a7\u30a4\u30d7\uff1a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u6700\u7d42\u7684\u306b\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3057\u305f\u3044\u30dd\u30ea\u30b4\u30f3\u3092\u30ab\u30d7\u30bb\u30eb\u5316\u3057\u307e\u3059\u3002\u3053\u306e\u5834\u5408\u306f\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u3067\u3059\u3002"}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"the-opengl-shading-language",children:"The OpenGL Shading Language"}),"\n",(0,r.jsx)(n.p,{children:"OpenGL\u30b7\u30a7\u30fc\u30c7\u30a3\u30f3\u30b0\u8a00\u8a9e\u307e\u305f\u306fGLSL\u306f\u3001\u8907\u6570\u306e\u30aa\u30da\u30ec\u30fc\u30c6\u30a3\u30f3\u30b0\u30fb\u30b7\u30b9\u30c6\u30e0\u3084\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30fb\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u30fb\u30ab\u30fc\u30c9\u4e0a\u306e\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u30fb\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u30fb\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u76f4\u63a5\u5236\u5fa1\u3067\u304d\u308bC\u30bf\u30a4\u30d7\u306e\u8a00\u8a9e\u3067\u3059\u3002GLSL\u3092\u4f7f\u7528\u3059\u308b\u3068\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5916\u89b3\u3092\u8a18\u8ff0\u3059\u308b\u30b7\u30a7\u30fc\u30c0\u30fc\u3068\u547c\u3070\u308c\u308b\u5c0f\u3055\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002OpenGL\u3092\u4f7f\u3046\u304b\u3001\u30b9\u30de\u30fc\u30c8\u30d5\u30a9\u30f3\u3084\u30bf\u30d6\u30ec\u30c3\u30c8\u306e\u3088\u3046\u306a\u7d44\u307f\u8fbc\u307f\u30b7\u30b9\u30c6\u30e0\u5c02\u7528\u306b\u8a2d\u8a08\u3055\u308c\u305f\u30b5\u30d6\u30bb\u30c3\u30c8\u30fb\u30e9\u30a4\u30d6\u30e9\u30eaOpenGL ES\u3092\u4f7f\u3046\u304b\u306b\u3088\u3063\u3066\u3001\u8a00\u8a9e\u69cb\u6587\u306f\u5909\u308f\u308a\u307e\u305b\u3093\u304c\u3001\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u8003\u616e\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u4f8b\u3068\u3057\u3066\u3001\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u4f7f\u7528\u3059\u308b\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\u30fc\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// OpenGL\u304a\u3088\u3073OpenGL ES\n\u5c5e\u6027 vec4 position\uff1b\n\u5c5e\u6027 vec4 sourceColour\uff1b\n\u5c5e\u6027 vec2 textureCoordIn\uff1b\n \n\u4e00\u69d8\u306a mat4 projectionMatrix\uff1b\n\u4e00\u69d8\u306a mat4 viewMatrix\uff1b\n \n\u5909\u5316\u3059\u308b vec4 destinationColour\uff1b\n\u5909\u5316\u3059\u308b vec2 textureCoordOut\uff1b\n \nvoid main()\n{\n    destinationColour = sourceColour\uff1b\n    textureCoordOut = textureCoordIn\uff1b\n    gl_Position = projectionMatrix * viewMatrix * position\uff1b\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u305d\u3057\u3066\u3001\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u4f7f\u7528\u3059\u308b\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30fb\u30b7\u30a7\u30fc\u30c0\u30fc\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// OpenGL\n\u5909\u5316\u3059\u308b vec4 destinationColour\uff1b\n\u5909\u5316\u3059\u308bvec2 textureCoordOut\uff1b\n \nvoid main()\n{\n    vec4 color = vec4(0.95, 0.57, 0.03, 0.7)\uff1b\n    gl_FragColor = color\uff1b\n}\n \n// OpenGL ES\n\u5909\u5316\u3059\u308blowp vec4 destinationColour\uff1b\n\u53ef\u5909lowp vec2 textureCoordOut\uff1b\n \nvoid main()\n{\n    lowp vec4 color = vec4(0.95, 0.57, 0.03, 0.7)\uff1b\n    gl_FragColor = color\uff1b\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u3054\u89a7\u306e\u901a\u308a\u3001\u30b7\u30a7\u30fc\u30c0\u30fc\u306f\u975e\u5e38\u306b\u4e9b\u7d30\u306a\u3082\u306e\u3067\u3001OpenGL\u30b7\u30a7\u30fc\u30c0\u30fc\u3068OpenGL ES\u30b7\u30a7\u30fc\u30c0\u30fc\u306e\u9055\u3044\u306f\u3054\u304f\u308f\u305a\u304b\u3067\u3059\u3002\u3053\u3053\u3067\u4f7f\u308f\u308c\u3066\u3044\u308bGLSL\u306e\u578b\u3001\u5909\u6570\u3001\u95a2\u6570\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\uff1a"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VEC2/VEC4"}),": Represents a floating point vector with 2 or 4 components."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u30de\u30c3\u30c84"}),": Represents a 4-by-4 floating point matrix."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u30ed\u30fc\u30d7"}),": Specifies a lower precision data type for OpenGL ES."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u5c5e\u6027"}),": Represents a vertex-specific parameter."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0"}),": Represents a global parameter describing the GL environment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u307e\u3061\u307e\u3061"}),": Represents a shared parameter between the vertex and fragment shaders."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"gl_\u30dd\u30b8\u30b7\u30e7\u30f3"}),": The transformed vertex position for the vertex shader to execute vertex manipulations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"gl_\u30d5\u30e9\u30b0\u30ab\u30e9\u30fc"}),": The colour for the fragment shader to execute fragment manipulations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u30e1\u30a4\u30f3()"}),": The main function is where the vertex or fragment shader computation is performed."]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"the-openglappcomponent-class",children:"The OpenGLAppComponent class"}),"\n",(0,r.jsxs)(n.p,{children:["In JUCE, the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"})," class is very similar to the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classAudioAppComponent",title:"A base class for writing audio apps that stream from the audio i/o devices.",children:"\u30aa\u30fc\u30c7\u30a3\u30aa\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})," class but instead it is used for graphical apps. When inheriting from the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"})," class, there are several functions that we have to override namely:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"initialise()\u3092\u4f7f\u7528\u3057\u307e\u3059\uff1a\u3053\u306e\u95a2\u6570\u306f\u3001\u30b7\u30a7\u30fc\u30c0\u30fc\u306a\u3069\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u306b\u5fc5\u8981\u306aGL\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u6e96\u5099\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"render()\u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff1arender\u95a2\u6570\u306fOpenGL\u30ec\u30f3\u30c0\u30e9\u30fc\u306b\u3088\u3063\u3066\u547c\u3073\u51fa\u3055\u308c\u3001\u3053\u3053\u3067OpenGL\u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\u3092\u63cf\u753b\u3059\u308b\u305f\u3081\u306e\u6295\u5f71\u884c\u5217\u3068\u30d3\u30e5\u30fc\u884c\u5217\u304c\u8a08\u7b97\u3055\u308c\u308b\u3002"}),"\n",(0,r.jsx)(n.li,{children:"shutdown()\uff1a\u3053\u306e\u95a2\u6570\u306f\u3001\u30b7\u30a7\u30fc\u30c0\u30fc\u306a\u3069\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u306b\u4f7f\u7528\u3055\u308c\u305fGL\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u30af\u30ea\u30a2\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"shutdownOpenGL()\uff1a\u30b5\u30d6\u30af\u30e9\u30b9\u306e\u30c7\u30b9\u30c8\u30e9\u30af\u30bf\u3067\u3001\u30af\u30e9\u30b9\u304c\u7834\u58ca\u3055\u308c\u308b\u524d\u306bGL\u30b7\u30b9\u30c6\u30e0\u3092\u30b7\u30e3\u30c3\u30c8\u30c0\u30a6\u30f3\u3059\u308b\u305f\u3081\u306b\u3001\u3053\u306e\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"OpenGL\u306e\u57fa\u672c\u3092\u5b66\u3093\u3060\u3068\u3053\u308d\u3067\u3001\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3092\u5b9f\u88c5\u3057\u3066\u307f\u3088\u3046\uff01"}),"\n",(0,r.jsx)(n.h1,{id:"calculating-the-projection-and-view-matrices",children:"Calculating the Projection and View matrices"}),"\n",(0,r.jsx)(n.p,{children:"\u6295\u5f71\u884c\u5217\u3068\u30d3\u30e5\u30fc\u884c\u5217\u306e\u8a08\u7b97\u3092\u5207\u308a\u96e2\u3059\u305f\u3081\u306b\u3001\u3053\u308c\u3089\u306e\u884c\u5217\u3092\u5f8c\u3067\u4f7f\u3048\u308b\u3088\u3046\u306b\u8fd4\u30592\u3064\u306e\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\u3092\u4f5c\u6210\u3059\u308b\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u307e\u305a\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30d5\u30e9\u30b9\u30c8\u30e9\u30e0\u3068\u30b9\u30af\u30ea\u30fc\u30f3\u5883\u754c\u3092\u4f7f\u3063\u3066\u6295\u5f71\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    juce::Matrix3D getProjectionMatrix() const\n    {\n        auto w = 1.0f / (0.5f + 0.1f);                                          // [1]\n        auto h = w * getLocalBounds().toFloat().getAspectRatio (false);         // [2]\n \n        return juce::Matrix3D::fromFrustum (-w, w, -h, h, 4.0f, 30.0f); // [3].\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A frustum is a shape cutout from a polygon by slicing it with two parallel planes and the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classMatrix3D",title:"A 4x4 3D transformation matrix.",children:"\u30de\u30c8\u30ea\u30c3\u30af\u30b93D"})," class provides a handy function called ",(0,r.jsx)(n.code,{children:"fromFrustum()"})," that returns a matrix from one. In the function above:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"[1]: We first declare a width variable to define half the width of the frustum on the near plane with an arbitrary number that works well for our scenario."}),"\n",(0,r.jsx)(n.li,{children:"[2]: Then we declare a height variable to define half the height of the frustum on the near plane based on the screen ratio and the width variable."}),"\n",(0,r.jsxs)(n.li,{children:["[3]: We finally use the ",(0,r.jsx)(n.code,{children:"fromFrustum()"})," function with width, height, near plane and far plane distances as arguments to retrieve the projection matrix. This gives us a perspective projection as opposed to an orthographic projection."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"\u6b21\u306b\u3001\u56de\u8ee2\u884c\u5217\u3092\u4f7f\u3063\u3066\u30d3\u30e5\u30fc\u884c\u5217\u3092\u8a08\u7b97\u3057\u3001\u4e0b\u56f3\u306e\u3088\u3046\u306b\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u3092\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u5316\u3057\u307e\u3059\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    juce::Matrix3D getViewMatrix() const\n    {\n        auto viewMatrix = juce::Matrix3D::fromTranslation ({ 0.0f, 0.0f, -10.0f }); // [4].\n        auto rotationMatrix = viewMatrix.rotation ({ -0.3f\u3001\n                                                      5.0f * std::sin ((float) getFrameCounter() * 0.01f)\u3001\n                                                      0.0f }); // [5]\n \n        return viewMatrix * rotationMatrix; // [6].\n    }\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"[4]: First we create an identity matrix translated by a vector to push the matrix 10 units back into the scene. This puts our teapot right at the center of the screen but a little bit far off."}),"\n",(0,r.jsx)(n.li,{children:"[5]: We then create a rotation matrix from the previously defined matrix that rotates the teapot around the y-axis depending on the rendering frame counter. This will also make the rotation change direction back and forth at the rate of the sin function."}),"\n",(0,r.jsx)(n.li,{children:"[6]: Finally we apply the rotation by multiplaying the matrices and return the view matrix."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"\u6570\u5b66\u7684\u8a08\u7b97\u90e8\u5206\u306f\u5b8c\u4e86\u3057\u305f\u306e\u3067\u3001\u6b21\u306b\u30b7\u30a7\u30fc\u30c0\u30fc\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304d\u59cb\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002"}),"\n",(0,r.jsx)(n.h1,{id:"writing-the-opengl-shaders",children:"Writing the OpenGL shaders"}),"\n",(0,r.jsx)(n.p,{children:"\u307e\u305a\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306e\u30b3\u30fc\u30c9\u30fb\u30d9\u30fc\u30b9\u5168\u4f53\u3067\u4f7f\u7528\u3059\u308b\u4fbf\u5229\u306a\u30e1\u30f3\u30d0\u5909\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u304b\u3089\u59cb\u3081\u307e\u3057\u3087\u3046\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    juce::String vertexShader;\n    juce::String fragmentShader;\n \n    std::unique_ptr shader;\n    std::unique_ptr shape;\n    std::unique_ptr attributes;\n    std::unique_ptr\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0\n \n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here we have defined several pointers to the shape, attributes and uniforms we will be using in this GL context as well as an ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLShaderProgram",title:"Manages an OpenGL shader program.",children:"OpenGLShaderProgramme"})," object that manages the shader program. We also have two char pointers to define the vertex shader and fragment shader as shown in the next step:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'void createShaders()\n    {\n        \u9802\u70b9\u30b7\u30a7\u30fc\u30c0 = R"(\n            \u5c5e\u6027 vec4 position\uff1b\n            \u5c5e\u6027 vec4 sourceColour\uff1b\n            \u5c5e\u6027 vec2 textureCoordIn\uff1b\n \n            \u4e00\u69d8\u306a mat4 projectionMatrix\uff1b\n            \u4e00\u69d8\u306a mat4 viewMatrix\uff1b\n \n            \u5909\u5316\u3059\u308b vec4 destinationColour\uff1b\n            \u5909\u5316\u3059\u308b vec2 textureCoordOut\uff1b\n \n            void main()\n            {\n                destinationColour = sourceColour\uff1b\n                textureCoordOut = textureCoordIn\uff1b\n                gl_Position = projectionMatrix * viewMatrix * position\uff1b\n            })";\n \n        \u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\n           #if JUCE_OPENGL_ES\n            R"(varying lowp vec4 destinationColour\uff1b\n               \u5909\u5316\u3059\u308b lowp vec2 textureCoordOut;)"\n           #\u305d\u308c\u4ee5\u964d\n            R"(varying vec4 destinationColour\uff1b\n               vec2 textureCoordOut\u3092\u5909\u5316\u3055\u305b\u308b;)"\n           #endif\n            R"(\n               void main()\n               {)"\n           #if JUCE_OPENGL_ES\n            R"( lowp vec4 color = vec4(0.95, 0.57, 0.03, 0.7);)" "\n           #else\n            R"( vec4 color = vec4(0.95, 0.57, 0.03, 0.7);)" #endif\n           #endif\n            R"( gl_FragColor = color\uff1b\n               })";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"createShaders()"})," function, we first copy the previously shown shaders into the char pointers by inserting line breaks. This function will be later called in the ",(0,r.jsx)(n.code,{children:"\u30a4\u30cb\u30b7\u30e3\u30e9\u30a4\u30ba()"})," function of the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"}),'. The vertex shader essentially sets the position of every vertex in the shape by setting the "gl_Position" variable to the product of the transformation matrices namely the projection matrix followed by the view matrix. As for the fragment shader, the colour of the pixel is specified by setting the "gl_FragColor" variable to the specified colour.']}),"\n",(0,r.jsxs)(n.p,{children:["In the second half of the ",(0,r.jsx)(n.code,{children:"createShaders()"})," function, we create a new shader program within the current GL context [1] and perform some initialisation as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'        std::unique_ptrnewShader (new juce::OpenGLShaderProgram (openGLContext)); // [1].\n        juce::String statusText\uff1b\n \n        if (newShader->addVertexShader (juce::OpenGLHelpers::translateVertexShaderToV3 (vertexShader)))          // [2]\n              && newShader->addFragmentShader (juce::OpenGLHelpers::translateFragmentShaderToV3 (fragmentShader))\n              && newShader->link())\n        {\n            shape .reset()\uff1b\n            attribute .reset()\uff1b\n            \u30e6\u30cb\u30d5\u30a9\u30fc\u30e0 .reset()\uff1b\n \n            shader.reset (newShader.release()); // [3].\n            shader->use()\uff1b\n \n            shape .reset (new Shape())\uff1b\n            attributes .reset (new Attributes (*shader))\uff1b\n            uniforms .reset (new Uniforms (*shader))\uff1b\n \n            statusText = "GLSL: v"+ juce::String (juce::OpenGLShaderProgram::getLanguageVersion(), 2)\uff1b\n        }\n        else\n        {\n            statusText = newShader->getLastError(); // [4].\n        }\n    }\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"[2]: We first add the vertex shader followed by the fragment shader and attempt to link the compiled shaders into a single program."}),"\n",(0,r.jsx)(n.li,{children:"[3]: If the compilation and linking of the shaders are successful, we can clear the shape, attributes and uniforms pointers, assign the newly created shader to the shader program pointer and instantiate new objects for the shape, attributes and uniforms pointers."}),"\n",(0,r.jsx)(n.li,{children:"[4]: We can optionally keep track of the initialisation status in case the compilation of shaders fails."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"\u3067\u306f\u3001\u9802\u70b9\u3001\u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3001\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0\u3001\u30b7\u30a7\u30a4\u30d7\u3092\u8868\u3059\u4fbf\u5229\u306a\u69cb\u9020\u3092\u5b9a\u7fa9\u3057\u3066\u307f\u3088\u3046\u3002"}),"\n",(0,r.jsx)(n.h2,{id:"the-vertex-struct",children:"The Vertex struct"}),"\n",(0,r.jsx)(n.p,{children:"\u9802\u70b9\u3092\u8868\u73fe\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b4\u3064\u306e\u91cd\u8981\u306a\u5909\u6570\u304c\u5fc5\u8981\u3067\u3042\u308b\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u9802\u70b9\u69cb\u9020\n    \n        float position[3]\uff1b\n        float normal[3]\uff1b\n        float color[4]\uff1b\n        float texCoord[2]\uff1b\n    };\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u4f4d\u7f6e\uff1a\u4f4d\u7f6e\u306e\u914d\u5217\u306f\u30013D\u5c40\u6240\u7a7a\u9593\u306b\u304a\u3051\u308b\u9802\u70b9\u306e\u4f4d\u7f6e\u3092\u8868\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u6cd5\u7dda\uff1a\u6cd5\u7dda\u914d\u5217\u306f\u3001\u96a3\u63a5\u3059\u308b\u9762\u306e\u6cd5\u7dda\u304b\u3089\u8a08\u7b97\u3055\u308c\u305f\u5f53\u8a72\u9802\u70b9\u306e\u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u65b9\u5411\u3092\u8868\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u8272\uff1a\u8272\u306e\u914d\u5217\u306f\u9802\u70b9\u306e\u8272\u3092 RGBA \u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u8868\u3057\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u30c6\u30af\u30b9\u30c1\u30e3\u5ea7\u6a19\uff1a\u30c6\u30af\u30b9\u30c1\u30e3\u3092\u4f7f\u7528\u3059\u308b\u5834\u5408\u3001\u305d\u306e\u9802\u70b9\u3067\u4f7f\u7528\u3059\u308b\u30c6\u30af\u30b9\u30c1\u30e3\u306e2D\u5ea7\u6a19\u3092\u8868\u3057\u307e\u3059\u3002"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"the-attributes-struct",children:"The Attributes struct"}),"\n",(0,r.jsxs)(n.p,{children:["The attributes structure is essentially a container class to hold several ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/structOpenGLShaderProgram_1_1Attribute",title:"Represents an openGL vertex attribute value.",children:"OpenGLShaderProgram::\u5c5e\u6027"})," objects together and the attributes we store are defined here:"]}),"\n",(0,r.jsx)(n.p,{children:"\u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u306f\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u9802\u70b9\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a18\u8ff0\u3059\u308b\u305f\u3081\u306e\u3082\u306e\u306a\u306e\u3067\u3001\u3053\u308c\u3089\u306f\u5148\u306b\u5b9a\u7fa9\u3057\u305fVertex\u69cb\u9020\u4f53\u306e\u5909\u6570\u306b\u6b63\u78ba\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u4e88\u60f3\u901a\u308a\u3001\u6b21\u306e\u30b9\u30c6\u30c3\u30d7\u3067\u5b9a\u7fa9\u3057\u305f\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30fb\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\u3092\u547c\u3073\u51fa\u3057\u3001\u5f15\u6570\u3068\u3057\u3066\u30b7\u30a7\u30fc\u30c0\u30fc\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u6e21\u3059\u3053\u3068\u3067\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5185\u3067\u3053\u308c\u3089\u306e\u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3092\u4f5c\u6210\u3059\u308b\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\u660e\u793a\u7684\u5c5e\u6027 (juce::OpenGLShaderProgram& shaderProgram)\n        {\n            position .reset (createAttribute (shaderProgram, "position"))\uff1b\n            normal .reset (createAttribute (shaderProgram, "normal"))\uff1b\n            sourceColour .reset\uff08createAttribute\uff08shaderProgram, "sourceColour"\uff09\uff09\uff1b\n            textureCoordIn .reset (createAttribute (shaderProgram, "textureCoordIn"))\uff1b\n        }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The helper function in turn will call the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/structOpenGLShaderProgram_1_1Attribute",title:"Represents an openGL vertex attribute value.",children:"OpenGLShaderProgram::\u5c5e\u6027"})," constructor to instantiate new objects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"private\uff1a\n        static juce::OpenGLShaderProgram::Attribute* createAttribute (juce::OpenGLShaderProgram& shader\u3001\n                                                                      const juce::String& attributeName)\n        {\n            \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n            if (glGetAttribLocation (shader.getProgramID(), attributeName.toRawUTF8()) < 0)\n                nullptr \u3092\u8fd4\u3059\uff1b\n \n            return new juce::OpenGLShaderProgram::Attribute (shader, attributeName.toRawUTF8())\uff1b\n        }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["However, in the above we first check whether the attribute exists in the shader program by using the ",(0,r.jsx)(n.code,{children:"glGetAttribLocation()"})," function. If the number returned is -1 then we abort the attribute instantiation."]}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"\u30a4\u30cd\u30fc\u30d6\u30eb()"})," function, all the attributes are activated (after checking if they exist) by calling the ",(0,r.jsx)(n.code,{children:"glVertexAttribPointer()"})," and ",(0,r.jsx)(n.code,{children:"glEnableVertexAttribArray()"})," functions as shown below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"void enable()\n        {\n            \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n            if (position.get() != nullptr)\n            {\n                glVertexAttribPointer (position->attributeID, 3, GL_FLOAT, GL_FALSE, sizeof (Vertex), nullptr)\uff1b\n                glEnableVertexAttribArray (position->attributeID)\uff1b\n            }\n \n            if (normal.get() != nullptr)\n            {\n                glVertexAttribPointer (normal->attributeID, 3, GL_FLOAT, GL_FALSE, sizeof (Vertex), (GLvoid*) (sizeof (float) * 3))\uff1b\n                glEnableVertexAttribArray (normal->attributeID)\uff1b\n            }\n \n            if (sourceColour.get() != nullptr)\n            {\n                glVertexAttribPointer (sourceColour->attributeID, 4, GL_FLOAT, GL_FALSE, sizeof (Vertex), (GLvoid*) (sizeof (float) * 6))\uff1b\n                glEnableVertexAttribArray (sourceColour->attributeID)\uff1b\n            }\n \n            if (textureCoordIn.get() != nullptr)\n            {\n                glVertexAttribPointer (textureCoordIn->attributeID, 2, GL_FLOAT, GL_FALSE, sizeof (Vertex), (GLvoid*) (sizeof (float) * 10))\uff1b\n                glEnableVertexAttribArray (textureCoordIn->attributeID)\uff1b\n            }\n        }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"glVertexAttribPointer()"})," function defines the array of vertex attribute data with information such as the index, size and type of data to hold. Notice that the last argument specifies the offset of the data cumulatively with regards to the other attributes defined previously in the structure. Then the ",(0,r.jsx)(n.code,{children:"glEnableVertexAttribArray()"})," function enables the actual array to be used within the context."]}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"\u7121\u52b9\u5316()"})," function, we do the exact opposite by calling the ",(0,r.jsx)(n.code,{children:"glDisableVertexAttribArray()"})," function on all attributes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u7121\u52b9\u5316()\n        {\n            \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n            if (position.get() != nullptr) glDisableVertexAttribArray (position->attributeID)\uff1b\n            if (normal.get() != nullptr) glDisableVertexAttribArray (normal->attributeID)\uff1b\n            if (sourceColour.get() != nullptr) glDisableVertexAttribArray (sourceColour->attributeID)\uff1b\n            if (textureCoordIn.get() != nullptr) glDisableVertexAttribArray (textureCoordIn->attributeID)\uff1b\n        }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"the-uniforms-struct",children:"The Uniforms struct"}),"\n",(0,r.jsxs)(n.p,{children:["The uniforms structure similarly contains several ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/structOpenGLShaderProgram_1_1Uniform",title:"Represents an openGL uniform value.",children:"OpenGLShaderProgram::\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0"})," objects in the same manner as defined here:"]}),"\n",(0,r.jsx)(n.p,{children:"\u3053\u308c\u3089\u306f\u3001\u5148\u306b\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\u30fc\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u5b9a\u7fa9\u3057\u305f\u884c\u5217\u5909\u6570\u306b\u6b63\u78ba\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\u3002"}),"\n",(0,r.jsx)(n.p,{children:"\u4e88\u60f3\u901a\u308a\u3001\u6b21\u306e\u30b9\u30c6\u30c3\u30d7\u3067\u5b9a\u7fa9\u3057\u305f\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30fb\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\u3092\u547c\u3073\u51fa\u3057\u3001\u5f15\u6570\u3068\u3057\u3066\u30b7\u30a7\u30fc\u30c0\u30fc\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u6e21\u3059\u3053\u3068\u3067\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5185\u3067\u3053\u308c\u3089\u306e\u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3092\u4f5c\u6210\u3059\u308b\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\u660e\u793a\u7684\u306a\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0 (juce::OpenGLShaderProgram& shaderProgram)\n        {\n            projectionMatrix .reset (createUniform (shaderProgram, "projectionMatrix"))\uff1b\n            viewMatrix .reset (createUniform (shaderProgram, "viewMatrix"))\uff1b\n        }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The helper function in turn will call the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/structOpenGLShaderProgram_1_1Uniform",title:"Represents an openGL uniform value.",children:"OpenGLShaderProgram::\u30e6\u30cb\u30d5\u30a9\u30fc\u30e0"})," constructor to instantiate new objects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"private\uff1a\n        static juce::OpenGLShaderProgram::Uniform* createUniform (juce::OpenGLShaderProgram& shaderProgram\u3001\n                                                                  const juce::String& uniformName)\n        {\n            \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n            if (glGetUniformLocation (shaderProgram.getProgramID(), uniformName.toRawUTF8()) < 0)\n                return nullptr\uff1b\n \n            return new juce::OpenGLShaderProgram::Uniform (shaderProgram, uniformName.toRawUTF8())\uff1b\n        }\n    };\n"})}),"\n",(0,r.jsxs)(n.p,{children:["However, in the above we first check whether the uniform exists in the shader program by using the ",(0,r.jsx)(n.code,{children:"glGetUniformLocation()"})," function. If the number returned is -1 then we abort the uniform instantiation."]}),"\n",(0,r.jsx)(n.h2,{id:"the-shape-struct",children:"The Shape struct"}),"\n",(0,r.jsx)(n.p,{children:"Shape\u69cb\u9020\u4f53\u306f\u3001OpenGL\u7528\u8a9e\u3067\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u5b9a\u7fa9\u3059\u308b\u5834\u6240\u3067\u3059\u3002\u30e1\u30f3\u30d0\u5909\u6570\u306f\u3001\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u30e2\u30c7\u30eb\u306eWavefront Obj\u30d5\u30a1\u30a4\u30eb\u3068\u3001\u3059\u3050\u4e0b\u306e\u30b5\u30d6\u69cb\u9020\u4f53\u3068\u3057\u3066\u5b9a\u7fa9\u3055\u308c\u305f\u9802\u70b9\u30d0\u30c3\u30d5\u30a1\u306e\u914d\u5217\u3092\u683c\u7d0d\u3059\u308b\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"        WavefrontObjFile shapeFile;\n        juce::OwnedArray\u9802\u70b9\u30d0\u30c3\u30d5\u30a1\uff1b\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u307e\u305a\u3001\u9802\u70b9\u30d0\u30c3\u30d5\u30a1\u304c\u3069\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u304b\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u3053\u306e\u30d0\u30c3\u30d5\u30a1\u306b\u306f\u3001\u30e1\u30c3\u30b7\u30e5\u5185\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u7dcf\u6570\u3068\u3001\u5f8c\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u306b\u5099\u3048\u308b\u305f\u3081\u306e\u9802\u70b9\u30d0\u30c3\u30d5\u30a1\u3068\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u30d0\u30c3\u30d5\u30a1\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"GLuint vertexBuffer, indexBuffer\uff1b\n            int numIndices\uff1b\n \n            JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VertexBuffer)\n        };\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u3053\u306e\u30af\u30e9\u30b9\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306f\u3001\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u9802\u70b9\u30d0\u30c3\u30d5\u30a1\u3092\u521d\u671f\u5316\u3057\u307e\u3059\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"            explicit VertexBuffer (WavefrontObjFile::Shape& aShape)\n            {\n                using namespace ::juce::gl;\n \n                numIndices = aShape.mesh.indices.size();                                    // [1]\n \n                glGenBuffers (1, &vertexBuffer);                                            // [2]\n                glBindBuffer (GL_ARRAY_BUFFER, vertexBuffer);\n \n                juce::Array vertices;\n                createVertexListFromMesh (aShape.mesh, vertices, juce::Colours::green);     // [3]\n \n                glBufferData (GL_ARRAY_BUFFER,                                              // [4]\n                              static_cast (static_cast (vertices.size()) * sizeof (Vertex)),\n                              vertices.getRawDataPointer(), GL_STATIC_DRAW);\n \n                glGenBuffers (1, &indexBuffer);                                             // [5]\n                glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, indexBuffer);\n                glBufferData (GL_ELEMENT_ARRAY_BUFFER,\n                              static_cast (static_cast(numIndices) * sizeof (juce::uint32))\u3001\n                              aShape.mesh.indices.getRawDataPointer(), GL_STATIC_DRAW)\uff1b\n            }\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"[1]: We first retrieve the number of indices in the mesh we want to draw."}),"\n",(0,r.jsxs)(n.li,{children:["[2]: Then we generate the buffer object name for our single vertex buffer with the ",(0,r.jsx)(n.code,{children:"glGenBuffers()"})," function and bind the vertex attributes to it with the ",(0,r.jsx)(n.code,{children:"glBindBuffer()"})," function."]}),"\n",(0,r.jsx)(n.li,{children:"[3]: Using the helper function defined below, we create a vertex list from the teapot mesh."}),"\n",(0,r.jsxs)(n.li,{children:["[4]: We can then copy the vertex list into the vertex buffer by calling the ",(0,r.jsx)(n.code,{children:"glBufferData()"})," function."]}),"\n",(0,r.jsx)(n.li,{children:"[5]: Finally we do the same for the index buffer by generating the buffer object name, binding the vertex array indices to it and copying the indices into the index buffer."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"\u9802\u70b9\u30ea\u30b9\u30c8\u304b\u3089\u30e1\u30c3\u30b7\u30e5\u3092\u4f5c\u6210\u3059\u308b\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"        static void createVertexListFromMesh (const WavefrontObjFile::Mesh& mesh, juce::Array\u30ea\u30b9\u30c8, juce::Colour \u30ab\u30e9\u30fc)\n        {\n            auto scale = 0.2f; // [6\uff3d\n            WavefrontObjFile::TextureCoord defaultTexCoord { 0.5f, 0.5f }\uff1b\n            WavefrontObjFile::Vertex defaultNormal { 0.5f, 0.5f, 0.5f }\uff1b\n \n            for (auto i = 0; i < mesh.vertices.size(); ++i) // [7].\n            {\n                const auto& v = mesh.vertices.getReference (i)\uff1b\n                const auto& n = i < mesh.normals.size() ? mesh.normals.getReference (i) : defaultNormal\uff1b\n                const auto& tc = i < mesh.textureCoords.size() ? mesh.textureCoords.getReference (i) : defaultTexCoord\uff1b\n \n                list.add ({ { scale * v.x, scale * v.y, scale * v.z, }\u3001\n                            { scale * n.x, scale * n.y, scale * n.z, }\u3001\n                            { color.getFloatRed(), color.getFloatGreen(), color.getFloatBlue(), color.getFloatAlpha() }\u3001\n                            { tc.x, tc.y }.}); // [8]\n            }\n        }\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"[6]: We first define several local variables for the mesh scale, the default texture coordinates and the default normal vector."}),"\n",(0,r.jsx)(n.li,{children:"[7]: Then for every vertex in the mesh, we get a reference to the vertex position, normal vector and texture coordinates to create a new Vertex object that we defined earlier."}),"\n",(0,r.jsx)(n.li,{children:"[8]: On the Vertex object that was created, we scale the position and normal vectors, assign a dummy green colour and finally we add it to the vertex list."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In the destructor, we delete the vertex and index buffers by calling the ",(0,r.jsx)(n.code,{children:"glDeleteBuffers()"})," function on each variable:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"~\u9802\u70b9\u30d0\u30c3\u30d5\u30a1()\n            {\n                \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n                glDeleteBuffers (1, &vertexBuffer)\uff1b\n                glDeleteBuffers (1, &indexBuffer)\uff1b\n            }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"\u30d0\u30a4\u30f3\u30c9"})," function defined below is called when the shape is drawn and binds the vertex and index buffers using the ",(0,r.jsx)(n.code,{children:"glBindBuffer()"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"void bind()\n{\n    \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n    glBindBuffer (GL_ARRAY_BUFFER, vertexBuffer)\uff1b\n    glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, indexBuffer)\uff1b\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u3055\u3066\u3001\u30b7\u30a7\u30a4\u30d7\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306b\u623b\u3063\u3066\u3001\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u306e\u30d0\u30a4\u30ca\u30ea\u30c7\u30fc\u30bf\u3092WavefrontObjFile\u5909\u6570\u306b\u30ed\u30fc\u30c9\u3057\u3066\u307f\u307e\u3057\u3087\u3046\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\u5f62\u72b6()\n        {\n            auto dir = juce::File::getCurrentWorkingDirectory()\uff1b\n \n            int numTries = 0\uff1b\n \n            while (! dir.getChildFile ("Resources").exists() && numTries++ < 15)\n                dir = dir.getParentDirectory()\uff1b\n \n            if (shapeFile.load (dir.getChildFile ("Resources").getChildFile ("teapot.obj")).wasOk())\n                for (auto* s : shapeFile.shapes)\n                    vertexBuffers.add (new VertexBuffer (*s))\uff1b\n        }\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:['Make sure that the "teapot.obj" file exists in the ',(0,r.jsx)(n.code,{children:"\u30ea\u30bd\u30fc\u30b9"})," folder of your project."]})}),"\n",(0,r.jsx)(n.p,{children:"\u30ed\u30fc\u30c9\u306b\u6210\u529f\u3059\u308c\u3070\u3001WavefrontObjFile\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u542b\u307e\u308c\u308b\u3059\u3079\u3066\u306e\u5f62\u72b6\u3092\u7e70\u308a\u8fd4\u3057\u51e6\u7406\u3057\u3001\u65b0\u3057\u3044VertexBuffer\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3057\u3066\u9802\u70b9\u30d0\u30c3\u30d5\u30a1\u914d\u5217\u306b\u8ffd\u52a0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002"}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we implement a ",(0,r.jsx)(n.code,{children:"\u30c9\u30ed\u30fc()"})," function that will be called in the ",(0,r.jsx)(n.code,{children:"\u30ec\u30f3\u30c0\u30fc"})," function of the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"})," later on as defined below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"void draw (Attributes& glAttributes)\n        {\n            \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n            for (auto* vertexBuffer : vertexBuffers)\n            {\n                vertexBuffer->bind()\uff1b\n \n                glAttributes.enable()\uff1b\n                glDrawElements (GL_TRIANGLES, vertexBuffer->numIndices, GL_UNSIGNED_INT, nullptr)\uff1b\n                glAttributes.disable()\uff1b\n            }\n        }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For every vertex buffer in the member variable array, we first call the ",(0,r.jsx)(n.code,{children:"\u30d0\u30a4\u30f3\u30c9"})," function to bind the vertex and index buffers to the GL context. We then call the ",(0,r.jsx)(n.code,{children:"\u30a4\u30cd\u30fc\u30d6\u30eb()"})," function defined earlier on every attribute to fill the arrays with data. Finally, the ",(0,r.jsx)(n.code,{children:"glDrawElements"})," function draws every set of three vertices contained in the vertex buffer as triangles before the attributes are disabled and emptied."]}),"\n",(0,r.jsx)(n.h1,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,r.jsx)(n.p,{children:"\u3053\u308c\u3067\u3001\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8\u3092\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3059\u308b\u305f\u3081\u306e\u3059\u3079\u3066\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304c\u63c3\u3063\u305f\u3002"}),"\n",(0,r.jsxs)(n.p,{children:["As mentioned before our app inherits from the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"})," class as shown here in the ",(0,r.jsx)(n.code,{children:"\u30e1\u30a4\u30f3\u30b3\u30f3\u30c6\u30f3\u30c4\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"class MainContentComponent : public juce::OpenGLAppComponent\n{\npublic\uff1a\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the class constructor, we set the size of our window as usual using the ",(0,r.jsx)(n.code,{children:"setSize()"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"MainContentComponent()\n    {\n        setSize (800, 600)\uff1b\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the class destructor, we make sure that the OpenGL system is shutdown before our class is destroyed by calling the ",(0,r.jsx)(n.code,{children:"shutdownOpenGL()"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"~MainContentComponent()\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        shutdownOpenGL()\uff1b\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As described before the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"})," class provides startup and shutdown functions to facilitate implementation of our graphics application. In the ",(0,r.jsx)(n.code,{children:"\u30a4\u30cb\u30b7\u30e3\u30e9\u30a4\u30ba()"})," function we call the helper function ",(0,r.jsx)(n.code,{children:"createShaders()"})," defined earlier to prepare the vertex and fragment shaders as shown here:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"void initialise() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        createShaders()\uff1b\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As for the ",(0,r.jsx)(n.code,{children:"\u30b7\u30e3\u30c3\u30c8\u30c0\u30a6\u30f3"})," function, we ensure there is no leakage by setting all the member variable pointers to null as done here:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"void shutdown() override\n    {\n        shader .reset()\uff1b\n        shape .reset()\uff1b\n        \u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8 .reset()\uff1b\n        \u30e6\u30cb\u30d5\u30a9\u30fc\u30e0 .reset()\uff1b\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Next, we perform the actual rendering by overriding the ",(0,r.jsx)(n.code,{children:'[OpenGLAppComponent::render()](classOpenGLAppComponent.html#af4e76e80318343d5302be7af6bf4cdbc "Called to render your openGL.")'})," function as explained below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"void render() \u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\n    {\n        \u540d\u524d\u7a7a\u9593 ::juce::gl\uff1b\n \n        jassert (juce::OpenGLHelpers::isContextActive())\uff1b\n \n        auto desktopScale = (float) openGLContext.getRenderingScale(); // [1].\n        juce::OpenGLHelpers::clear (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId)); // [2].\n \n        glEnable (GL_BLEND); // [3].\n        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\uff1b\n \n        glViewport (0\u3001\n                    0,\n                    juce::roundToInt (desktopScale * (float) getWidth())\u3001\n                    juce::roundToInt (desktopScale * (float) getHeight())); // [4].\n \n        shader->use(); // [5].\n \n        if (uniforms->projectionMatrix.get() != nullptr) // [6].\n            uniforms->projectionMatrix->setMatrix4 (getProjectionMatrix().mat, 1, false)\uff1b\n \n        if (uniforms->viewMatrix.get() != nullptr) // [7].\n            uniforms->viewMatrix->setMatrix4 (getViewMatrix().mat, 1, false)\uff1b\n \n        shape->draw (*attributes); // [8].\n \n        \u5b50\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304c\u6b63\u3057\u304f\u63cf\u753b\u3055\u308c\u308b\u3088\u3046\u306b\u3001 // \u8981\u7d20\u30d0\u30c3\u30d5\u30a1\u3092\u30ea\u30bb\u30c3\u30c8\u3059\u308b\u3002\n        glBindBuffer (GL_ARRAY_BUFFER, 0); // [9].\n        glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0)\uff1b\n    }\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["[1]: First check that the GL context is active using the ",(0,r.jsx)(n.code,{children:'[OpenGLHelpers::isContextActive()](classOpenGLHelpers.html#aeb9c20e316e3aa59046a4fe4cb2562f8 "Returns true if the current thread has an active OpenGL context.")'})," function so that we can retrieve the scale factor of the rendering display."]}),"\n",(0,r.jsx)(n.li,{children:"[2]: We can then clear the display by painting the background with the appropriate look and feel colour."}),"\n",(0,r.jsxs)(n.li,{children:["[3]: This goes beyond the scope of the tutorial but the ",(0,r.jsx)(n.code,{children:"glEnable()"}),' function activates the "GL_BLEND" option which blends the colour of the computed fragment colour with the colour buffer values. The blending method is specified in the ',(0,r.jsx)(n.code,{children:"glBlendFunc()"})," function by specifying the transparency calculation."]}),"\n",(0,r.jsxs)(n.li,{children:["[4]: The ",(0,r.jsx)(n.code,{children:"glViewport()"})," function sets the viewport of the GL window relative to the device screen by multiplying the width and height by the rendering display scale factor."]}),"\n",(0,r.jsxs)(n.li,{children:["[5]: By calling the ",(0,r.jsx)(n.code,{children:"\u4f7f\u7528"})," function on the shader pointer, we specify which shader we want to use in this GL context."]}),"\n",(0,r.jsx)(n.li,{children:"[6]: We set the projection matrix as a uniform variable from our helper function to compute the shader."}),"\n",(0,r.jsx)(n.li,{children:"[7]: We also set the view matrix as a uniform variable from our helper function to compute the shader."}),"\n",(0,r.jsxs)(n.li,{children:["[8]: Finally, we call the ",(0,r.jsx)(n.code,{children:"\u30c9\u30ed\u30fc()"})," function defined earlier on the shape pointer to render the teapot within the GL context and attributes specified as arguments."]}),"\n",(0,r.jsxs)(n.li,{children:["[9]: We also make sure to empty the vertex attributes and vertex array indices using the ",(0,r.jsx)(n.code,{children:"glBindBuffer()"})," function on the GL context."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:'\u63a5\u982d\u8f9e\u304c "gl "\u3067\u3042\u308b\u95a2\u6570\u306f\u3059\u3079\u3066\u3001JUCE\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u306f\u306a\u304f\u3001\u958b\u767a\u30de\u30b7\u30f3\u306eOpenGL\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002'})}),"\n",(0,r.jsx)(n.h1,{id:"\u6982\u8981",children:"\u6982\u8981"}),"\n",(0,r.jsx)(n.p,{children:"\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3001OpenGL JUCE \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u65b9\u6cd5\u3092\u5b66\u3073\u307e\u3057\u305f\u3002\u7279\u306b"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Learnt the functionalities of the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLAppComponent",title:"A base class for writing simple one-page graphical apps.",children:"OpenGLAppComponent"})," class."]}),"\n",(0,r.jsx)(n.li,{children:"Wavefront\u306eObj\u30d5\u30a1\u30a4\u30eb\u3092OpenGL\u30ec\u30f3\u30c0\u30e9\u30fc\u306b\u30ed\u30fc\u30c9\u3057\u305f\u3002"}),"\n",(0,r.jsx)(n.li,{children:"\u8a08\u7b97\u3055\u308c\u305f\u6295\u5f71\u884c\u5217\u3068\u30d3\u30e5\u30fc\u884c\u5217\u3002"}),"\n",(0,r.jsxs)(n.li,{children:["Configured the ",(0,r.jsx)(n.a,{href:"https://docs.juce.com/master/classOpenGLContext",title:"Creates an OpenGL context, which can be attached to a component.",children:"OpenGLContext"})," and render appearance using shaders."]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"\u95a2\u9023\u9805\u76ee",children:"\u95a2\u9023\u9805\u76ee"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../tutorial_main_window/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u30fb\u30a6\u30a3\u30f3\u30c9\u30a6"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../tutorial_main_component/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30e1\u30a4\u30f3\u30fb\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../tutorial_graphics_class/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30ebGraphics\u30af\u30e9\u30b9"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../tutorial_component_parents_children/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u89aa\u5b50\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../tutorial_animation/",children:"\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u30b8\u30aa\u30e1\u30c8\u30ea\u306e\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3449:(e,n,t)=>{t.d(n,{A:()=>i});var r=t(4848);function i(e){let{src:n,caption:t,alt:i,width:s,height:a}=e;return(0,r.jsxs)("figure",{children:[(0,r.jsx)("img",{src:n,alt:i||t,width:s,height:a}),(0,r.jsx)("figcaption",{children:(0,r.jsx)("b",{children:t})})]})}},5706:(e,n,t)=>{t.d(n,{A:()=>s});var r=t(4848);const i=e=>e.includes("::")?"struct"+e.replace("::","_1_1"):"class"+e;function s(e){let{refs:n}=e;return(0,r.jsxs)("p",{children:["\u30af\u30e9\u30b9\uff1a",n.map((e=>(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("a",{href:`https://docs.juce.com/master/${i(e)}.html`,children:e}),", "]})))]})}},6378:(e,n,t)=>{t.d(n,{A:()=>i});var r=t(4848);function i(e){let{path:n}=e;return(0,r.jsx)("p",{children:(0,r.jsx)("a",{href:`https://docs.juce.com/master/${n}.html`,children:"\ud83d\udcda Source Page"})})}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);