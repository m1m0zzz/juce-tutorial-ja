"use strict";(self.webpackChunkjuce_tutorial_ja=self.webpackChunkjuce_tutorial_ja||[]).push([[752],{6087:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(4848),a=n(8453);const i={title:"App analytics collection",sidebar_position:6},r="Tutorial: App analytics collection",o={id:"utility-classes/tutorial_analytics_collection",title:"App analytics collection",description:"Collect app usage data from users in JUCE applications. Send analytics events to Google Analytics using the analytics module.",source:"@site/docs/utility-classes/tutorial_analytics_collection.mdx",sourceDirName:"utility-classes",slug:"/utility-classes/tutorial_analytics_collection",permalink:"/juce-tutorial-ja/utility-classes/tutorial_analytics_collection",draft:!1,unlisted:!1,editUrl:"https://github.com/m1m0zzz/juce-tutorial-ja/tree/main/docs/utility-classes/tutorial_analytics_collection.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"App analytics collection",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Using an UndoManager with a ValueTree",permalink:"/juce-tutorial-ja/utility-classes/tutorial_undo_manager_value_tree"},next:{title:"Unlock your plugins through online registration",permalink:"/juce-tutorial-ja/utility-classes/tutorial_online_unlock_status"}},l={},c=[{value:"\u306f\u3058\u3081\u308b",id:"\u306f\u3058\u3081\u308b",level:2},{value:"Formatting the HTTP request",id:"formatting-the-http-request",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{CaptionImage:n,SourcePageLink:i}=t;return n||u("CaptionImage",!0),i||u("SourcePageLink",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i,{path:"tutorial_analytics_collection"}),"\n",(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"tutorial-app-analytics-collection",children:"Tutorial: App analytics collection"})}),"\n",(0,s.jsx)(t.p,{children:"Collect app usage data from users in JUCE applications. Send analytics events to Google Analytics using the analytics module."}),"\n",(0,s.jsx)(t.p,{children:"Level: Intermediate"}),"\n",(0,s.jsx)(t.p,{children:"Platforms: Windows, macOS, Linux, iOS, Android"}),"\n",(0,s.jsxs)(t.p,{children:["Classes: ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classThreadedAnalyticsDestination",title:"A base class for dispatching analytics events on a dedicated thread.",children:"ThreadedAnalyticsDestination"}),", ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classButtonTracker",title:"A class that automatically sends analytics events to the Analytics singleton when a button is clicked...",children:"ButtonTracker"}),", ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classWebInputStream",title:"An InputStream which can be used to read from a given URL.",children:"WebInputStream"}),", ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classCriticalSection",title:"A re-entrant mutex.",children:"CriticalSection"}),", ",(0,s.jsx)(t.a,{href:"classCriticalSection.html#a4d398019b977a4c2151c6f1e2a06210b",title:"Provides the type of scoped lock to use with a CriticalSection.",children:"CriticalSection::ScopedLockType"})]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["This project requires a Google Analytics account. If you need help with this, follow the instructions on the ",(0,s.jsx)(t.a,{href:"https://support.google.com/analytics/",children:"Google Analytics website"})," to open an account."]})}),"\n",(0,s.jsx)(t.h2,{id:"\u306f\u3058\u3081\u308b",children:"\u306f\u3058\u3081\u308b"}),"\n",(0,s.jsxs)(t.p,{children:["Download the demo project for this tutorial here: ",(0,s.jsx)(t.a,{href:"/tutorials/PIPs/AnalyticsCollectionTutorial.zip",children:"PIP"})," | ",(0,s.jsx)(t.a,{href:"/tutorials/ZIPs/AnalyticsCollectionTutorial.zip",children:"ZIP"}),". Unzip the project and open the first header file in the Projucer."]}),"\n",(0,s.jsxs)(t.p,{children:["If you need help with this step, see ",(0,s.jsx)(t.a,{href:"../tutorial_new_projucer_project/",children:"Tutorial: Projucer Part 1: Getting started with the Projucer"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Please make sure you have your Google Analytics API key written down and ready for this tutorial to fully work."}),"\n",(0,s.jsx)(t.h1,{id:"the-demo-project",children:"The demo project"}),"\n",(0,s.jsx)(t.p,{children:"The demo project shows a very simple UI with two buttons sending analytics events when pressed. Since the API key has not been set up yet, Google will not receive any events before implementation."}),"\n",(0,s.jsx)(n,{src:"https://docs.juce.com/master/tutorial_analytics_collection_screenshot1.png",caption:"The demo project app window"}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsx)(t.p,{children:"This project uses Google Analytics to track app analytics but you can apply this to any other service you wish to use."}),(0,s.jsxs)(t.p,{children:["The code presented here is broadly similar to the ",(0,s.jsx)(t.strong,{children:"AnalyticsCollection"})," from the JUCE Examples."]})]}),"\n",(0,s.jsx)(t.h1,{id:"anatomy-of-events",children:"Anatomy of events"}),"\n",(0,s.jsx)(t.p,{children:"Events describe how the user has interacted with the content in applications and are sent to the analytics tracking system. To better categorise and filter the interactions, events are structured using the following keywords:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Category: Describes groups of events that are combined under the analytics reports."}),"\n",(0,s.jsx)(t.li,{children:"Action: Specifies the action that was performed to trigger the event."}),"\n",(0,s.jsx)(t.li,{children:"Label: Additional information explaining the specific object that interacted with the user."}),"\n",(0,s.jsxs)(t.li,{children:["Value: ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classOptional",title:"A simple optional type.",children:"Optional"})," integer to provide numerical data to the event in question."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"All the events are sent with a unique user ID and a timestamp along with the keywords mentioned above. Additionally, users can be grouped into categories to better describe their capacity such as beta testers or developers."}),"\n",(0,s.jsx)(t.h1,{id:"api-key-set-up",children:"API key set up"}),"\n",(0,s.jsx)(t.p,{children:"The first step for the project to work properly is to set up the Google Analytics API key. You can find the Tracking ID in your Google Analytics dashboard here:"}),"\n",(0,s.jsx)(n,{src:"https://docs.juce.com/master/tutorial_analytics_collection_screenshot2.png",caption:"Google Analytics Tracking ID"}),"\n",(0,s.jsxs)(t.p,{children:["Copy this ID, and replace the ",(0,s.jsx)(t.code,{children:"apiKey"})," placeholder variable in the ",(0,s.jsx)(t.code,{children:"GoogleAnalyticsDestination"})," class:"]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"Ideally, this API key should not be visible in your binary distribution as there could be all sorts of malicious uses if discovered and may pollute your analytics data with spam. One way to prevent this would be to retrieve the API key dynamically at runtime (such as from your own server)."})}),"\n",(0,s.jsx)(t.h1,{id:"tracking-app-startup",children:"Tracking app startup"}),"\n",(0,s.jsxs)(t.p,{children:["Let's first start by tracking user-independent information such as app launches and define constant user information that will be used by the analytics system. In the constructor of the ",(0,s.jsx)(t.code,{children:"MainContentComponent"})," class, we start by getting a reference to the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classAnalytics",title:"A singleton class to manage analytics data.",children:"Analytics"})," singleton by calling ",(0,s.jsx)(t.code,{children:"Analytics::getInstance()"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["We can then set the user ID with ",(0,s.jsx)(t.code,{children:"setUserID()"})," by choosing a unique identifier for this user [1]. Make sure not to include any sensitive personal information in this identifier. We can also set a user group on this user by calling ",(0,s.jsx)(t.code,{children:"setUserProperties()"})," using a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classStringPairArray",title:"A container for holding a set of strings which are keyed by another string.",children:"StringPairArray"})," [2]."]}),"\n",(0,s.jsxs)(t.p,{children:["For the events to be received, we need to specify at least one destination to our ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classAnalytics",title:"A singleton class to manage analytics data.",children:"Analytics"})," instance. We can optionally add multiple destinations if we wish. In this case we add an instance of the GoogleAnalyticsDestination class to the singleton [3]."]}),"\n",(0,s.jsxs)(t.p,{children:["Since the ",(0,s.jsx)(t.code,{children:"MainContentComponent"})," constructor gets called when the MainWindow is instantiated, we can log this event using the function ",(0,s.jsx)(t.code,{children:"logEvent()"})," right when the component gets owned by the MainWindow [4]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    MainContentComponent()\n    {\n        // Add an analytics identifier for the user. Make sure you don\'t accidentally\n        // collect identifiable information if you haven\'t asked for permission!\n        juce::Analytics::getInstance()->setUserId ("AnonUser1234");                                 // [1]\n \n        // Add any other constant user information.\n        juce::StringPairArray userData;\n        userData.set ("group", "beta");\n        juce::Analytics::getInstance()->setUserProperties (userData);                               // [2]\n \n        // Add any analytics destinations we want to use to the Analytics singleton.\n        juce::Analytics::getInstance()->addDestination (new GoogleAnalyticsDestination());          // [3]\n \n        // The event type here should probably be DemoAnalyticsEventTypes::sessionStart\n        // in a more advanced app.\n        juce::Analytics::getInstance()->logEvent ("startup", {}, DemoAnalyticsEventTypes::event);   // [4]\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Likewise, we can log the shutdown event in the ",(0,s.jsx)(t.code,{children:"MainContentComponent"})," destructor right when the MainWindow gets deleted [5]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    ~MainContentComponent() override\n    {\n        // The event type here should probably be DemoAnalyticsEventTypes::sessionEnd\n        // in a more advanced app.\n        juce::Analytics::getInstance()->logEvent ("shutdown", {}, DemoAnalyticsEventTypes::event);  // [5]\n    }\n'})}),"\n",(0,s.jsx)(t.h1,{id:"tracking-button-behaviour",children:"Tracking Button behaviour"}),"\n",(0,s.jsxs)(t.p,{children:["In order to add tracking to specific user actions, we need to define which user interactions we want recorded and sent. Fortunately to record button behaviour, we can use a handy class included in the JUCE analytics module called ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classButtonTracker",title:"A class that automatically sends analytics events to the Analytics singleton when a button is clicked...",children:"ButtonTracker"})," that will automatically handle this for us."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's first declare a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classButtonTracker",title:"A class that automatically sends analytics events to the Analytics singleton when a button is clicked...",children:"ButtonTracker"})," as a member variable in the ",(0,s.jsx)(t.code,{children:"MainContentComponent"})," class [1]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    juce::TextButton eventButton { "Press me!" }, crashButton { "Simulate crash!" };\n    std::unique_ptr logEventButtonPress;   // [1]\n \n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)\n};\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Now in the MainContentComponent constructor, we can link the specific ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classTextButton",title:"A button that uses the standard lozenge-shaped background with a line of text on it.",children:"TextButton"})," object we want to track by passing it as an argument to the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classButtonTracker",title:"A class that automatically sends analytics events to the Analytics singleton when a button is clicked...",children:"ButtonTracker"})," constructor. We also set the event category and action properties to send when the event is fired [2]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'        juce::StringPairArray logButtonPressParameters;\n        logButtonPressParameters.set ("id", "a");\n        logEventButtonPress.reset (new juce::ButtonTracker (eventButton, "button_press", logButtonPressParameters)); // [2]\n    }\n'})}),"\n",(0,s.jsx)(t.p,{children:"Create additional GUI components and implement tracking on them with different event parameters."}),"\n",(0,s.jsx)(t.h1,{id:"sending-events",children:"Sending events"}),"\n",(0,s.jsxs)(t.p,{children:["The JUCE analytics module handles the logging of events on a dedicated thread and sends the analytics data in batches periodically. Therefore, we need to temporarily store the events on local storage until the data is sent. In the rest of this tutorial, we will be working in the ",(0,s.jsx)(t.code,{children:"GoogleAnalyticsDestination"})," class."]}),"\n",(0,s.jsxs)(t.p,{children:["We first need to specify a location to store our analytics event data in the application data directory. For this we use the special location ",(0,s.jsx)(t.code,{children:'[File::userApplicationDataDirectory](classFile.html#a3e19cafabb03c5838160263a6e76313da0c9f89d8dc9f9f32c9eb42428385351d "The folder in which applications store their persistent user-specific settings.")'})," to find the correct location and navigate to the corresponding application folder for our app [1]. If the location does not exist we create the folder [2] and save the file path as an XML file name extension [3]."]}),"\n",(0,s.jsxs)(t.p,{children:["We can now start the thread by using the ",(0,s.jsx)(t.code,{children:"startAnalyticsThread()"})," function and specifying the waiting time between batches of events in milliseconds [4]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    GoogleAnalyticsDestination()\n        : ThreadedAnalyticsDestination ("GoogleAnalyticsThread")\n    {\n        {\n            // Choose where to save any unsent events.\n \n            auto appDataDir = juce::File::getSpecialLocation (juce::File::userApplicationDataDirectory)\n                                   .getChildFile (juce::JUCEApplication::getInstance()->getApplicationName());  // [1]\n \n            if (! appDataDir.exists())\n                appDataDir.createDirectory();                                                                   // [2]\n \n            savedEventsFile = appDataDir.getChildFile ("analytics_events.xml");                                 // [3]\n        }\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"        startAnalyticsThread (initialPeriodMs);                                                                 // [4]\n    }\n"})}),"\n",(0,s.jsx)(t.p,{children:"In the class destructor, we have to ensure that the last batch of events can be sent without the application being killed by the operating system. To allow this, we provide one last batch period while sleeping the thread before stopping it forcibly after 1 second. This provides enough time for one last sending attempt without elongating too much the application shutdown time."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"    ~GoogleAnalyticsDestination() override\n    {\n        // Here we sleep so that our background thread has a chance to send the\n        // last lot of batched events. Be careful - if your app takes too long to\n        // shut down then some operating systems will kill it forcibly!\n        juce::Thread::sleep (initialPeriodMs);  // [5]\n \n        stopAnalyticsThread (1000);             // [6]\n    }\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We can supply the maximum number of events to send in batches by overriding the ",(0,s.jsx)(t.code,{children:"getMaximumBatchSize()"})," function like so:"]}),"\n",(0,s.jsx)(t.h2,{id:"formatting-the-http-request",children:"Formatting the HTTP request"}),"\n",(0,s.jsxs)(t.p,{children:["Now we need to format the correct HTTP request to log these events to the analytics server. The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classURL",title:"Represents a URL and has a bunch of useful functions to manipulate it.",children:"URL"})," we are trying to construct with its corresponding POST data in the case of a button press behaviour for example looks something like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"POST /batch HTTP/1.1\nHost: www.google-analytics.com\n \nv=1                            // Version Number\n&aip=1                         // Anonymise IP\n&tid=UA-XXXXXXXXX-1            // Tracking ID\n&t=event                       // Log Type\n&ec=button_press               // Event Category\n&ea=a                          // Event Action\n&cid=AnonUser1234              // User ID\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"[v]: The batch logging API version."}),"\n",(0,s.jsx)(t.li,{children:"[aip]: The IP address of the sender is anonymised."}),"\n",(0,s.jsx)(t.li,{children:"[tid]: The Tracking ID for the corresponding app."}),"\n",(0,s.jsx)(t.li,{children:"[t]: The type of logging for the analytics system."}),"\n",(0,s.jsx)(t.li,{children:"[ec]: The category identifier for the logged event."}),"\n",(0,s.jsx)(t.li,{children:"[ea]: The action identifier for the logged event."}),"\n",(0,s.jsx)(t.li,{children:"[cid]: The user ID for the corresponding user."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In a typical app lifecycle, the batched logger will first process the appStarted event when the application is fired up. Then when the user clicks on the button we log the button_press event and finally log the appStopped event when the application quits."}),"\n",(0,s.jsxs)(t.p,{children:["In order to account for these 3 logging scenarios, we need to construct different requests in the ",(0,s.jsx)(t.code,{children:"logBatchedEvents()"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    bool logBatchedEvents (const juce::Array& events) override\n    {\n        // Send events to Google Analytics.\n \n        juce::String appData ("v=1&aip=1&tid=" + apiKey);       // [1]\n \n        juce::StringArray postData;\n \n        for (auto& event : events)                              // [2]\n        {\n            juce::StringPairArray data;\n \n            switch (event.eventType)\n            {\n                case (DemoAnalyticsEventTypes::event):\n                {\n                    data.set ("t", "event");\n \n                    if (event.name == "startup")\n                    {\n                        data.set ("ec",  "info");\n                        data.set ("ea",  "appStarted");\n                    }\n                    else if (event.name == "shutdown")\n                    {\n                        data.set ("ec",  "info");\n                        data.set ("ea",  "appStopped");\n                    }\n                    else if (event.name == "button_press")\n                    {\n                        data.set ("ec",  "button_press");\n                        data.set ("ea",  event.parameters["id"]);\n                    }\n                    else if (event.name == "crash")\n                    {\n                        data.set ("ec",  "crash");\n                        data.set ("ea",  "crash");\n                    }\n                    else\n                    {\n                        jassertfalse;\n                        continue;\n                    }\n \n                    break;\n                }\n \n                default:\n                {\n                    // Unknown event type! In this demo app we\'re just using a\n                    // single event type, but in a real app you probably want to\n                    // handle multiple ones.\n                    jassertfalse;\n                    break;\n                }\n            }\n \n            data.set ("cid", event.userID);                                 // [3]\n \n            juce::StringArray eventData;\n \n            for (auto& key : data.getAllKeys())                             // [4]\n                eventData.add (key + "=" + juce::URL::addEscapeChars (data[key], true));\n \n            postData.add (appData + "&" + eventData.joinIntoString ("&"));  // [5]\n        }\n \n        auto url = juce::URL ("https://www.google-analytics.com/batch")\n                       .withPOSTData (postData.joinIntoString ("\\n"));      // [6]\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"[1]: We start by adding the version number, anonymised IP and tracking ID to the appData string variable."}),"\n",(0,s.jsxs)(t.li,{children:['[2]: Then for each event in the batch, we determine the type of event in question to set its category and action properties. If the event is a startup or a shutdown, we set the event category to "info" and set the action property to "appStarted" or "appStopped" respectively. If the event is a button pressing, we set the event category to "button_press" and retrieve its action property from the id parameter of the ',(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classButtonTracker",title:"A class that automatically sends analytics events to the Analytics singleton when a button is clicked...",children:"ButtonTracker"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"[3]: We also set the user ID for the event to log."}),"\n",(0,s.jsxs)(t.li,{children:["[4]: Now for all the individual ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classStringPairArray",title:"A container for holding a set of strings which are keyed by another string.",children:"StringPairArray"})," entries, we concatenate keys with their corresponding values by inserting an equal sign in between and escaping any special characters from the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classURL",title:"Represents a URL and has a bunch of useful functions to manipulate it.",children:"URL"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"[5]: Finally, we can join all the event parameters together with ampersand signs in between and by prepending the initial appData content to the front."}),"\n",(0,s.jsxs)(t.li,{children:["[6]: The ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classURL",title:"Represents a URL and has a bunch of useful functions to manipulate it.",children:"URL"})," is eventually constructed with its POST data appended line by line. This way we can send multiple events in a single HTTP request."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Modify the code above to handle all event properties including label and value attributes."}),"\n",(0,s.jsxs)(t.p,{children:["Now that we have our ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classURL",title:"Represents a URL and has a bunch of useful functions to manipulate it.",children:"URL"})," ready we need to send the request to the server by creating a ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classWebInputStream",title:"An InputStream which can be used to read from a given URL.",children:"WebInputStream"}),". We first have to lock the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classCriticalSection",title:"A re-entrant mutex.",children:"CriticalSection"})," mutex declared as a member variable called webStreamCreation. Using a ScopedLock object allows us to automatically lock and unlock the mutex for the piece of code delimited by the curly brackets [1]."]}),"\n",(0,s.jsxs)(t.p,{children:["If the ",(0,s.jsx)(t.code,{children:"stopLoggingEvents()"})," function was previously called due to the application terminating, we return immediately without attempting to initialise the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classWebInputStream",title:"An InputStream which can be used to read from a given URL.",children:"WebInputStream"})," [2]. Otherwise, we can create it in a std::unique_ptr by passing the previously constructed ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classURL",title:"Represents a URL and has a bunch of useful functions to manipulate it.",children:"URL"})," as an argument and using POST as the method [3]."]}),"\n",(0,s.jsxs)(t.p,{children:["We can then connect to the specified ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classURL",title:"Represents a URL and has a bunch of useful functions to manipulate it.",children:"URL"})," and perform the request using the ",(0,s.jsx)(t.code,{children:"connect()"})," function on the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classWebInputStream",title:"An InputStream which can be used to read from a given URL.",children:"WebInputStream"})," [4]. If the response is successful, we just return positively from the function. Otherwise, we set an exponential decay on the batch period by multiplying the previous rate by 2 and return negatively from the function [5]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:" \n        {\n            const juce::ScopedLock lock (webStreamCreation);        // [1]\n \n            if (shouldExit)                                         // [2]\n                return false;\n \n            webStream.reset (new juce::WebInputStream (url, true)); // [3]\n        }\n \n        auto success = webStream->connect (nullptr);                // [4]\n \n        // Do an exponential backoff if we failed to connect.\n        if (success)\n            periodMs = initialPeriodMs;\n        else\n            periodMs *= 2;\n \n        setBatchPeriod (periodMs);                                  // [5]\n \n        return success;\n    }\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When the application shuts down, we need to cancel connections to the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classWebInputStream",title:"An InputStream which can be used to read from a given URL.",children:"WebInputStream"})," if there are any that are concurrently running. By first acquiring the lock from the same ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classCriticalSection",title:"A re-entrant mutex.",children:"CriticalSection"})," object using a ScopedLock, we ensure that the previously encountered critical section of the code in the ",(0,s.jsx)(t.code,{children:"logBatchedEvents()"})," function will have terminated before [1]. Setting the shouldExit boolean to true prevents any new connections from being created subsequently [2]. Then we can finally cancel any ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classWebInputStream",title:"An InputStream which can be used to read from a given URL.",children:"WebInputStream"})," connections using the ",(0,s.jsx)(t.code,{children:"cancel()"})," function if there are any [3]."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"    void stopLoggingEvents() override\n    {\n        const juce::ScopedLock lock (webStreamCreation);            // [1]\n \n        shouldExit = true;                                          // [2]\n \n        if (webStream.get() != nullptr)                             // [3]\n            webStream->cancel();\n    }\n"})}),"\n",(0,s.jsx)(t.p,{children:"This completes the part of the tutorial dealing with logging events. However, if the transmission of event data fails and the application terminates, we currently have no way of keeping track of unlogged events."}),"\n",(0,s.jsx)(t.h1,{id:"save-and-restore-unlogged-events",children:"Save and restore unlogged events"}),"\n",(0,s.jsx)(t.p,{children:"This section will cover the use of XML files to store any unlogged events to disk in the case of a lost connection."}),"\n",(0,s.jsx)(t.p,{children:"The XML document storing unlogged event information will look something like this for a single button press:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\n                                                                                              // Root XML element for the whole document.\n     // Event node with name, type, timestamp and user ID.\n                                                                      // Parameters related to the parent event.\n                                                      // Properties for the user in the parent event.\n    \n    //...\n\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We will look at the ",(0,s.jsx)(t.code,{children:"saveUnloggedEvents()"})," and ",(0,s.jsx)(t.code,{children:"restoreUnloggedEvents()"})," functions that deal with saving and restoring events respectively. The ",(0,s.jsx)(t.code,{children:"saveUnloggedEvents()"})," function will build an XML structure based on the format shown above and save the content in an XML file:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    void saveUnloggedEvents (const std::deque& eventsToSave) override\n    {\n        // Save unsent events to disk. Here we use XML as a serialisation format, but\n        // you can use anything else as long as the restoreUnloggedEvents method can\n        // restore events from disk. If you\'re saving very large numbers of events then\n        // a binary format may be more suitable if it is faster - remember that this\n        // method is called on app shutdown so it needs to complete quickly!\n \n        juce::XmlDocument previouslySavedEvents (savedEventsFile);\n        std::unique_ptr xml (previouslySavedEvents.getDocumentElement()); // [1]\n \n        if (xml.get() == nullptr || xml->getTagName() != "events")                          // [2]\n            xml.reset (new juce::XmlElement ("events"));\n \n        for (auto& event : eventsToSave)\n        {\n            auto* xmlEvent = new juce::XmlElement ("google_analytics_event");               // [3]\n            xmlEvent->setAttribute ("name", event.name);\n            xmlEvent->setAttribute ("type", event.eventType);\n            xmlEvent->setAttribute ("timestamp", (int) event.timestamp);\n            xmlEvent->setAttribute ("user_id", event.userID);\n \n            auto* parameters = new juce::XmlElement ("parameters");                         // [4]\n \n            for (auto& key : event.parameters.getAllKeys())\n                parameters->setAttribute (key, event.parameters[key]);\n \n            xmlEvent->addChildElement (parameters);\n \n            auto* userProperties = new juce::XmlElement ("user_properties");                // [5]\n \n            for (auto& key : event.userProperties.getAllKeys())\n                userProperties->setAttribute (key, event.userProperties[key]);\n \n            xmlEvent->addChildElement (userProperties);\n \n            xml->addChildElement (xmlEvent);                                                // [6]\n        }\n \n        xml->writeTo (savedEventsFile);                                                     // [7]\n    }\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["[1]: First we retrieve any previously saved events from the XML file stored at the previously defined file location and build an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classXmlElement",title:"Used to build a tree of elements representing an XML document.",children:"XmlElement"})," based on it."]}),"\n",(0,s.jsxs)(t.li,{children:["[2]: If the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classXmlElement",title:"Used to build a tree of elements representing an XML document.",children:"XmlElement"}),' does not exist or does not have the root "events" node, we create it.']}),"\n",(0,s.jsx)(t.li,{children:'[3]: For each unsaved event in the queue, we create a "google_analytics_event" node with the event name, type, timestamp and user ID as attributes.'}),"\n",(0,s.jsx)(t.li,{children:'[4]: We also create a "parameters" node as a child node to the previously created one with event parameters as attributes to it.'}),"\n",(0,s.jsx)(t.li,{children:'[5]: At the same hierarchy level, we create a "user_properties" node as a child node with user properties as attributes to it.'}),"\n",(0,s.jsx)(t.li,{children:'[6]: We can then add the individual event nodes as children to the root "events" node.'}),"\n",(0,s.jsx)(t.li,{children:"[7]: Finally, we write the XML structure to the XML file and store the events."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["On the other hand, the ",(0,s.jsx)(t.code,{children:"restoreUnloggedEvents()"})," function will in turn read an XML structure based on the same format shown previously and fill up the event queue:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    void restoreUnloggedEvents (std::deque& restoredEventQueue) override\n    {\n        juce::XmlDocument savedEvents (savedEventsFile);\n        std::unique_ptr xml (savedEvents.getDocumentElement());           // [1]\n \n        if (xml.get() == nullptr || xml->getTagName() != "events")                          // [2]\n            return;\n \n        auto numEvents = xml->getNumChildElements();\n \n        for (auto iEvent = 0; iEvent < numEvents; ++iEvent)\n        {\n            auto* xmlEvent = xml->getChildElement (iEvent);                                 // [3]\n \n            juce::StringPairArray parameters;\n            auto* xmlParameters = xmlEvent->getChildByName ("parameters");                  // [4]\n            auto numParameters = xmlParameters->getNumAttributes();\n \n            for (auto iParam = 0; iParam < numParameters; ++iParam)\n                parameters.set (xmlParameters->getAttributeName (iParam),\n                                xmlParameters->getAttributeValue (iParam));\n \n            juce::StringPairArray userProperties;\n            auto* xmlUserProperties = xmlEvent->getChildByName ("user_properties");         // [5]\n            auto numUserProperties = xmlUserProperties->getNumAttributes();\n \n            for (auto iProp = 0; iProp < numUserProperties; ++iProp)\n                userProperties.set (xmlUserProperties->getAttributeName (iProp),\n                                    xmlUserProperties->getAttributeValue (iProp));\n \n            restoredEventQueue.push_back ({\n                xmlEvent->getStringAttribute ("name"),                                      // [6]\n                xmlEvent->getIntAttribute ("type"),\n                static_cast (xmlEvent->getIntAttribute ("timestamp")),\n                parameters,\n                xmlEvent->getStringAttribute ("user_id"),\n                userProperties\n            });\n        }\n \n        savedEventsFile.deleteFile();                                                       // [7]\n    }\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["[1]: Same as before, we retrieve any previously saved events from the XML file stored at the previously defined file location and build an ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classXmlElement",title:"Used to build a tree of elements representing an XML document.",children:"XmlElement"})," based on it."]}),"\n",(0,s.jsxs)(t.li,{children:["[2]: If the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classXmlElement",title:"Used to build a tree of elements representing an XML document.",children:"XmlElement"}),' does not exist or does not have the root "events" node, we return from the function as there is nothing to do.']}),"\n",(0,s.jsx)(t.li,{children:"[3]: We first retrieve a single event child node to parse from the root parent."}),"\n",(0,s.jsxs)(t.li,{children:['[4]: For each attribute from the child "parameters" node, we set a key/value pair and add it to a ',(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classStringPairArray",title:"A container for holding a set of strings which are keyed by another string.",children:"StringPairArray"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:['[5]: For each attribute from the child "user_properties" node, we set a key/value pair and add it to a ',(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classStringPairArray",title:"A container for holding a set of strings which are keyed by another string.",children:"StringPairArray"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["[6]: We can then push the individual events back into the event queue by setting the corresponding parameters from the ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classStringPairArray",title:"A container for holding a set of strings which are keyed by another string.",children:"StringPairArray"})," objects."]}),"\n",(0,s.jsx)(t.li,{children:"[7]: Finally, we delete the XML file from disk when done."}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"We used XML as a serialisation format but if we need to save large amounts of unsaved events, a binary format would be more efficient."})}),"\n",(0,s.jsxs)(t.p,{children:["Save and restore unlogged events in a different serialisation format such as ",(0,s.jsx)(t.a,{href:"https://docs.juce.com/master/classJSON",title:"Contains static methods for converting JSON-formatted text to and from var objects.",children:"JSON"})," or in a binary format."]}),"\n",(0,s.jsx)(t.h1,{id:"\u6982\u8981",children:"\u6982\u8981"}),"\n",(0,s.jsx)(t.p,{children:"In this tutorial, we have learnt how to track usage data with Google Analytics and the JUCE analytics module. In particular, we have:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Sent analytics events to Google Analytics on a separate thread."}),"\n",(0,s.jsx)(t.li,{children:"Stored unsent events locally in an XML document."}),"\n",(0,s.jsx)(t.li,{children:"Restored saved events from the XML document to the event queue."}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"\u95a2\u9023\u9805\u76ee",children:"\u95a2\u9023\u9805\u76ee"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_android_studio/",children:"Tutorial: Getting started with Android"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_android_screen_sizes/",children:"Tutorial: Managing Android screen sizes"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_in_app_purchases/",children:"Tutorial: In-App Purchases on desktop and mobile devices"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_push_notifications/",children:"Tutorial: Push Notifications on desktop and mobile devices"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"../tutorial_app_plugin_packaging/",children:"Tutorial: Package your app or plugin for distribution"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function u(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);