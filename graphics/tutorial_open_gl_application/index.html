<!doctype html>
<html lang="ja" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-graphics/tutorial_open_gl_application" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">OpenGLアプリケーションのビルド | JUCE日本語版チュートリアル</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://m1m0zzz.github.io/juce-tutorial-ja/img/juce-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://m1m0zzz.github.io/juce-tutorial-ja/img/juce-social-card.jpg"><meta data-rh="true" property="og:url" content="https://m1m0zzz.github.io/juce-tutorial-ja/graphics/tutorial_open_gl_application/"><meta data-rh="true" property="og:locale" content="ja"><meta data-rh="true" name="docusaurus_locale" content="ja"><meta data-rh="true" name="docsearch:language" content="ja"><meta data-rh="true" name="keywords" content="JUCE, plugin, VST, 日本語, チュートリアル"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="OpenGLアプリケーションのビルド | JUCE日本語版チュートリアル"><meta data-rh="true" name="description" content="JUCEアプリケーションの高性能レンダリングライブラリとしてOpenGLを使い始める方法をご紹介します。オーディオアプリケーションやプラグインで、美しい2Dや3Dのグラフィックスをレンダリングします。"><meta data-rh="true" property="og:description" content="JUCEアプリケーションの高性能レンダリングライブラリとしてOpenGLを使い始める方法をご紹介します。オーディオアプリケーションやプラグインで、美しい2Dや3Dのグラフィックスをレンダリングします。"><link data-rh="true" rel="icon" href="/juce-tutorial-ja/img/juce.png"><link data-rh="true" rel="canonical" href="https://m1m0zzz.github.io/juce-tutorial-ja/graphics/tutorial_open_gl_application/"><link data-rh="true" rel="alternate" href="https://m1m0zzz.github.io/juce-tutorial-ja/graphics/tutorial_open_gl_application/" hreflang="ja"><link data-rh="true" rel="alternate" href="https://m1m0zzz.github.io/juce-tutorial-ja/graphics/tutorial_open_gl_application/" hreflang="x-default"><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1662Y26YFC"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1662Y26YFC",{anonymize_ip:!0})</script><link rel="stylesheet" href="/juce-tutorial-ja/assets/css/styles.e1cde857.css">
<script src="/juce-tutorial-ja/assets/js/runtime~main.d87bbea4.js" defer="defer"></script>
<script src="/juce-tutorial-ja/assets/js/main.ffd66bad.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="メインコンテンツまでスキップ"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">メインコンテンツまでスキップ</a></div><nav aria-label="ナビゲーション" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="ナビゲーションバーを開く" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/juce-tutorial-ja/"><div class="navbar__logo"><img src="/juce-tutorial-ja/img/juce.png" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/juce-tutorial-ja/img/juce.png" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">JUCE日本語版チュートリアル</b></a><a class="navbar__item navbar__link" href="/juce-tutorial-ja/tags/初級/">tag:初級</a><a class="navbar__item navbar__link" href="/juce-tutorial-ja/tags/中級/">tag:中級</a><a class="navbar__item navbar__link" href="/juce-tutorial-ja/tags/上級/">tag:上級</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/m1m0zzz/juce-tutorial-ja" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="ダークモードを切り替える(現在はライトモード)" aria-label="ダークモードを切り替える(現在はライトモード)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="先頭へ戻る" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="ドキュメントのサイドバー" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/juce-tutorial-ja/">About / このサイトについて</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/getting-started/">Getting Started</a><button aria-label="&#x27;Getting Started&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/audio/">Audio</a><button aria-label="&#x27;Audio&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/synth/">Synth</a><button aria-label="&#x27;Synth&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/midi/">MIDI</a><button aria-label="&#x27;MIDI&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/plugins/">Plugins</a><button aria-label="&#x27;Plugins&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/dsp/">DSP</a><button aria-label="&#x27;DSP&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/juce-tutorial-ja/category/graphics/">Graphics</a><button aria-label="&#x27;Graphics&#x27;の目次を隠す" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/juce-tutorial-ja/graphics/tutorial_main_window/">アプリケーションウィンドウ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/juce-tutorial-ja/graphics/tutorial_main_component/">メインコンポーネント</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/juce-tutorial-ja/graphics/tutorial_graphics_class/">Graphics クラス</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/juce-tutorial-ja/graphics/tutorial_animation/">ジオメトリのアニメーション</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/juce-tutorial-ja/graphics/tutorial_open_gl_application/">OpenGLアプリケーションのビルド</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/interface-design/">Interface Design</a><button aria-label="&#x27;Interface Design&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/mobile/">Mobile</a><button aria-label="&#x27;Mobile&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/juce-tutorial-ja/category/utility-classes/">Utility Classes</a><button aria-label="&#x27;Utility Classes&#x27;の目次を開く" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="パンくずリストのナビゲーション"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="ホームページ" class="breadcrumbs__link" href="/juce-tutorial-ja/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/juce-tutorial-ja/category/graphics/"><span itemprop="name">Graphics</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">OpenGLアプリケーションのビルド</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">このページの見出し</button></div><div class="theme-doc-markdown markdown"><header><h1>チュートリアルOpenGLアプリケーションのビルド</h1></header>
<p>JUCEアプリケーションの高性能レンダリングライブラリとしてOpenGLを使い始める方法をご紹介します。オーディオアプリケーションやプラグインで、美しい2Dや3Dのグラフィックスをレンダリングします。</p>
<p>レベル：上級</p>
<p>プラットフォーム：Windows, macOS, Linux, iOS, Android</p>
<p>クラス： <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a>, <a href="https://docs.juce.com/master/classOpenGLContext" target="_blank" rel="noopener noreferrer" title="Creates an OpenGL context, which can be attached to a component.">OpenGLContext</a>, <a href="https://docs.juce.com/master/classOpenGLShaderProgram" target="_blank" rel="noopener noreferrer" title="Manages an OpenGL shader program.">OpenGLShaderProgramme</a>, <a href="https://docs.juce.com/master/classOpenGLHelpers" target="_blank" rel="noopener noreferrer" title="A set of miscellaneous openGL helper functions.">OpenGLHelpers</a>, <a href="https://docs.juce.com/master/classMatrix3D" target="_blank" rel="noopener noreferrer" title="A 4x4 3D transformation matrix.">マトリックス3D</a>, <a href="https://docs.juce.com/master/classVector3D" target="_blank" rel="noopener noreferrer" title="A three-coordinate vector.">ベクター3D</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="はじめる">はじめる<a href="#はじめる" class="hash-link" aria-label="はじめる への直接リンク" title="はじめる への直接リンク">​</a></h2>
<p>This tutorial assumes basic understanding of the OpenGL graphics library. If you are not familiar with <a href="https://en.wikipedia.org/wiki/OpenGL" target="_blank" rel="noopener noreferrer">オープンGL</a>, you should read about it first <a href="https://www.opengl.org" target="_blank" rel="noopener noreferrer">これ</a>.</p>
<p>Download the demo project for this tutorial here: <a href="/juce-tutorial-ja/tutorials/PIPs/OpenGLAppTutorial.zip/">ピップ</a> | <a href="/juce-tutorial-ja/tutorials/ZIPs/OpenGLAppTutorial.zip/">ジップ</a>. Unzip the project and open the first header file in the Projucer.</p>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_BuS1"><p>If using the PIP version of this project, please make sure to copy the <code>リソース</code> folder into the generated Projucer project.</p></div></div>
<p>If you need help with this step, see <a href="/juce-tutorial-ja/graphics/tutorial_new_projucer_project/">チュートリアルProjucerパート1：Projucerを始める</a>.</p>
<h1>The demo project</h1>
<p>デモ・プロジェクトは、以下のスクリーンショットのように、Wavefrontの&quot;.obj &quot;ファイルを解析して、標準的なOpenGLティーポット・オブジェクトを3Dグラフィックスで表示します：</p>
<figure><img src="https://docs.juce.com/master/tutorial_open_gl_application_screenshot1.png" alt="The demo project app window"><figcaption><b>The demo project app window</b></figcaption></figure>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>注記</div><div class="admonitionContent_BuS1"><p>The code presented here is broadly similar to the <strong>OpenGLAppExample</strong> from the JUCE Examples.</p></div></div>
<h1>Anatomy of an OpenGL app</h1>
<p>OpenGL APIは、多くの異なるプラットフォームやビルド環境で動作する強力で汎用性の高いライブラリですが、3Dレンダリングに関する原則は、すべてのアプリケーションで類似しています。ここで説明する用語のいくつかは、OpenGLがどのようにレンダリングルーチンを実行するかを理解するための基本的なものです：</p>
<ul>
<li>GLコンテキスト：コンテキストは初期化段階で一度設定され、プラットフォーム固有の方法でグラフィックスレンダラーのGL設定を記述し、アプリケーション内で使用するために必要なOpenGL関数がロードされる。</li>
<li>投影マトリックス：投影行列によって、3Dオブジェクトを2D平面に変換し、シーンをスクリーンにレンダリングすることができる。</li>
<li>ビュー行列：ビューマトリックスによって、3D環境で幾何学的な変換を行い、オブジェクトをシーン内に配置することができる。</li>
<li>シェーダー：オブジェクトの外観をカスタマイズするために、シェーダーを使用して、表面の光沢や反射、3Dオブジェクト上の光や影の見え方など、マテリアル の特性を記述します。</li>
<li>頂点：シーン内でレンダリングしようとしている3Dオブジェクトを定義する3Dポイントを表します。頂点シェーダーで使用されます。</li>
<li>フラグメント：補間によって頂点と頂点の間に存在するピクセルを表す。フラグメントシェーダやピクセルシェーダで使用されます。</li>
<li>属性：シェーダ言語で使用される色やテクスチャ座標などの頂点パラメータを記述する。</li>
<li>ユニフォーム：シェーダ言語で使用されるが、シェーダプログラム間で不変であるグローバルパラメータを記述する。</li>
<li>変数：頂点シェーダプログラムとフラグメントシェーダプログラムの間で共有されるパラメータを記述します。</li>
<li>シェイプ：アプリケーションで最終的にレンダリングしたいポリゴンをカプセル化します。この場合はティーポットです。</li>
</ul>
<h1>The OpenGL Shading Language</h1>
<p>OpenGLシェーディング言語またはGLSLは、複数のオペレーティング・システムやハードウェア・グラフィックス・カード上のグラフィックス・レンダリング・パイプラインを直接制御できるCタイプの言語です。GLSLを使用すると、オブジェクトの外観を記述するシェーダーと呼ばれる小さなプログラムを書くことができます。OpenGLを使うか、スマートフォンやタブレットのような組み込みシステム専用に設計されたサブセット・ライブラリOpenGL ESを使うかによって、言語構文は変わりませんが、パフォーマンスを考慮する必要があります。</p>
<p>例として、このチュートリアルで使用する頂点シェーダーは次のようになります：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// OpenGLおよびOpenGL ES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">属性 vec4 position；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">属性 vec4 sourceColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">属性 vec2 textureCoordIn；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">一様な mat4 projectionMatrix；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">一様な mat4 viewMatrix；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">変化する vec4 destinationColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">変化する vec2 textureCoordOut；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    destinationColour = sourceColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    textureCoordOut = textureCoordIn；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gl_Position = projectionMatrix * viewMatrix * position；</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>そして、このチュートリアルで使用するフラグメント・シェーダーは以下のようになる：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// OpenGL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">変化する vec4 destinationColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">変化するvec2 textureCoordOut；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec4 color = vec4(0.95, 0.57, 0.03, 0.7)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gl_FragColor = color；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// OpenGL ES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">変化するlowp vec4 destinationColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可変lowp vec2 textureCoordOut；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lowp vec4 color = vec4(0.95, 0.57, 0.03, 0.7)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gl_FragColor = color；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>ご覧の通り、シェーダーは非常に些細なもので、OpenGLシェーダーとOpenGL ESシェーダーの違いはごくわずかです。ここで使われているGLSLの型、変数、関数は以下の通りです：</p>
<ul>
<li><code>VEC2/VEC4</code>: Represents a floating point vector with 2 or 4 components.</li>
<li><code>マット4</code>: Represents a 4-by-4 floating point matrix.</li>
<li><code>ロープ</code>: Specifies a lower precision data type for OpenGL ES.</li>
<li><code>属性</code>: Represents a vertex-specific parameter.</li>
<li><code>ユニフォーム</code>: Represents a global parameter describing the GL environment.</li>
<li><code>まちまち</code>: Represents a shared parameter between the vertex and fragment shaders.</li>
<li><code>gl_ポジション</code>: The transformed vertex position for the vertex shader to execute vertex manipulations.</li>
<li><code>gl_フラグカラー</code>: The colour for the fragment shader to execute fragment manipulations.</li>
<li><code>メイン()</code>: The main function is where the vertex or fragment shader computation is performed.</li>
</ul>
<h1>The OpenGLAppComponent class</h1>
<p>In JUCE, the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a> class is very similar to the <a href="https://docs.juce.com/master/classAudioAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing audio apps that stream from the audio i/o devices.">オーディオコンポーネント</a> class but instead it is used for graphical apps. When inheriting from the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a> class, there are several functions that we have to override namely:</p>
<ul>
<li>initialise()を使用します：この関数は、シェーダーなどのレンダリングに必要なGLオブジェクトを準備します。</li>
<li>render()を呼び出します：render関数はOpenGLレンダラーによって呼び出され、ここでOpenGLコンテキストを描画するための投影行列とビュー行列が計算される。</li>
<li>shutdown()：この関数は、シェーダーなどのレンダリングに使用されたGLオブジェクトをクリアします。</li>
<li>shutdownOpenGL()：サブクラスのデストラクタで、クラスが破壊される前にGLシステムをシャットダウンするために、この関数を呼び出す必要があります。</li>
</ul>
<p>OpenGLの基本を学んだところで、ティーポットのレンダリングを実装してみよう！</p>
<h1>Calculating the Projection and View matrices</h1>
<p>投影行列とビュー行列の計算を切り離すために、これらの行列を後で使えるように返す2つのヘルパー関数を作成する。</p>
<p>まず、以下のようにフラストラムとスクリーン境界を使って投影行列を計算する：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    juce::Matrix3D getProjectionMatrix() const</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auto w = 1.0f / (0.5f + 0.1f);                                          // [1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auto h = w * getLocalBounds().toFloat().getAspectRatio (false);         // [2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return juce::Matrix3D::fromFrustum (-w, w, -h, h, 4.0f, 30.0f); // [3].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>A frustum is a shape cutout from a polygon by slicing it with two parallel planes and the <a href="https://docs.juce.com/master/classMatrix3D" target="_blank" rel="noopener noreferrer" title="A 4x4 3D transformation matrix.">マトリックス3D</a> class provides a handy function called <code>fromFrustum()</code> that returns a matrix from one. In the function above:</p>
<ul>
<li>[1]: We first declare a width variable to define half the width of the frustum on the near plane with an arbitrary number that works well for our scenario.</li>
<li>[2]: Then we declare a height variable to define half the height of the frustum on the near plane based on the screen ratio and the width variable.</li>
<li>[3]: We finally use the <code>fromFrustum()</code> function with width, height, near plane and far plane distances as arguments to retrieve the projection matrix. This gives us a perspective projection as opposed to an orthographic projection.</li>
</ul>
<p>次に、回転行列を使ってビュー行列を計算し、下図のようにティーポットをアニメーション化します：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    juce::Matrix3D getViewMatrix() const</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auto viewMatrix = juce::Matrix3D::fromTranslation ({ 0.0f, 0.0f, -10.0f }); // [4].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auto rotationMatrix = viewMatrix.rotation ({ -0.3f、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                      5.0f * std::sin ((float) getFrameCounter() * 0.01f)、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                      0.0f }); // [5]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return viewMatrix * rotationMatrix; // [6].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>[4]: First we create an identity matrix translated by a vector to push the matrix 10 units back into the scene. This puts our teapot right at the center of the screen but a little bit far off.</li>
<li>[5]: We then create a rotation matrix from the previously defined matrix that rotates the teapot around the y-axis depending on the rendering frame counter. This will also make the rotation change direction back and forth at the rate of the sin function.</li>
<li>[6]: Finally we apply the rotation by multiplaying the matrices and return the view matrix.</li>
</ul>
<p>数学的計算部分は完了したので、次にシェーダープログラムを書き始めることができる。</p>
<h1>Writing the OpenGL shaders</h1>
<p>まず、チュートリアルのコード・ベース全体で使用する便利なメンバ変数を定義することから始めましょう：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    juce::String vertexShader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    juce::String fragmentShader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::unique_ptr shader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::unique_ptr shape;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::unique_ptr attributes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::unique_ptrユニフォーム</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Here we have defined several pointers to the shape, attributes and uniforms we will be using in this GL context as well as an <a href="https://docs.juce.com/master/classOpenGLShaderProgram" target="_blank" rel="noopener noreferrer" title="Manages an OpenGL shader program.">OpenGLShaderProgramme</a> object that manages the shader program. We also have two char pointers to define the vertex shader and fragment shader as shown in the next step:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void createShaders()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        頂点シェーダ = R&quot;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            属性 vec4 position；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            属性 vec4 sourceColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            属性 vec2 textureCoordIn；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            一様な mat4 projectionMatrix；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            一様な mat4 viewMatrix；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            変化する vec4 destinationColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            変化する vec2 textureCoordOut；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                destinationColour = sourceColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                textureCoordOut = textureCoordIn；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                gl_Position = projectionMatrix * viewMatrix * position；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        フラグメントシェーダ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           #if JUCE_OPENGL_ES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            R&quot;(varying lowp vec4 destinationColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               変化する lowp vec2 textureCoordOut;)&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           #それ以降</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            R&quot;(varying vec4 destinationColour；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               vec2 textureCoordOutを変化させる;)&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           #endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            R&quot;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               {)&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           #if JUCE_OPENGL_ES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            R&quot;( lowp vec4 color = vec4(0.95, 0.57, 0.03, 0.7);)&quot; &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           #else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            R&quot;( vec4 color = vec4(0.95, 0.57, 0.03, 0.7);)&quot; #endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           #endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            R&quot;( gl_FragColor = color；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               })&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>In the <code>createShaders()</code> function, we first copy the previously shown shaders into the char pointers by inserting line breaks. This function will be later called in the <code>イニシャライズ()</code> function of the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a>. The vertex shader essentially sets the position of every vertex in the shape by setting the &quot;gl_Position&quot; variable to the product of the transformation matrices namely the projection matrix followed by the view matrix. As for the fragment shader, the colour of the pixel is specified by setting the &quot;gl_FragColor&quot; variable to the specified colour.</p>
<p>In the second half of the <code>createShaders()</code> function, we create a new shader program within the current GL context [1] and perform some initialisation as follows:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        std::unique_ptrnewShader (new juce::OpenGLShaderProgram (openGLContext)); // [1].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        juce::String statusText；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (newShader-&gt;addVertexShader (juce::OpenGLHelpers::translateVertexShaderToV3 (vertexShader)))          // [2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              &amp;&amp; newShader-&gt;addFragmentShader (juce::OpenGLHelpers::translateFragmentShaderToV3 (fragmentShader))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              &amp;&amp; newShader-&gt;link())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            shape .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            attribute .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ユニフォーム .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            shader.reset (newShader.release()); // [3].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            shader-&gt;use()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            shape .reset (new Shape())；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            attributes .reset (new Attributes (*shader))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            uniforms .reset (new Uniforms (*shader))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            statusText = &quot;GLSL: v&quot;+ juce::String (juce::OpenGLShaderProgram::getLanguageVersion(), 2)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            statusText = newShader-&gt;getLastError(); // [4].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>[2]: We first add the vertex shader followed by the fragment shader and attempt to link the compiled shaders into a single program.</li>
<li>[3]: If the compilation and linking of the shaders are successful, we can clear the shape, attributes and uniforms pointers, assign the newly created shader to the shader program pointer and instantiate new objects for the shape, attributes and uniforms pointers.</li>
<li>[4]: We can optionally keep track of the initialisation status in case the compilation of shaders fails.</li>
</ul>
<p>では、頂点、アトリビュート、ユニフォーム、シェイプを表す便利な構造を定義してみよう。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-vertex-struct">The Vertex struct<a href="#the-vertex-struct" class="hash-link" aria-label="The Vertex struct への直接リンク" title="The Vertex struct への直接リンク">​</a></h2>
<p>頂点を表現するためには、以下のように4つの重要な変数が必要である：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">頂点構造</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float position[3]；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float normal[3]；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float color[4]；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float texCoord[2]；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>位置：位置の配列は、3D局所空間における頂点の位置を表します。</li>
<li>法線：法線配列は、隣接する面の法線から計算された当該頂点の法線ベクトルの方向を表す。</li>
<li>色：色の配列は頂点の色を RGBA フォーマットで表します。</li>
<li>テクスチャ座標：テクスチャを使用する場合、その頂点で使用するテクスチャの2D座標を表します。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-attributes-struct">The Attributes struct<a href="#the-attributes-struct" class="hash-link" aria-label="The Attributes struct への直接リンク" title="The Attributes struct への直接リンク">​</a></h2>
<p>The attributes structure is essentially a container class to hold several <a href="https://docs.juce.com/master/structOpenGLShaderProgram_1_1Attribute" target="_blank" rel="noopener noreferrer" title="Represents an openGL vertex attribute value.">OpenGLShaderProgram::属性</a> objects together and the attributes we store are defined here:</p>
<p>アトリビュートは頂点シェーダプログラムの頂点パラメータを記述するためのものなので、これらは先に定義したVertex構造体の変数に正確に対応しています。</p>
<p>予想通り、次のステップで定義したプライベート・ヘルパー関数を呼び出し、引数としてシェーダープログラムを渡すことで、コンストラクタ内でこれらのアトリビュートを作成する：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">明示的属性 (juce::OpenGLShaderProgram&amp; shaderProgram)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            position .reset (createAttribute (shaderProgram, &quot;position&quot;))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            normal .reset (createAttribute (shaderProgram, &quot;normal&quot;))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sourceColour .reset（createAttribute（shaderProgram, &quot;sourceColour&quot;））；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            textureCoordIn .reset (createAttribute (shaderProgram, &quot;textureCoordIn&quot;))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The helper function in turn will call the <a href="https://docs.juce.com/master/structOpenGLShaderProgram_1_1Attribute" target="_blank" rel="noopener noreferrer" title="Represents an openGL vertex attribute value.">OpenGLShaderProgram::属性</a> constructor to instantiate new objects:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static juce::OpenGLShaderProgram::Attribute* createAttribute (juce::OpenGLShaderProgram&amp; shader、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                      const juce::String&amp; attributeName)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (glGetAttribLocation (shader.getProgramID(), attributeName.toRawUTF8()) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nullptr を返す；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new juce::OpenGLShaderProgram::Attribute (shader, attributeName.toRawUTF8())；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>However, in the above we first check whether the attribute exists in the shader program by using the <code>glGetAttribLocation()</code> function. If the number returned is -1 then we abort the attribute instantiation.</p>
<p>In the <code>イネーブル()</code> function, all the attributes are activated (after checking if they exist) by calling the <code>glVertexAttribPointer()</code> and <code>glEnableVertexAttribArray()</code> functions as shown below:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void enable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (position.get() != nullptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glVertexAttribPointer (position-&gt;attributeID, 3, GL_FLOAT, GL_FALSE, sizeof (Vertex), nullptr)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glEnableVertexAttribArray (position-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (normal.get() != nullptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glVertexAttribPointer (normal-&gt;attributeID, 3, GL_FLOAT, GL_FALSE, sizeof (Vertex), (GLvoid*) (sizeof (float) * 3))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glEnableVertexAttribArray (normal-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sourceColour.get() != nullptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glVertexAttribPointer (sourceColour-&gt;attributeID, 4, GL_FLOAT, GL_FALSE, sizeof (Vertex), (GLvoid*) (sizeof (float) * 6))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glEnableVertexAttribArray (sourceColour-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (textureCoordIn.get() != nullptr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glVertexAttribPointer (textureCoordIn-&gt;attributeID, 2, GL_FLOAT, GL_FALSE, sizeof (Vertex), (GLvoid*) (sizeof (float) * 10))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glEnableVertexAttribArray (textureCoordIn-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The <code>glVertexAttribPointer()</code> function defines the array of vertex attribute data with information such as the index, size and type of data to hold. Notice that the last argument specifies the offset of the data cumulatively with regards to the other attributes defined previously in the structure. Then the <code>glEnableVertexAttribArray()</code> function enables the actual array to be used within the context.</p>
<p>In the <code>無効化()</code> function, we do the exact opposite by calling the <code>glDisableVertexAttribArray()</code> function on all attributes:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">無効化()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (position.get() != nullptr) glDisableVertexAttribArray (position-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (normal.get() != nullptr) glDisableVertexAttribArray (normal-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sourceColour.get() != nullptr) glDisableVertexAttribArray (sourceColour-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (textureCoordIn.get() != nullptr) glDisableVertexAttribArray (textureCoordIn-&gt;attributeID)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-uniforms-struct">The Uniforms struct<a href="#the-uniforms-struct" class="hash-link" aria-label="The Uniforms struct への直接リンク" title="The Uniforms struct への直接リンク">​</a></h2>
<p>The uniforms structure similarly contains several <a href="https://docs.juce.com/master/structOpenGLShaderProgram_1_1Uniform" target="_blank" rel="noopener noreferrer" title="Represents an openGL uniform value.">OpenGLShaderProgram::ユニフォーム</a> objects in the same manner as defined here:</p>
<p>これらは、先に頂点シェーダープログラムで定義した行列変数に正確に対応しています。</p>
<p>予想通り、次のステップで定義したプライベート・ヘルパー関数を呼び出し、引数としてシェーダープログラムを渡すことで、コンストラクタ内でこれらのアトリビュートを作成する：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">明示的なユニフォーム (juce::OpenGLShaderProgram&amp; shaderProgram)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            projectionMatrix .reset (createUniform (shaderProgram, &quot;projectionMatrix&quot;))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            viewMatrix .reset (createUniform (shaderProgram, &quot;viewMatrix&quot;))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The helper function in turn will call the <a href="https://docs.juce.com/master/structOpenGLShaderProgram_1_1Uniform" target="_blank" rel="noopener noreferrer" title="Represents an openGL uniform value.">OpenGLShaderProgram::ユニフォーム</a> constructor to instantiate new objects:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static juce::OpenGLShaderProgram::Uniform* createUniform (juce::OpenGLShaderProgram&amp; shaderProgram、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                  const juce::String&amp; uniformName)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (glGetUniformLocation (shaderProgram.getProgramID(), uniformName.toRawUTF8()) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return nullptr；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new juce::OpenGLShaderProgram::Uniform (shaderProgram, uniformName.toRawUTF8())；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>However, in the above we first check whether the uniform exists in the shader program by using the <code>glGetUniformLocation()</code> function. If the number returned is -1 then we abort the uniform instantiation.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-shape-struct">The Shape struct<a href="#the-shape-struct" class="hash-link" aria-label="The Shape struct への直接リンク" title="The Shape struct への直接リンク">​</a></h2>
<p>Shape構造体は、OpenGL用語でティーポットオブジェクトを定義する場所です。メンバ変数は、ティーポットモデルのWavefront Objファイルと、すぐ下のサブ構造体として定義された頂点バッファの配列を格納するために使用されます：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        WavefrontObjFile shapeFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        juce::OwnedArray頂点バッファ；</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>まず、頂点バッファがどのように定義されているかを見てみましょう。このバッファには、メッシュ内のインデックスの総数と、後のレンダリングに備えるための頂点バッファとインデックスバッファが含まれています：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">GLuint vertexBuffer, indexBuffer；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int numIndices；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VertexBuffer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>このクラスのコンストラクタは、次のようにして頂点バッファを初期化します：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">            explicit VertexBuffer (WavefrontObjFile::Shape&amp; aShape)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                using namespace ::juce::gl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                numIndices = aShape.mesh.indices.size();                                    // [1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glGenBuffers (1, &amp;vertexBuffer);                                            // [2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glBindBuffer (GL_ARRAY_BUFFER, vertexBuffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                juce::Array vertices;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                createVertexListFromMesh (aShape.mesh, vertices, juce::Colours::green);     // [3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glBufferData (GL_ARRAY_BUFFER,                                              // [4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              static_cast (static_cast (vertices.size()) * sizeof (Vertex)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              vertices.getRawDataPointer(), GL_STATIC_DRAW);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glGenBuffers (1, &amp;indexBuffer);                                             // [5]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glBufferData (GL_ELEMENT_ARRAY_BUFFER,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              static_cast (static_cast(numIndices) * sizeof (juce::uint32))、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              aShape.mesh.indices.getRawDataPointer(), GL_STATIC_DRAW)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>[1]: We first retrieve the number of indices in the mesh we want to draw.</li>
<li>[2]: Then we generate the buffer object name for our single vertex buffer with the <code>glGenBuffers()</code> function and bind the vertex attributes to it with the <code>glBindBuffer()</code> function.</li>
<li>[3]: Using the helper function defined below, we create a vertex list from the teapot mesh.</li>
<li>[4]: We can then copy the vertex list into the vertex buffer by calling the <code>glBufferData()</code> function.</li>
<li>[5]: Finally we do the same for the index buffer by generating the buffer object name, binding the vertex array indices to it and copying the indices into the index buffer.</li>
</ul>
<p>頂点リストからメッシュを作成するヘルパー関数は以下のように定義されている：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        static void createVertexListFromMesh (const WavefrontObjFile::Mesh&amp; mesh, juce::Arrayリスト, juce::Colour カラー)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            auto scale = 0.2f; // [6］</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            WavefrontObjFile::TextureCoord defaultTexCoord { 0.5f, 0.5f }；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            WavefrontObjFile::Vertex defaultNormal { 0.5f, 0.5f, 0.5f }；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (auto i = 0; i &lt; mesh.vertices.size(); ++i) // [7].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const auto&amp; v = mesh.vertices.getReference (i)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const auto&amp; n = i &lt; mesh.normals.size() ? mesh.normals.getReference (i) : defaultNormal；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const auto&amp; tc = i &lt; mesh.textureCoords.size() ? mesh.textureCoords.getReference (i) : defaultTexCoord；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                list.add ({ { scale * v.x, scale * v.y, scale * v.z, }、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            { scale * n.x, scale * n.y, scale * n.z, }、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            { color.getFloatRed(), color.getFloatGreen(), color.getFloatBlue(), color.getFloatAlpha() }、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            { tc.x, tc.y }.}); // [8]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>[6]: We first define several local variables for the mesh scale, the default texture coordinates and the default normal vector.</li>
<li>[7]: Then for every vertex in the mesh, we get a reference to the vertex position, normal vector and texture coordinates to create a new Vertex object that we defined earlier.</li>
<li>[8]: On the Vertex object that was created, we scale the position and normal vectors, assign a dummy green colour and finally we add it to the vertex list.</li>
</ul>
<p>In the destructor, we delete the vertex and index buffers by calling the <code>glDeleteBuffers()</code> function on each variable:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">~頂点バッファ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glDeleteBuffers (1, &amp;vertexBuffer)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glDeleteBuffers (1, &amp;indexBuffer)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The <code>バインド</code> function defined below is called when the shape is drawn and binds the vertex and index buffers using the <code>glBindBuffer()</code> function:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void bind()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    glBindBuffer (GL_ARRAY_BUFFER, vertexBuffer)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, indexBuffer)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>さて、シェイプコンストラクタに戻って、ティーポットのバイナリデータをWavefrontObjFile変数にロードしてみましょう：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">形状()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            auto dir = juce::File::getCurrentWorkingDirectory()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int numTries = 0；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (! dir.getChildFile (&quot;Resources&quot;).exists() &amp;&amp; numTries++ &lt; 15)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dir = dir.getParentDirectory()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (shapeFile.load (dir.getChildFile (&quot;Resources&quot;).getChildFile (&quot;teapot.obj&quot;)).wasOk())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (auto* s : shapeFile.shapes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    vertexBuffers.add (new VertexBuffer (*s))；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="theme-admonition theme-admonition-warning admonition_xJq3 alert alert--warning"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_BuS1"><p>Make sure that the &quot;teapot.obj&quot; file exists in the <code>リソ ース</code> folder of your project.</p></div></div>
<p>ロードに成功すれば、WavefrontObjFileオブジェクトに含まれるすべての形状を繰り返し処理し、新しいVertexBufferオブジェクトを作成して頂点バッファ配列に追加することができます。</p>
<p>Finally, we implement a <code>ドロー()</code> function that will be called in the <code>レンダー</code> function of the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a> later on as defined below:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void draw (Attributes&amp; glAttributes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (auto* vertexBuffer : vertexBuffers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                vertexBuffer-&gt;bind()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glAttributes.enable()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glDrawElements (GL_TRIANGLES, vertexBuffer-&gt;numIndices, GL_UNSIGNED_INT, nullptr)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                glAttributes.disable()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>For every vertex buffer in the member variable array, we first call the <code>バインド</code> function to bind the vertex and index buffers to the GL context. We then call the <code>イネーブル()</code> function defined earlier on every attribute to fill the arrays with data. Finally, the <code>glDrawElements</code> function draws every set of three vertices contained in the vertex buffer as triangles before the attributes are disabled and emptied.</p>
<h1>Putting it all together</h1>
<p>これで、ティーポットをレンダリングするためのすべてのコンポーネントが揃った。</p>
<p>As mentioned before our app inherits from the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a> class as shown here in the <code>  メインコンテンツコンポーネント</code> class:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MainContentComponent : public juce::OpenGLAppComponent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public：</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>In the class constructor, we set the size of our window as usual using the <code>setSize()</code> function:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MainContentComponent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setSize (800, 600)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>In the class destructor, we make sure that the OpenGL system is shutdown before our class is destroyed by calling the <code>shutdownOpenGL()</code> function:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">~MainContentComponent()オーバーライド</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shutdownOpenGL()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>As described before the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a> class provides startup and shutdown functions to facilitate implementation of our graphics application. In the <code>イニシャライズ()</code> function we call the helper function <code>createShaders()</code> defined earlier to prepare the vertex and fragment shaders as shown here:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void initialise() オーバーライド</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        createShaders()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>As for the <code>シャットダウン</code> function, we ensure there is no leakage by setting all the member variable pointers to null as done here:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void shutdown() override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shader .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shape .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        アトリビュート .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ユニフォーム .reset()；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Next, we perform the actual rendering by overriding the <code>[OpenGLAppComponent::render()](classOpenGLAppComponent.html#af4e76e80318343d5302be7af6bf4cdbc &quot;Called to render your openGL.&quot;)</code> function as explained below:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void render() オーバーライド</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        名前空間 ::juce::gl；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        jassert (juce::OpenGLHelpers::isContextActive())；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auto desktopScale = (float) openGLContext.getRenderingScale(); // [1].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        juce::OpenGLHelpers::clear (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId)); // [2].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        glEnable (GL_BLEND); // [3].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        glViewport (0、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    juce::roundToInt (desktopScale * (float) getWidth())、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    juce::roundToInt (desktopScale * (float) getHeight())); // [4].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shader-&gt;use(); // [5].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (uniforms-&gt;projectionMatrix.get() != nullptr) // [6].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            uniforms-&gt;projectionMatrix-&gt;setMatrix4 (getProjectionMatrix().mat, 1, false)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (uniforms-&gt;viewMatrix.get() != nullptr) // [7].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            uniforms-&gt;viewMatrix-&gt;setMatrix4 (getViewMatrix().mat, 1, false)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shape-&gt;draw (*attributes); // [8].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        子コンポーネントが正しく描画されるように、 // 要素バッファをリセットする。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        glBindBuffer (GL_ARRAY_BUFFER, 0); // [9].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="クリップボードにコードをコピー" title="コピー" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>[1]: First check that the GL context is active using the <code>[OpenGLHelpers::isContextActive()](classOpenGLHelpers.html#aeb9c20e316e3aa59046a4fe4cb2562f8 &quot;Returns true if the current thread has an active OpenGL context.&quot;)</code> function so that we can retrieve the scale factor of the rendering display.</li>
<li>[2]: We can then clear the display by painting the background with the appropriate look and feel colour.</li>
<li>[3]: This goes beyond the scope of the tutorial but the <code>glEnable()</code> function activates the &quot;GL_BLEND&quot; option which blends the colour of the computed fragment colour with the colour buffer values. The blending method is specified in the <code>glBlendFunc()</code> function by specifying the transparency calculation.</li>
<li>[4]: The <code>glViewport()</code> function sets the viewport of the GL window relative to the device screen by multiplying the width and height by the rendering display scale factor.</li>
<li>[5]: By calling the <code>使用</code> function on the shader pointer, we specify which shader we want to use in this GL context.</li>
<li>[6]: We set the projection matrix as a uniform variable from our helper function to compute the shader.</li>
<li>[7]: We also set the view matrix as a uniform variable from our helper function to compute the shader.</li>
<li>[8]: Finally, we call the <code>ドロー()</code> function defined earlier on the shape pointer to render the teapot within the GL context and attributes specified as arguments.</li>
<li>[9]: We also make sure to empty the vertex attributes and vertex array indices using the <code>glBindBuffer()</code> function on the GL context.</li>
</ul>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>注記</div><div class="admonitionContent_BuS1"><p>接頭辞が &quot;gl &quot;である関数はすべて、JUCEライブラリではなく、開発マシンのOpenGLライブラリに含まれています。</p></div></div>
<h1>概要</h1>
<p>このチュートリアルでは、OpenGL JUCE アプリケーションのセットアップ方法を学びました。特に</p>
<ul>
<li>Learnt the functionalities of the <a href="https://docs.juce.com/master/classOpenGLAppComponent" target="_blank" rel="noopener noreferrer" title="A base class for writing simple one-page graphical apps.">OpenGLAppComponent</a> class.</li>
<li>WavefrontのObjファイルをOpenGLレンダラーにロードした。</li>
<li>計算された投影行列とビュー行列。</li>
<li>Configured the <a href="https://docs.juce.com/master/classOpenGLContext" target="_blank" rel="noopener noreferrer" title="Creates an OpenGL context, which can be attached to a component.">OpenGLContext</a> and render appearance using shaders.</li>
</ul>
<h1>関連項目</h1>
<ul>
<li><a href="/juce-tutorial-ja/graphics/tutorial_main_window/">チュートリアルアプリケーション・ウィンドウ</a></li>
<li><a href="/juce-tutorial-ja/graphics/tutorial_main_component/">チュートリアルメイン・コンポーネント</a></li>
<li><a href="/juce-tutorial-ja/graphics/tutorial_graphics_class/">チュートリアルGraphicsクラス</a></li>
<li><a href="/juce-tutorial-ja/graphics/tutorial_component_parents_children/">チュートリアル親子コンポーネント</a></li>
<li><a href="/juce-tutorial-ja/graphics/tutorial_animation/">チュートリアルジオメトリのアニメーション</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>タグ:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/juce-tutorial-ja/tags/上級/">上級</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/m1m0zzz/juce-tutorial-ja/tree/main/docs/graphics/tutorial_open_gl_application.mdx" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>このページを編集</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="ドキュメントページ"><a class="pagination-nav__link pagination-nav__link--prev" href="/juce-tutorial-ja/graphics/tutorial_animation/"><div class="pagination-nav__sublabel">前へ</div><div class="pagination-nav__label">ジオメトリのアニメーション</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/juce-tutorial-ja/category/interface-design/"><div class="pagination-nav__sublabel">次へ</div><div class="pagination-nav__label">Interface Design</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#はじめる" class="table-of-contents__link toc-highlight">はじめる</a></li><li><a href="#the-vertex-struct" class="table-of-contents__link toc-highlight">The Vertex struct</a></li><li><a href="#the-attributes-struct" class="table-of-contents__link toc-highlight">The Attributes struct</a></li><li><a href="#the-uniforms-struct" class="table-of-contents__link toc-highlight">The Uniforms struct</a></li><li><a href="#the-shape-struct" class="table-of-contents__link toc-highlight">The Shape struct</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Tutorial</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/juce-tutorial-ja/category/getting-started/">Getting Started</a></li></ul></div><div class="col footer__col"><div class="footer__title">JUCE</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://juce.com/learn/tutorials/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Tutorials<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://juce.com/learn/documentation/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Documentation<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://forum.juce.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/m1m0zzz/juce-tutorial-ja" target="_blank" rel="noopener noreferrer" class="footer__link-item">repo<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/juce-framework/JUCE" target="_blank" rel="noopener noreferrer" class="footer__link-item">JUCE GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">© 2024 Raw Material Software Limited. translation: mimoz</div></div></div></footer></div>
</body>
</html>