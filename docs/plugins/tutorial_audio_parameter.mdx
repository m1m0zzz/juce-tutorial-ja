---
title: プラグインパラメータの追加
sidebar_position: 1
tags: ["ビギナー"]
---

import CaptionImage from "@site/src/components/CaptionImage";
import SourcePageLink from "@site/src/components/SourcePageLink";

# チュートリアル：プラグインパラメータの追加

<SourcePageLink path="tutorial_audio_parameter" />

オーディオプラグインにパラメータを追加して、デジタルオーディオワークステーションからのコントロールとオートメーションを可能にします。
オーディオパラメータをオーディオ処理に使用し、そのユーザーインターフェイスを作成する方法を学びます。

レベル：ビギナー

プラットフォーム：Windows, macOS, Linux

クラス：
[AudioParameterFloat](https://docs.juce.com/master/tutorial_audio_parameter.html),
[AudioParameterBool](https://docs.juce.com/master/classAudioParameterBool.html),
[GenericAudioProcessorEditor](https://docs.juce.com/master/classGenericAudioProcessorEditor.html)


## はじめる

Download the demo project for this tutorial here: [ピップ](/tutorials/PIPs/AudioParameterTutorial.zip) | [ジップ](/tutorials/ZIPs/AudioParameterTutorial.zip). Unzip the project and open the first header file in the Projucer.

If you need help with this step, see [チュートリアルProjucerパート1：Projucerを始める](../tutorial_new_projucer_project/).

You should also know how to build an audio plug-in using JUCE and load this into your preferred audio host (also known as a Digital Audio Workstation — DAW). See [チュートリアル基本的なAudio/MIDIプラグインを作る, パート1：セットアップ](../tutorial_create_projucer_basic_plugin/) for an introduction.

# The demo project

The demo project is based on the *ゲインプラグイン* project in the `JUCE/examples/Plugins` directory. This plug-in simply changes the gain of an incoming signal using a single parameter.


<CaptionImage src="https://docs.juce.com/master/tutorial_audio_parameter_screenshot1.png" caption="The gain plug-in UI in Logic Pro X" />


# The gain processor

Most of the code in the `チュートリアルプロセッサー` class is the same as that generated by the Projucer when you use the **オーディオプラグイン** project template. For simplicity, we have bundled the processor code into a single `.h` file rather than being split across a `.cpp` and an `.h` file.

## Configuring the parameters

プロセッサーには、各パラメーターのオーディオ・パラメーター・メンバーを格納する必要があります。私たちの場合は1つだけです：

```
プライベート：
    //==============================================================================
    juce::AudioParameterFloat* gain；
 
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)
};
```

プロセッサは、プラグインが必要とするパラメータをコンストラクタに割り当てて追加します。この単純な例では、設定するパラメータは1つだけです：

```
チュートリアルプロセッサ()
    {
        addParameter (gain = new juce::AudioParameterFloat ("gain", // parameterID
                                                            "Gain", // パラメータ名
                                                            0.0f, // 最小値
                                                            1.0f, // 最大値
                                                            0.5f)); // デフォルト値
    }
```

:::note

The base class ([オーディオプロセッサ](https://docs.juce.com/master/classAudioProcessor "Base class for audio processing classes or plugins.")) takes ownership of the parameter objects, which is why we use raw pointers to store our parameters in the derived processor class. This is safe because you know for certain that the base class will be deconstructed after our derived class. In addition to this, you can also assume that the processor's editor component will be deleted before the processor object.

:::

The *パラメータID* should be a unique identifier for this parameter. Think of this like a variable name; it can contain alphanumeric characters and underscores, but no spaces. The *パラメータ名* is the name that will be displayed on the screen.

{/* TODO */}
{/* In addition to this, the [AudioParameterFloat](https://docs.juce.com/master/classAudioParameterFloat "A subclass of AudioProcessorParameter that provides an easy way to create a parameter which maps onto...") class allows you to specify the range of values that the parameter can represent. The [AudioParameterFloat](https://docs.juce.com/master/classAudioParameterFloat "A subclass of AudioProcessorParameter that provides an easy way to create a parameter which maps onto...") class also has an alternative constructor which allows you to use a [NormalisableRange<float>（正規化可能範囲<浮動小数点数](https://docs.juce.com/master/classNormalisableRange) object instead. JUCE stores all of the parameter values in the range \[0, 1\] as this is a limitation of *いくつか* of the target plug-in APIs. We could rewrite the code shown above as: */}

```
addParameter (gain = new juce::AudioParameterFloat ("gain",                                      // parameter ID
                                                    "Gain",                                      // parameter name
                                                    juce::NormalisableRange(0.0f, 1.0f), // パラメータ範囲
                                                    0.5f)); // デフォルト値
```

{/* TODO */}
{/* This may seem a little pointless in our example (since the parameter range is already in the range \[0, 1\]!) but using a [NormalisableRange<float>（正規化可能範囲<浮動小数点数](https://docs.juce.com/master/classNormalisableRange) object also allows you to specify a *スキューファクター*. This is especially useful if your plug-in needs to use parameters that represent frequency or time properties, since these are often best represented using a non-linear mapping. */}

:::note

The [AudioParameterFloat](https://docs.juce.com/master/classAudioParameterFloat "A subclass of AudioProcessorParameter that provides an easy way to create a parameter which maps onto...") class also has additional optional lambda functions that can be specified to convert the value to text and vice-versa. This is especially useful if you want to display the parameter's value as a string or allow the user to type in the value.

:::

## Performing the gain processing

Once the parameters have been created and added, your plug-in can interact with these parameter objects. In our case we simply retrieve the *ゲイン* value in the `TutorialProcessor::processBlock()` function:

```
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
    {
        buffer.applyGain（*ゲイン）；
    }
```

The [AudioSampleBuffer::applyGain()](classAudioBuffer.html#a9ffc61d339e455d4bddc7cf055a63ee3 "Applies a gain multiple to a region of one channel.") function applies our gain value to all samples across all channels in the buffer.

This illustrates the idiom that you should use when using the audio parameter classes: dereference the pointer to the parameter to obtain the parameter value. In this case, because we are using an `[AudioParameterFloat](https://docs.juce.com/master/classAudioParameterFloat "A subclass of AudioProcessorParameter that provides an easy way to create a parameter which maps onto...")`, we get a float.

The other `AudioParameter*XXX*` classes work in a similar way:

-   The [オーディオパラメータInt](https://docs.juce.com/master/classAudioParameterInt "Provides a class of AudioProcessorParameter that can be used as an integer value with a given range.") class works with integers.
-   The [AudioParameterBool](https://docs.juce.com/master/classAudioParameterBool "Provides a class of AudioProcessorParameter that can be used as a boolean value.") class works with boolean values.
-   The [オーディオパラメータ選択](https://docs.juce.com/master/classAudioParameterChoice "Provides a class of AudioProcessorParameter that can be used to select an indexed,...") class works with arrays of strings representing text-based options.

## Storing and retrieving parameters

In addition to providing routines for processing audio you also need to provide methods for storing and retrieving the *全体* state of your plug-in into a block of memory. This should include the current values of all of your parameters, but it can also include other state information if needed (for example, if your plug-in deals with files, it might store the file paths).

シンプルなゲイン・プラグインで保存するものはただひとつ、ゲイン値そのものです。これを保存するのは、浮動小数点値をバイナリ形式で書き込むのと同じくらい簡単だ：

```
void getStateInformation (juce::MemoryBlock& destData) override
    {
        juce::MemoryOutputStream (destData, true).writeFloat (*gain)；
    }
```

The [AudioProcessor::getStateInformation()](classAudioProcessor.html#a5d79591b367a7c0516e4ef4d1d6c32b2 "The host will call this method when it wants to save the processor's internal state.") callback is called when plug-in needs to have its state stored. For example, this happens when the user saves their DAW project or saves a preset (in some DAWs). We can put anything we like into the [メモリーブロック](https://docs.juce.com/master/classMemoryBlock "A class to hold a resizable block of raw data.") object that is passed to this function.

The [AudioProcessor::setStateInformation()](classAudioProcessor.html#a6154837fea67c594a9b35c487894df27 "This must restore the processor's state from a block of data previously created using getStateInforma...") function needs to do the opposite: it should read data from a memory location and restore the state of our plug-in:

```
    void setStateInformation (const void* data, int sizeInBytes) override
    {
        *gain = juce::MemoryInputStream (data, static_cast(sizeInBytes), false).readFloat()；
    }
```

ゲインパラメータをバイナリ形式ではなく、文字列として保存してみてください。

# Improving the gain processor

このゲイン・プロセッサーにはいくつか改善点がある：

-   ゲインを変えると信号に不連続性が生じ、ゲインを素早く変調すると小さなクリック音として聞こえる。
-   プラグインの状態を保存するには、XMLを使うと便利です。

## Smoothing gain changes

Using the AudioSampleBuffer class we can easily perform ramping gain changes over the whole block size of the buffer. In order to do this we need to store the value of the gain parameter from the *前* audio callback. First, add a member variable to the `チュートリアルプロセッサー` class \[1\]:

```
プライベート：
    //==============================================================================
    juce::AudioParameterFloat* gain；
    float previousGain; // [1］
 
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)
};
```

Then, ensure that this value is initialised in the `チュートリアルプロセッサ::preparePlay()` function:

```
void prepareToPlay (double, int) override
    {
        previousGain = *gain；
    }
```

Finally, modify the `TutorialProcessor::processBlock()` function to perform the gain ramp:

```
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
    {
        auto currentGain = gain->get()；
 
        if (juce::approximatelyEqual (currentGain, previousGain))
        {
            buffer.applyGain (currentGain)；
        }
        else
        {
            buffer.applyGainRamp (0, buffer.getNumSamples(), previousGain, currentGain)；
            previousGain = currentGain；
        }
    }
```

Here you can see that if the value hasn't changed, then we simply apply a constant gain. If the value has changed, then we apply the gain ramp, then update the `前ゲイン` value for next time.

:::note

The source code for this modified version of the plug-in can be found in the `AudioParameterTutorial_02.h` file of the demo project.

:::

平滑化アルゴリズムを変更し、処理ブロックサイズに依存しないようにする。

## Using XML to store the processor's state

Storing the plug-in state in a binary format results in using less memory and storage space for your plug-in's state. However, it is often more convient to use a format such as XML or [JSON](https://docs.juce.com/master/classJSON "Contains static methods for converting JSON-formatted text to and from var objects."). This makes debugging easier and it also simplifies making the stored state information compatible with future versions of your plug-in. In particular, XML makes it easy to:

-   情報ブロックにないパラメータをデフォルト値に設定する。
-   情報ブロックにバージョン情報を含めることで、異なるバージョンのプラグインの前方互換性と後方互換性を扱うことができます。

ゲイン・プラグインの状態をXMLに保存するには、次のようにする：

```
    void getStateInformation (juce::MemoryBlock& destData) override
    {
        std::unique_ptrxml (new juce::XmlElement ("ParamTutorial"))；
        xml->setAttribute ("gain", (double) *gain)；
        copyXmlToBinary (*xml, destData)；
    }
```

The [AudioProcessor::copyXmlToBinary()](classAudioProcessor.html#a6d0c1c945bebbc967d187c0f08b42c4b "Helper function that just converts an xml element into a binary blob.") function is a convenient helper function to convert XML to a binary blob. To retrieve the state we can do the opposite:

```
    void setStateInformation (const void* data, int sizeInBytes) override
    {
        std::unique_ptrxmlState (getXmlFromBinary (data, sizeInBytes))；
 
        if (xmlState.get() != nullptr)
            if (xmlState->hasTagName ("ParamTutorial"))
                *gain = (float) xmlState->getDoubleAttribute ("gain", 1.0)；
    }
```

Where the [AudioProcessor::getXmlFromBinary()](classAudioProcessor.html#a80c616e54758a0a411d27d6d76df956c "Retrieves an XML element that was stored as binary with the copyXmlToBinary() method.") function converts binary data—created with [AudioProcessor::copyXmlToBinary()](classAudioProcessor.html#a6d0c1c945bebbc967d187c0f08b42c4b "Helper function that just converts an xml element into a binary blob.") function—back to XML.

Importantly, you can see the error checking going on here. If the information block **ではない** XML then the function will do nothing. It also checks for the *タグ名* "ParamTutorial" and only proceeds if this name is found. The gain value will also default to 1.0 if the gain parameter isn't found. Adding version information is as simple as adding another attribute for this purpose. Then more error checking would allow you to handle different versions of the state information.

:::note

The source code for this modified version of the plug-in can be found in the `オーディオパラメータ・チュートリアル_03.h` file of the demo project.

:::

# Adding a phase invert parameter

Let's add a *位相反転* parameter to our gain plug-in!

## Adding a boolean parameter

First, add an AudioParameterBool\* member to the `チュートリアルプロセッサー` class \[2\]:

```
プライベート：
    //==============================================================================
    juce::AudioParameterFloat* gain；
    juce::AudioParameterBool* invertPhase; // [2].
 
    float previousGain；
 
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)
};
```

Then we need to allocate and add the parameter in the `チュートリアルプロセッサー` constructor \[3\]:

```
チュートリアルプロセッサ()
    {
        addParameter (gain = new juce::AudioParameterFloat ("gain", "Gain", 0.0f, 1.0f, 0.5f))；
        addParameter (invertPhase = new juce::AudioParameterBool ("invertPhase", "Invert Phase", false)); // [3].
    }
```

Of course a boolean parameter doesn't have a specifiable range, only a default value. We'll need to update our `TutorialProcessor::getStateInformation()` function \[4\]:

```
    void getStateInformation (juce::MemoryBlock& destData) override
    {
        std::unique_ptrxml (new juce::XmlElement ("ParamTutorial"))；
        xml->setAttribute ("gain", (double) *gain)；
        xml->setAttribute ("invertPhase", *invertPhase); // [4].
        copyXmlToBinary (*xml, destData)；
    }
```

And the `TutorialProcessor::setStateInformation()` function \[5\]:

```
    void setStateInformation (const void* data, int sizeInBytes) override
    {
        std::unique_ptrxmlState (getXmlFromBinary (data, sizeInBytes))；
 
        if (xmlState.get() != nullptr)
        {
            if (xmlState->hasTagName ("ParamTutorial"))
            {
                *gain = (float) xmlState->getDoubleAttribute ("gain", 1.0)；
                *invertPhase = xmlState->getBoolAttribute ("invertPhase", false); // [5].
            }
        }
    }
```

オーディオ処理コードを追加する必要がある：

```
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
    {
        auto phase = *invertPhase ?-1.0f : 1.0f; // [6].
        auto currentGain = *gain * phase; // [7].
 
        if (juce::approximatelyEqual (currentGain, previousGain))
        {
            buffer.applyGain (currentGain)；
        }
        else
        {
            buffer.applyGainRamp (0, buffer.getNumSamples(), previousGain, currentGain)；
            previousGain = currentGain；
        }
    }
```

ここで注目してほしい：

-   \[6\]: We choose either +1 or -1 depending on the state of the `逆位相` parameter.
-   \[7\]: We multiply this by the value of the `ゲイン` parameter.
-   この関数の残りのコードは、平滑化技術も含めて同じである。

Finally, the `前ゲイン` value needs to be initialised in the `チュートリアルプロセッサ::prepareToPlay()` function:

```
void prepareToPlay (double, int) override
    {
        auto phase = *invertPhase ?-1.0f : 1.0f；
        previousGain = *gain * phase；
    }
```

# 概要

In this tutorial we have learned about using audio parameters within the [オーディオプロセッサ](https://docs.juce.com/master/classAudioProcessor "Base class for audio processing classes or plugins.") class. In particular we have explored:

-   Creating [AudioParameterFloat](https://docs.juce.com/master/classAudioParameterFloat "A subclass of AudioProcessorParameter that provides an easy way to create a parameter which maps onto...") objects to represent our processor's variable parameters.
-   Using the values from [AudioParameterFloat](https://docs.juce.com/master/classAudioParameterFloat "A subclass of AudioProcessorParameter that provides an easy way to create a parameter which maps onto...") objects to control audio processing.
-   プロセッサの状態情報にパラメータ・データを格納し、取り出す。
-   Using [AudioParameterBool](https://docs.juce.com/master/classAudioParameterBool "Provides a class of AudioProcessorParameter that can be used as a boolean value.") objects to represent parameters that are in either an on or off state.

# 関連項目

-   [チュートリアル基本的なAudio/MIDIプラグインを作る, パート1：セットアップ](../tutorial_create_projucer_basic_plugin/)
-   [チュートリアルプラグインに適切なバスレイアウトを設定する](../tutorial_audio_bus_layouts/)
-   [チュートリアルプラグイン状態の保存と読み込み](../tutorial_audio_processor_value_tree_state/)
-   [チュートリアルカスケードプラグインエフェクト](../tutorial_audio_processor_graph/)