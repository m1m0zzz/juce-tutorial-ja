---
title: プラグインエフェクトのカスケード接続
sidebar_position: 4
tags: ["中級"]
---

# チュートリアル：プラグインエフェクトのカスケード接続

<SourcePageLink path="tutorial_audio_processor_graph" />

[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")を使用してオーディオプロセッサやプラグインをデイジーチェーン接続する方法を学び、独自のチャンネルストリップを作成します。プラグインとスタンドアロンアプリケーションの両方のコンテキストで[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")を使用する方法を学びます。

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins."), [AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor."), [AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors."), [AudioProcessorGraph::AudioGraphIOProcessor](https://docs.juce.com/master/classAudioProcessorGraph_1_1AudioGraphIOProcessor.html "A special type of AudioProcessor that can live inside an AudioProcessorGraph in order to use the audi..."), [AudioProcessorGraph::Node](https://docs.juce.com/master/classAudioProcessorGraph_1_1Node.html "Represents one of the nodes, or processors, in an AudioProcessorGraph."), [AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.")

## はじめに

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/AudioProcessorGraphTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/AudioProcessorGraphTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルをProjucerで開いてください。

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucerを始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトは、異なるオーディオプロセッサを直列に適用できるチャンネルストリップをシミュレートします。個別にバイパスできる3つのスロットがあり、オシレーター、ゲインコントロール、フィルターの3つの異なるプロセッサから選択できます。プラグインは入力オーディオに処理を適用し、変更された信号を出力に伝播します。

<CaptionImage
  src="/_images/tutorial_audio_processor_graph_screenshot1.png"
  caption="The channel strip plugin window"
/>

## AudioProcessorGraphのセットアップ

[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")は、複数の[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")オブジェクトをグラフ内のノードとして接続し、組み合わされた処理の結果を再生できる特別なタイプの[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")です。グラフノードを一緒にワイヤリングするには、オーディオ信号を処理したい順序でノードのチャンネル間の接続を追加する必要があります。

[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")クラスは、グラフ内のオーディオおよびMIDI信号の入出力処理用の特別なノードタイプも提供します。チャンネルストリップのグラフ例は、正しく接続されると次のようになります：

<CaptionImage
  src="/_images/tutorial_audio_processor_graph.svg"
/>

入力信号を受信し、処理せずに対応する出力に送り返すためのメインの[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")をセットアップすることから始めましょう。

このチュートリアルで頻繁に使用されるネストされたクラスの文字数を減らすために、まず`TutorialProcessor`クラスでAudioGraphIOProcessorクラスとNodeクラスの`using`を宣言します：

```cpp
using AudioGraphIOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor;
using Node = juce::AudioProcessorGraph::Node;
```

次に、クラス名の短縮版を使用して、以下のプライベートメンバー変数を宣言します：

```cpp
std::unique_ptr<juce::AudioProcessorGraph> mainProcessor;
```

```cpp
Node::Ptr audioInputNode;
Node::Ptr audioOutputNode;
Node::Ptr midiInputNode;
Node::Ptr midiOutputNode;
```

ここでは、メインの[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")へのポインタと、後でグラフ内でインスタンス化される入出力プロセッサノードを作成します。

次に、`TutorialProcessor`コンストラクタで、プラグインのデフォルトバスプロパティを設定し、メインの[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")をインスタンス化します：

```cpp
TutorialProcessor()
    : AudioProcessor (BusesProperties().withInput ("Input", juce::AudioChannelSet::stereo(), true).withOutput ("Output", juce::AudioChannelSet::stereo(), true)),
      mainProcessor (new juce::AudioProcessorGraph()),
```

プラグインを扱っているため、プラグインホストまたはDAWにどのチャンネルセットをサポートしているかを通知するためにisBusesLayoutSupported()コールバックを実装する必要があります。この例では、モノ・ツー・モノとステレオ・ツー・ステレオの設定のみをサポートすることにします：

```cpp
bool isBusesLayoutSupported (const BusesLayout& layouts) const override
{
    if (layouts.getMainInputChannelSet() == juce::AudioChannelSet::disabled()
        || layouts.getMainOutputChannelSet() == juce::AudioChannelSet::disabled())
        return false;

    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()
        && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
        return false;

    return layouts.getMainInputChannelSet() == layouts.getMainOutputChannelSet();
}
```

:::tip
バスレイアウトについてさらに学びたい場合は、[チュートリアル：プラグインの正しいバスレイアウトの設定](../tutorial_audio_bus_layouts/)を参照してください。
:::

`TutorialProcessor`が提供されたグラフを通じてオーディオを処理できるようにするには、信号処理を実行する[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")クラスの3つの主要な関数、つまりprepareToPlay()、releaseResources()、processBlock()関数をオーバーライドし、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")の同じそれぞれの関数を呼び出す必要があります。

prepareToPlay()関数から始めましょう。まず、setPlayConfigDetails()関数を呼び出して、I/Oチャンネル数、サンプルレート、ブロックあたりのサンプル数を[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")に通知します：

```cpp
void prepareToPlay (double sampleRate, int samplesPerBlock) override
{
    mainProcessor->setPlayConfigDetails (getMainBusNumInputChannels(),
        getMainBusNumOutputChannels(),
        sampleRate,
        samplesPerBlock);

    mainProcessor->prepareToPlay (sampleRate, samplesPerBlock);

    initialiseGraph();
}
```

次に、同じ情報で[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")のprepareToPlay()関数を呼び出し、後で定義する`initialiseGraph()`ヘルパー関数を呼び出してグラフ内のノードを作成および接続します。

releaseResources()関数は自明で、単に[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")インスタンスの同じ関数を呼び出します：

```cpp
void releaseResources() override
{
    mainProcessor->releaseResources();
}
```

最後にprocessBlock()関数では、念のためガベージデータを含む可能性のある追加チャンネルに含まれるサンプルをクリアし、チャンネルストリップの設定が変更された場合にグラフを再構築する後で定義する`updateGraph()`ヘルパー関数を呼び出します。関数の最後で[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")のprocessBlock()関数が最終的に呼び出されます：

```cpp
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer& midiMessages) override
{
    for (int i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    updateGraph();

    mainProcessor->processBlock (buffer, midiMessages);
}
```

prepareToPlay()コールバックで先に呼び出された`initialiseGraph()`関数は、まず以前に存在していたノードと接続を[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")からクリアすることから始めます。これにより、グラフ内の削除されたノードに関連付けられた対応する[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")インスタンスの削除も処理されます。次に、グラフI/O用のAudioGraphIOProcessorオブジェクトをインスタンス化し、[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")オブジェクトをグラフ内のノードとして追加します。

```cpp
void initialiseGraph()
{
    mainProcessor->clear();

    audioInputNode = mainProcessor->addNode (std::make_unique<AudioGraphIOProcessor> (AudioGraphIOProcessor::audioInputNode));
    audioOutputNode = mainProcessor->addNode (std::make_unique<AudioGraphIOProcessor> (AudioGraphIOProcessor::audioOutputNode));
    midiInputNode = mainProcessor->addNode (std::make_unique<AudioGraphIOProcessor> (AudioGraphIOProcessor::midiInputNode));
    midiOutputNode = mainProcessor->addNode (std::make_unique<AudioGraphIOProcessor> (AudioGraphIOProcessor::midiOutputNode));

    connectAudioNodes();
    connectMidiNodes();
}
```

オーディオ/MIDIデータを伝播するために、グラフ内の新しく作成されたノード間に接続を追加する必要があり、これは以下のヘルパー関数で実行されます：

```cpp
void connectAudioNodes()
{
    for (int channel = 0; channel < 2; ++channel)
        mainProcessor->addConnection ({ { audioInputNode->nodeID, channel },
            { audioOutputNode->nodeID, channel } });
}
```

ここでは、Connectionオブジェクトの形式で接続したいソースノードと宛先ノードを渡すことで、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")インスタンスのaddConnection()関数を呼び出します。これらは適切な接続を構築するためにnodeIDとチャンネルインデックスが必要で、このプロセス全体が必要なすべてのチャンネルに対して繰り返されます。

```cpp
void connectMidiNodes()
{
    mainProcessor->addConnection ({ { midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex },
        { midiOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex } });
}
```

MIDI I/Oノードでも同じことが行われますが、チャンネルインデックス引数は例外です。MIDI信号は通常のオーディオチャンネルを介して送信されないため、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")クラスの列挙型として指定された特別なチャンネルインデックスを提供する必要があります。

チュートリアルのこの段階で、信号が変更されることなくグラフを通過するのが聞こえるはずです。

:::warning
内蔵の入力と出力でプラグインをテストするときは、叫び声のようなフィードバックに注意してください。ヘッドフォンを使用することでこの問題を回避できます。
:::

## 異なるプロセッサの実装

チュートリアルのこの部分では、チャンネルストリッププラグイン内で使用して入力オーディオ信号を変更できるさまざまなプロセッサを作成します。追加のプロセッサを作成したり、以下のプロセッサをお好みでカスタマイズしたりしてください。

作成したいさまざまなプロセッサのコードの繰り返しを避けるために、まず個々のプロセッサに継承される[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")基底クラスを宣言し、簡略化のために必要な関数を一度だけオーバーライドしましょう。

```cpp
class ProcessorBase : public juce::AudioProcessor
{
public:
    //==============================================================================
    ProcessorBase()
        : AudioProcessor (BusesProperties().withInput ("Input", juce::AudioChannelSet::stereo()).withOutput ("Output", juce::AudioChannelSet::stereo()))
    {
    }

    //==============================================================================
    void prepareToPlay (double, int) override {}
    void releaseResources() override {}
    void processBlock (juce::AudioSampleBuffer&, juce::MidiBuffer&) override {}

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }

    //==============================================================================
    const juce::String getName() const override { return {}; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0; }

    //==============================================================================
    int getNumPrograms() override { return 0; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    //==============================================================================
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ProcessorBase)
};
```

:::tip
以下の3つのプロセッサは実装を容易にするためにDSPモジュールを使用します。DSPについてさらに学びたい場合は、[チュートリアル：DSP入門](../../dsp/tutorial_dsp_introduction/)を参照してください。
:::

### オシレーターの実装

最初のプロセッサは、440Hzの一定のサイン波トーンを生成するシンプルなオシレーターです。

`OscillatorProcessor`クラスを先に定義した`ProcessorBase`から派生させ、getName()関数をオーバーライドして意味のある名前を提供し、DSPモジュールから[dsp::Oscillator](https://docs.juce.com/master/classdsp_1_1Oscillator.html "Generates a signal based on a user-supplied function.")オブジェクトを宣言します：

```cpp
class OscillatorProcessor : public ProcessorBase
{
public:
    //...
    const juce::String getName() const override { return "Oscillator"; }

private:
    juce::dsp::Oscillator<float> oscillator;
};
```

コンストラクタでは、[dsp::Oscillator](https://docs.juce.com/master/classdsp_1_1Oscillator.html "Generates a signal based on a user-supplied function.")オブジェクトのsetFrequency()およびinitialise()関数をそれぞれ呼び出して、オシレーターの周波数と波形を設定します：

```cpp
OscillatorProcessor()
{
    oscillator.setFrequency (440.0f);
    oscillator.initialise ([] (float x) { return std::sin (x); });
}
```

prepareToPlay()関数では、サンプルレートとブロックあたりのサンプル数を[dsp::Oscillator](https://docs.juce.com/master/classdsp_1_1Oscillator.html "Generates a signal based on a user-supplied function.")オブジェクトに記述するための[dsp::ProcessSpec](https://docs.juce.com/master/structdsp_1_1ProcessSpec.html "This structure is passed into a DSP algorithm's prepare() method, and contains information about vari...")オブジェクトを作成し、prepare()関数を呼び出して仕様を渡します：

```cpp
void prepareToPlay (double sampleRate, int samplesPerBlock) override
{
    juce::dsp::ProcessSpec spec { sampleRate, static_cast<juce::uint32> (samplesPerBlock), 2 };
    oscillator.prepare (spec);
}
```

次に、processBlock()関数では、引数として渡されたAudioSampleBufferから[dsp::AudioBlock](https://docs.juce.com/master/classdsp_1_1AudioBlock.html "Minimal and lightweight data-structure which contains a list of pointers to channels containing some ...")オブジェクトを作成し、そこから処理コンテキストを[dsp::ProcessContextReplacing](https://docs.juce.com/master/structdsp_1_1ProcessContextReplacing.html "Contains context information that is passed into an algorithm's process method.")オブジェクトとして宣言し、[dsp::Oscillator](https://docs.juce.com/master/classdsp_1_1Oscillator.html "Generates a signal based on a user-supplied function.")オブジェクトのprocess()関数に渡します：

```cpp
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
{
    juce::dsp::AudioBlock<float> block (buffer);
    juce::dsp::ProcessContextReplacing<float> context (block);
    oscillator.process (context);
}
```

最後に、[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")のreset()関数をオーバーライドし、同じ関数を呼び出すことで[dsp::Oscillator](https://docs.juce.com/master/classdsp_1_1Oscillator.html "Generates a signal based on a user-supplied function.")オブジェクトの状態をリセットできます：

```cpp
void reset() override
{
    oscillator.reset();
}
```

これでチャンネルストリッププラグインで使用できるオシレーターができました。

:::note
演習：オシレーターのinitialise()関数を変更して異なる波形を生成し、ターゲット周波数を変更してください。
:::

### ゲインコントロールの実装

2番目のプロセッサは、入力信号を-6dB減衰させるシンプルなゲインコントロールです。

`GainProcessor`クラスを先に定義した`ProcessorBase`から派生させ、getName()関数をオーバーライドして意味のある名前を提供し、DSPモジュールから[dsp::Gain](https://docs.juce.com/master/classdsp_1_1Gain.html "Applies a gain to audio samples as single samples or AudioBlocks.")オブジェクトを宣言します：

```cpp
class GainProcessor : public ProcessorBase
{
public:
    //...
    const juce::String getName() const override { return "Gain"; }

private:
    juce::dsp::Gain<float> gain;
};
```

コンストラクタでは、[dsp::Gain](https://docs.juce.com/master/classdsp_1_1Gain.html "Applies a gain to audio samples as single samples or AudioBlocks.")オブジェクトのsetGainDecibels()関数を呼び出して、ゲインコントロールのゲインをデシベルで設定します：

```cpp
GainProcessor()
{
    gain.setGainDecibels (-6.0f);
}
```

prepareToPlay()関数では、サンプルレート、ブロックあたりのサンプル数、およびチャンネル数を[dsp::Gain](https://docs.juce.com/master/classdsp_1_1Gain.html "Applies a gain to audio samples as single samples or AudioBlocks.")オブジェクトに記述するための[dsp::ProcessSpec](https://docs.juce.com/master/structdsp_1_1ProcessSpec.html "This structure is passed into a DSP algorithm's prepare() method, and contains information about vari...")オブジェクトを作成し、prepare()関数を呼び出して仕様を渡します：

```cpp
void prepareToPlay (double sampleRate, int samplesPerBlock) override
{
    juce::dsp::ProcessSpec spec { sampleRate, static_cast<juce::uint32> (samplesPerBlock), 2 };
    gain.prepare (spec);
}
```

次に、processBlock()関数では、引数として渡されたAudioSampleBufferから[dsp::AudioBlock](https://docs.juce.com/master/classdsp_1_1AudioBlock.html "Minimal and lightweight data-structure which contains a list of pointers to channels containing some ...")オブジェクトを作成し、そこから処理コンテキストを[dsp::ProcessContextReplacing](https://docs.juce.com/master/structdsp_1_1ProcessContextReplacing.html "Contains context information that is passed into an algorithm's process method.")オブジェクトとして宣言し、[dsp::Gain](https://docs.juce.com/master/classdsp_1_1Gain.html "Applies a gain to audio samples as single samples or AudioBlocks.")オブジェクトのprocess()関数に渡します：

```cpp
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
{
    juce::dsp::AudioBlock<float> block (buffer);
    juce::dsp::ProcessContextReplacing<float> context (block);
    gain.process (context);
}
```

最後に、[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")のreset()関数をオーバーライドし、同じ関数を呼び出すことで[dsp::Gain](https://docs.juce.com/master/classdsp_1_1Gain.html "Applies a gain to audio samples as single samples or AudioBlocks.")オブジェクトの状態をリセットできます：

```cpp
void reset() override
{
    gain.reset();
}
```

これでチャンネルストリッププラグインで使用できるゲインコントロールができました。

:::note
演習：ゲインコントロールのsetGainDecibels()関数を変更して、ゲインをさらに下げるか、信号をブーストしてください。（ブースト時はレベルに注意！）
:::

### フィルターの実装

3番目のプロセッサは、1kHz未満の周波数を減衰させるシンプルなハイパスフィルターです。

`FilterProcessor`クラスを先に定義した`ProcessorBase`から派生させ、getName()関数をオーバーライドして意味のある名前を提供し、DSPモジュールから[dsp::ProcessorDuplicator](https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator.html "Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...")オブジェクトを宣言します。これにより、[dsp::IIR::Filter](https://docs.juce.com/master/classdsp_1_1IIR_1_1Filter.html "A processing class that can perform IIR filtering on an audio signal, using the Transposed Direct For...")クラスのモノプロセッサを使用し、[dsp::IIR::Coefficients](https://docs.juce.com/master/structdsp_1_1IIR_1_1Coefficients.html "A set of coefficients for use in an Filter object.")クラスとして共有状態を提供することでマルチチャンネルバージョンに変換できます：

```cpp
class FilterProcessor : public ProcessorBase
{
public:
    FilterProcessor() {}
    //...
    const juce::String getName() const override { return "Filter"; }

private:
    juce::dsp::ProcessorDuplicator<juce::dsp::IIR::Filter<float>, juce::dsp::IIR::Coefficients<float>> filter;
};
```

prepareToPlay()関数では、まずmakeHighPass()関数を使用してフィルターに使用する係数を生成し、デュプリケーターに共有処理状態として割り当てます。次に、サンプルレート、ブロックあたりのサンプル数、およびチャンネル数を[dsp::ProcessorDuplicator](https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator.html "Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...")オブジェクトに記述するための[dsp::ProcessSpec](https://docs.juce.com/master/structdsp_1_1ProcessSpec.html "This structure is passed into a DSP algorithm's prepare() method, and contains information about vari...")オブジェクトを作成し、prepare()関数を呼び出して仕様を渡します：

```cpp
void prepareToPlay (double sampleRate, int samplesPerBlock) override
{
    *filter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass (sampleRate, 1000.0f);

    juce::dsp::ProcessSpec spec { sampleRate, static_cast<juce::uint32> (samplesPerBlock), 2 };
    filter.prepare (spec);
}
```

次に、processBlock()関数では、引数として渡されたAudioSampleBufferから[dsp::AudioBlock](https://docs.juce.com/master/classdsp_1_1AudioBlock.html "Minimal and lightweight data-structure which contains a list of pointers to channels containing some ...")オブジェクトを作成し、そこから処理コンテキストを[dsp::ProcessContextReplacing](https://docs.juce.com/master/structdsp_1_1ProcessContextReplacing.html "Contains context information that is passed into an algorithm's process method.")オブジェクトとして宣言し、[dsp::ProcessorDuplicator](https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator.html "Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...")オブジェクトのprocess()関数に渡します：

```cpp
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
{
    juce::dsp::AudioBlock<float> block (buffer);
    juce::dsp::ProcessContextReplacing<float> context (block);
    filter.process (context);
}
```

最後に、[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")のreset()関数をオーバーライドし、同じ関数を呼び出すことで[dsp::ProcessorDuplicator](https://docs.juce.com/master/structdsp_1_1ProcessorDuplicator.html "Converts a mono processor class into a multi-channel version by duplicating it and applying multichan...")オブジェクトの状態をリセットできます：

```cpp
void reset() override
{
    filter.reset();
}
```

これでチャンネルストリッププラグインで使用できるフィルターができました。

:::note
演習：フィルターの係数を変更して、異なるカットオフ周波数とレゾナンスを持つローパスまたはバンドパスフィルターを生成してください。
:::

## グラフノードの接続

[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")内で使用できる複数のプロセッサを実装したので、ユーザーの選択に応じてそれらを接続し始めましょう。

`TutorialProcessor`クラスで、チャンネルストリップで選択されたパラメータとその対応するバイパス状態を保存するために、3つの[AudioParameterChoice](https://docs.juce.com/master/classAudioParameterChoice.html "Provides a class of AudioProcessorParameter that can be used to select an indexed,...")と4つの[AudioParameterBool](https://docs.juce.com/master/classAudioParameterBool.html "Provides a class of AudioProcessorParameter that can be used as a boolean value.")ポインタをプライベートメンバー変数として追加します。また、後でグラフ内でインスタンス化されるときの3つのプロセッサスロットへのノードポインタを宣言し、便宜上選択可能な選択肢を[StringArray](https://docs.juce.com/master/classStringArray.html "A special array for holding a list of strings.")として提供します。

```cpp
juce::StringArray processorChoices { "Empty", "Oscillator", "Gain", "Filter" };

std::unique_ptr<juce::AudioProcessorGraph> mainProcessor;

juce::AudioParameterBool* muteInput;

juce::AudioParameterChoice* processorSlot1;
juce::AudioParameterChoice* processorSlot2;
juce::AudioParameterChoice* processorSlot3;

juce::AudioParameterBool* bypassSlot1;
juce::AudioParameterBool* bypassSlot2;
juce::AudioParameterBool* bypassSlot3;

Node::Ptr audioInputNode;
Node::Ptr audioOutputNode;
Node::Ptr midiInputNode;
Node::Ptr midiOutputNode;

Node::Ptr slot1Node;
Node::Ptr slot2Node;
Node::Ptr slot3Node;

//==============================================================================
JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)
};
```

次にコンストラクタで、オーディオパラメータをインスタンス化し、addParameter()関数を呼び出して[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")にプラグインで利用可能にするパラメータを伝えます。

```cpp
TutorialProcessor()
    : AudioProcessor (BusesProperties().withInput ("Input", juce::AudioChannelSet::stereo(), true).withOutput ("Output", juce::AudioChannelSet::stereo(), true)),
      mainProcessor (new juce::AudioProcessorGraph()),
      muteInput (new juce::AudioParameterBool ("mute", "Mute Input", true)),
      processorSlot1 (new juce::AudioParameterChoice ("slot1", "Slot 1", processorChoices, 0)),
      processorSlot2 (new juce::AudioParameterChoice ("slot2", "Slot 2", processorChoices, 0)),
      processorSlot3 (new juce::AudioParameterChoice ("slot3", "Slot 3", processorChoices, 0)),
      bypassSlot1 (new juce::AudioParameterBool ("bypass1", "Bypass 1", false)),
      bypassSlot2 (new juce::AudioParameterBool ("bypass2", "Bypass 2", false)),
      bypassSlot3 (new juce::AudioParameterBool ("bypass3", "Bypass 3", false))
{
    addParameter (muteInput);

    addParameter (processorSlot1);
    addParameter (processorSlot2);
    addParameter (processorSlot3);

    addParameter (bypassSlot1);
    addParameter (bypassSlot2);
    addParameter (bypassSlot3);
}
```

このチュートリアルでは、[GenericAudioProcessorEditor](https://docs.juce.com/master/classGenericAudioProcessorEditor.html "A type of UI component that displays the parameters of an AudioProcessor as a simple list of sliders,...")クラスを使用します。これは、[AudioParameterChoice](https://docs.juce.com/master/classAudioParameterChoice.html "Provides a class of AudioProcessorParameter that can be used to select an indexed,...")型のプラグインプロセッサの各パラメータに対して自動的に[ComboBox](https://docs.juce.com/master/classComboBox.html "A component that lets the user choose from a drop-down list of choices.")を作成し、[AudioParameterBool](https://docs.juce.com/master/classAudioParameterBool.html "Provides a class of AudioProcessorParameter that can be used as a boolean value.")型ごとに[ToggleButton](https://docs.juce.com/master/classToggleButton.html "A button that can be toggled on/off.")を作成します。

:::tip
オーディオパラメータとそのカスタマイズ方法についてさらに学ぶには、[チュートリアル：プラグインパラメータの追加](../tutorial_audio_parameter/)を参照してください。パラメータの保存と読み込みのよりシームレスでエレガントな方法については、[チュートリアル：プラグイン状態の保存と読み込み](../tutorial_audio_processor_value_tree_state/)を見てください。
:::

チュートリアルの最初の部分で[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")をセットアップするときに、`TutorialProcessor`クラスのprocessBlock()コールバックで`updateGraph()`ヘルパー関数を呼び出すことに気づきました。この関数の目的は、ユーザーが選択した現在の選択に応じて、適切な[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")オブジェクトとノードを再インスタンス化し、グラフを再接続することでグラフを更新することです。そのヘルパー関数を次のように実装しましょう：

```cpp
void updateGraph()
{
    bool hasChanged = false;

    juce::Array<juce::AudioParameterChoice*> choices { processorSlot1,
        processorSlot2,
        processorSlot3 };

    juce::Array<juce::AudioParameterBool*> bypasses { bypassSlot1,
        bypassSlot2,
        bypassSlot3 };

    juce::ReferenceCountedArray<Node> slots;
    slots.add (slot1Node);
    slots.add (slot2Node);
    slots.add (slot3Node);
```

関数はグラフの状態を表すローカル変数を宣言し、前回のオーディオブロック処理のイテレーション以降に変更されたかどうかを示します。また、プロセッサの選択、バイパス状態、およびグラフ内の対応するノードに対するイテレーションを容易にするための配列を作成します。

次の部分では、3つの利用可能なプロセッサスロットを反復処理し、各[AudioParameterChoice](https://docs.juce.com/master/classAudioParameterChoice.html "Provides a class of AudioProcessorParameter that can be used to select an indexed,...")オブジェクトに対して選択されたオプションをチェックします：

```cpp
for (int i = 0; i < 3; ++i)
{
    auto& choice = choices.getReference (i);
    auto slot = slots.getUnchecked (i);

    if (choice->getIndex() == 0) // [1]
    {
        if (slot != nullptr)
        {
            mainProcessor->removeNode (slot.get());
            slots.set (i, nullptr);
            hasChanged = true;
        }
    }
    else if (choice->getIndex() == 1) // [2]
    {
        if (slot != nullptr)
        {
            if (slot->getProcessor()->getName() == "Oscillator")
                continue;

            mainProcessor->removeNode (slot.get());
        }

        slots.set (i, mainProcessor->addNode (std::make_unique<OscillatorProcessor>()));
        hasChanged = true;
    }
    else if (choice->getIndex() == 2) // [3]
    {
        if (slot != nullptr)
        {
            if (slot->getProcessor()->getName() == "Gain")
                continue;

            mainProcessor->removeNode (slot.get());
        }

        slots.set (i, mainProcessor->addNode (std::make_unique<GainProcessor>()));
        hasChanged = true;
    }
    else if (choice->getIndex() == 3) // [4]
    {
        if (slot != nullptr)
        {
            if (slot->getProcessor()->getName() == "Filter")
                continue;

            mainProcessor->removeNode (slot.get());
        }

        slots.set (i, mainProcessor->addNode (std::make_unique<FilterProcessor>()));
        hasChanged = true;
    }
}
```

- [1]：選択が「Empty」状態のままの場合、まずノードが以前に別のプロセッサにインスタンス化されていたかどうかを確認し、そうであればグラフからノードを削除し、ノードへの参照をクリアし、`hasChanged`フラグをtrueに設定します。そうでなければ、状態は変更されておらず、グラフの再構築は必要ありません。
- [2]：ユーザーが「Oscillator」状態を選択した場合、まず現在インスタンス化されているノードがすでにオシレータープロセッサであるかどうかを確認し、そうであれば状態は変更されておらず、次のスロットに進みます。そうでなければ、スロットがすでに占有されている場合はグラフからノードを削除し、オシレーターをインスタンス化して新しいノードへの参照を設定し、`hasChanged`フラグをtrueに設定します。
- [3]：「Gain」状態についても同じことを行い、必要に応じてゲインプロセッサをインスタンス化します。
- [4]：同様に、「Filter」状態についても同じプロセスを繰り返し、必要に応じてフィルタープロセッサをインスタンス化します。

次のセクションは、グラフの状態が変更された場合にのみ実行され、ノードの接続を開始します：

```cpp
if (hasChanged)
{
    for (auto connection : mainProcessor->getConnections()) // [5]
        mainProcessor->removeConnection (connection);

    juce::ReferenceCountedArray<Node> activeSlots;

    for (auto slot : slots)
    {
        if (slot != nullptr)
        {
            activeSlots.add (slot); // [6]

            slot->getProcessor()->setPlayConfigDetails (getMainBusNumInputChannels(),
                getMainBusNumOutputChannels(),
                getSampleRate(),
                getBlockSize());
        }
    }

    if (activeSlots.isEmpty()) // [7]
    {
        connectAudioNodes();
    }
    else
    {
        for (int i = 0; i < activeSlots.size() - 1; ++i) // [8]
        {
            for (int channel = 0; channel < 2; ++channel)
                mainProcessor->addConnection ({ { activeSlots.getUnchecked (i)->nodeID, channel },
                    { activeSlots.getUnchecked (i + 1)->nodeID, channel } });
        }

        for (int channel = 0; channel < 2; ++channel) // [9]
        {
            mainProcessor->addConnection ({ { audioInputNode->nodeID, channel },
                { activeSlots.getFirst()->nodeID, channel } });
            mainProcessor->addConnection ({ { activeSlots.getLast()->nodeID, channel },
                { audioOutputNode->nodeID, channel } });
        }
    }

    connectMidiNodes();

    for (auto node : mainProcessor->getNodes()) // [10]
        node->getProcessor()->enableAllBuses();
}
```

- [5]：まず、ブランク状態から開始するためにグラフ内のすべての接続を削除します。
- [6]：次に、スロットを反復処理し、グラフ内に[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")ノードがあるかどうかを確認します。ある場合は、アクティブノードの一時配列にノードを追加し、将来の処理のためにノードを準備するために、チャンネル、サンプルレート、ブロックサイズ情報を使用して対応するプロセッサインスタンスのsetPlayConfigDetails()関数を呼び出します。
- [7]：次に、アクティブスロットが見つからない場合、これはすべての選択が「Empty」状態であり、オーディオI/Oプロセッサノードを単純に一緒に接続できることを意味します。
- [8]：そうでなければ、オーディオI/Oプロセッサノードの間にあるべきノードが少なくとも1つあることを意味します。したがって、スロット番号の昇順でアクティブスロットを一緒に接続し始めることができます。ここで、必要な接続のペア数はアクティブスロット数マイナス1だけであることに注意してください。
- [9]：その後、オーディオ入力プロセッサノードをチェーン内の最初のアクティブスロットに、最後のアクティブスロットをオーディオ出力プロセッサノードにリンクしてグラフの接続を完了します。
- [10]：最後に、MIDI I/Oノードを接続し、オーディオプロセッサのすべてのバスが有効になっていることを確認します。

```cpp
for (int i = 0; i < 3; ++i)
{
    auto slot = slots.getUnchecked (i);
    auto& bypass = bypasses.getReference (i);

    if (slot != nullptr)
        slot->setBypassed (bypass->get());
}

audioInputNode->setBypassed (muteInput->get());

slot1Node = slots.getUnchecked (0);
slot2Node = slots.getUnchecked (1);
slot3Node = slots.getUnchecked (2);
}
```

`updateGraph()`ヘルパー関数の最後のセクションでは、スロットがアクティブかどうかを確認し、チェックボックスがトグルされている場合は[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")をバイパスして、プロセッサのバイパス状態を処理します。また、テスト時のフィードバックループを避けるために入力をミュートするかどうかもチェックします。その後、次のイテレーションのために新しく作成されたノードを対応するスロットに割り当てます。

プラグインはグラフ内のロードされたプロセッサを通じて入力オーディオを処理して実行されるはずです。

:::note
演習：お好みの追加プロセッサノードを作成し、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")に追加してください。（例えば、MIDIメッセージを処理するプロセッサなど。）
:::

## プラグインをアプリケーションに変換

スタンドアロンアプリ内で[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")を使用することに興味がある場合、このオプションのセクションでこれについて詳しく説明します。

まず、メインの`TutorialProcessor`クラスを[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")の代わりに[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")のサブクラスに変換する必要があります。他のJUCE GUIアプリケーションの命名規則に合わせるために、クラス名を`MainComponent`に変更します：

```cpp
class MainComponent : public juce::Component,
                      private juce::Timer
{
public:
```

:::tip
PIPファイルを使用してこのチュートリアルに従っている場合は、「mainClass」と「type」フィールドを変更を反映するように変更し、「dependencies」フィールドを適切に修正してください。プロジェクトのZIPバージョンを使用している場合は、`Main.cpp`ファイルが「GUI Application」テンプレート形式に従っていることを確認してください。
:::

プラグインを作成するとき、すべてのIOデバイス管理と再生機能はホストによって制御されるため、これらのセットアップについて心配する必要はありません。しかし、スタンドアロンアプリケーションでは、これを自分で管理する必要があります。そのため、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")とシステムで利用可能なオーディオIOデバイス間の通信を可能にするために、`MainComponent`クラスに[AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.")と[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")をプライベートメンバー変数として宣言します。

```cpp
juce::AudioDeviceManager deviceManager;
juce::AudioProcessorPlayer player;
```

[AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.")はすべてのプラットフォームでオーディオおよびMIDIデバイスを管理する便利なクラスで、[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")は[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")を通じた簡単な再生を可能にします。

コンストラクタでは、プラグインパラメータを初期化する代わりに、通常のGUIコンポーネントを作成し、[AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.")と[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")を初期化します：

```cpp
MainComponent()
    : mainProcessor (new juce::AudioProcessorGraph())
{
```

```cpp
auto inputDevice = juce::MidiInput::getDefaultDevice();
auto outputDevice = juce::MidiOutput::getDefaultDevice();

mainProcessor->enableAllBuses();

deviceManager.initialiseWithDefaultDevices (2, 2); // [1]
deviceManager.addAudioCallback (&player); // [2]
deviceManager.setMidiInputDeviceEnabled (inputDevice.identifier, true);
deviceManager.addMidiInputDeviceCallback (inputDevice.identifier, &player); // [3]
deviceManager.setDefaultMidiOutputDevice (outputDevice.identifier);

initialiseGraph();

player.setProcessor (mainProcessor.get()); // [4]

setSize (600, 400);
startTimer (100);
}
```

ここでは、まずデフォルトのオーディオデバイスと各2つの入力と出力でデバイスマネージャーを初期化します[1]。次に[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")をデバイスマネージャーにオーディオコールバックとして追加し[2]、デフォルトのMIDIデバイスを使用してMIDIコールバックとして追加します[3]。グラフの初期化後、[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")のsetProcessor()関数を呼び出して[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")を再生するプロセッサとして設定できます[4]。

```cpp
~MainComponent() override
{
    auto device = juce::MidiInput::getDefaultDevice();

    deviceManager.removeAudioCallback (&player);
    deviceManager.setMidiInputDeviceEnabled (device.identifier, false);
    deviceManager.removeMidiInputDeviceCallback (device.identifier, &player);
}
```

デストラクタでは、アプリケーションのシャットダウン時に[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")をオーディオおよびMIDIコールバックとして削除することを確認します。

プラグインの実装とは異なり、[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")が自動的にオーディオの処理を行うため、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")のprepareToPlay()およびprocessBlock()関数を呼び出す必要がありません。

しかし、ユーザーがパラメータを変更したときにグラフを更新する方法を見つける必要があり、`MainComponent`を[Timer](https://docs.juce.com/master/classTimer.html "Makes repeated callbacks to a virtual method at a specified time interval.")クラスから派生させ、timerCallback()関数をオーバーライドすることでこれを行います：

```cpp
void timerCallback() override { updateGraph(); }
```

:::tip
タイマーコールバックを使用することは最も効率的な解決策ではなく、一般的に適切なコンポーネントにリスナーとして登録することがベストプラクティスです。
:::

最後に、`updateGraph()`関数を変更して、スタンドアロンアプリのシナリオでは後者が[AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")に置き換えられたため、メインの[AudioProcessor](https://docs.juce.com/master/classAudioProcessor.html "Base class for audio processing classes or plugins.")の代わりに[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")から再生設定の詳細を設定します：

```cpp
for (auto slot : slots)
{
    if (slot != nullptr)
    {
        activeSlots.add (slot);

        slot->getProcessor()->setPlayConfigDetails (mainProcessor->getMainBusNumInputChannels(),
            mainProcessor->getMainBusNumOutputChannels(),
            mainProcessor->getSampleRate(),
            mainProcessor->getBlockSize());
    }
}
```

これらの変更後、プラグインはアプリケーションとして実行されるはずです。

:::warning
繰り返しになりますが、内蔵の入力と出力でアプリをテストするときは、叫び声のようなフィードバックに注意してください。ヘッドフォンを使用することでこの問題を回避できます。
:::


:::tip
このプラグインの修正版のソースコードは、デモプロジェクトの`AudioProcessorGraphTutorial_02.h`ファイルにあります。
:::

## まとめ

このチュートリアルでは、[AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")を操作してプラグインのエフェクトをカスケードする方法を学びました。特に以下のことを行いました：

- 一連のオーディオプロセッサを持つチャンネルストリップを構築しました。
- [AudioProcessorGraph](https://docs.juce.com/master/classAudioProcessorGraph.html "A type of AudioProcessor which plays back a graph of other AudioProcessors.")でノードを接続する方法を学びました。
- [AudioProcessorPlayer](https://docs.juce.com/master/classAudioProcessorPlayer.html "An AudioIODeviceCallback object which streams audio through an AudioProcessor.")を使用してグラフからスタンドアロンアプリを作成しました。

## 関連項目

- [チュートリアル：プラグインパラメータの追加](../tutorial_audio_parameter/)
- [チュートリアル：プラグイン状態の保存と読み込み](../tutorial_audio_processor_value_tree_state/)
- [チュートリアル：プラグインの正しいバスレイアウトの設定](../tutorial_audio_bus_layouts/)
