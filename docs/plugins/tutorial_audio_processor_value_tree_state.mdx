---
title: プラグイン状態の保存と読み込み
sidebar_position: 2
---

import CaptionImage from "@site/src/components/CaptionImage";
import SourcePageLink from "@site/src/components/SourcePageLink";

# チュートリアルプラグイン状態の保存と読み込み

プラグインパラメーターの自動管理パラメーターの保存とアクセスが簡単になり、特に効果的なユーザーインターフェースの構築がより簡単になります。

レベル Intermediate

プラットフォーム Windows, macOS, Linux

クラス： [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state."), [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ..."), [XmlElement](https://docs.juce.com/master/classXmlElement "Used to build a tree of elements representing an XML document.")

# Getting started

Download the demo project for this tutorial here: [ピップ](/tutorials/PIPs/AudioProcessorValueTreeStateTutorial.zip) | [ジップ](/tutorials/ZIPs/AudioProcessorValueTreeStateTutorial.zip). Unzip the project and open the first header file in the Projucer.

If you need help with this step, see [チュートリアルProjucerパート1：Projucerを始める](../tutorial_new_projucer_project/).

You should also know how to build an audio plug-in using JUCE and load this into your preferred audio host (such as a Digital Audio Workstation). See [チュートリアル基本的なAudio/MIDIプラグインを作る, パート1：セットアップ](../tutorial_create_projucer_basic_plugin/) for an introduction. Ideally, you should also have read [チュートリアルプラグインパラメータの追加](../tutorial_audio_parameter/), as an introduction to audio processor parameters.

# The demo project

The demo project is loosely based on the *ゲインプラグイン* project in the `JUCE/examples/Plugins` directory. This plugin changes the gain of an incoming signal using a single parameter. In addition to this, it also has a phase invert\* parameter to invert the phase of the incoming signal.

# The gain processor

Most of the code in the `チュートリアルプロセッサー` class is the same as that generated by the Projucer when you use the **オーディオプラグイン** project template. For simplicity, we have bundled the processor code into a single `.h` file rather than being split across a `.cpp` and an `.h` file. The editor for the processor is in the `ジェネリックエディター` class.

There are several advantages to using the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class for managing your plug-in's parameters:

-   The [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") class inherently provides undo support.
-   [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") objects already have support for serialising and deserialising (to XML).
-   [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") objects can have listeners attached to them. This means that the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class can almost automatically connect to sliders and buttons to keep the state of the UI and the processor up-to-date in a thread safe manner.

To use an [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object, you can store one in your processor class:

```
プライベート：
    //==============================================================================
    juce::AudioProcessorValueTreeState パラメータ；
```

You may store your [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object elsewhere but you must be careful that each [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object must be:

-   1つのプロセッサにのみ接続される
-   プロセッサーと同じライフタイムを持つ（お互いに依存関係があるため）。

Storing the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object in the processor class makes it easier to ensure that you satisfy these requirements.

The [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") constructor requires a reference to the [オーディオプロセッサ](https://docs.juce.com/master/classAudioProcessor "Base class for audio processing classes or plugins.") subclass that it will be attached to, a pointer to an [UndoManager](https://docs.juce.com/master/classUndoManager "Manages a list of undo/redo commands.") object, an [特定する](https://docs.juce.com/master/classIdentifier "Represents a string identifier, designed for accessing properties by name.") for the [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") and an [AudioProcessorValueTreeState::ParameterLayout](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ParameterLayout "A class to contain a set of RangedAudioParameters and AudioProcessorParameterGroups containing Ranged...") containing the parameters to manage.

```
AudioProcessorValueTreeState（AudioProcessor&processorToConnectTo、
                              UndoManager* undoManagerToUse、
                              const juce::Identifier& valueTreeType、
                              ParameterLayout parameterLayout)；
AudioProcessorValueTreeStateこのクラスには、AudioProcessor全体の状態を管理するために使用されるValueTreeが含まれています。定義 juce_AudioProcessorValueTreeState.h:115
AudioProcessorBase オーディオ処理クラスまたはプラグイン用のクラスです。定義 juce_AudioProcessor.h:51
UndoManagerアンドゥ/リドゥコマンドのリストを管理します。定義 juce_UndoManager.h:55
```

In this case, we will use a `ヌルプトル` value for the [UndoManager](https://docs.juce.com/master/classUndoManager "Manages a list of undo/redo commands.") object as we're not going to implement undo support in this tutorial. The `ヌルプトル` value indicates that we do not want to use undo support.

## Configuring the parameters

The [AudioProcessorValueTreeState::ParameterLayout](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ParameterLayout "A class to contain a set of RangedAudioParameters and AudioProcessorParameterGroups containing Ranged...") parameter of the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") contains the parameters of our plug-in. The [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") can manage any parameters derived from [RangedAudioParameter](https://docs.juce.com/master/classRangedAudioParameter "This abstract base class is used by some AudioProcessorParameter helper classes."), and the [AudioProcessorValueTreeState::ParameterLayout](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ParameterLayout "A class to contain a set of RangedAudioParameters and AudioProcessorParameterGroups containing Ranged...") constructor can take a variable number of [RangedAudioParameter](https://docs.juce.com/master/classRangedAudioParameter "This abstract base class is used by some AudioProcessorParameter helper classes.") subclasses or AudioProcessorParameterGroups containing RangedAudioParameters.

APVTSがパラメータとグループの所有権を持つため、パラメータとグループはstd::unique\_ptrを使って渡される。

JUCE's built-in parameter types, the same ones we used in [チュートリアルプラグインパラメータの追加](../tutorial_audio_parameter/), are subclasses of [RangedAudioParameter](https://docs.juce.com/master/classRangedAudioParameter "This abstract base class is used by some AudioProcessorParameter helper classes."), so we can use them here too.

```
    TutorialProcessor()
        : parameters (*this, nullptr, juce::Identifier ("APVTSTutorial"),
                      {
                          std::make_unique ("gain",            // parameterID
                                                                       "Gain",            // parameter name
                                                                       0.0f,              // minimum value
                                                                       1.0f,              // maximum value
                                                                       0.5f),             // default value
                          std::make_unique("invertPhase", // parameterID
                                                                      "Invert Phase", // パラメータ名
                                                                      false) // デフォルト値
                      })
    {
```

Adding your parameters to an [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") automatically adds them to the attached [オーディオプロセッサ](https://docs.juce.com/master/classAudioProcessor "Base class for audio processing classes or plugins.") too.

The *パラメータID* should be a unique identifier for this parameter. Think of this like a variable name; it can contain alphanumeric characters and underscores, but no spaces. The *パラメータ名* is the name that will be displayed on the screen.

## Performing the gain processing

To help avoid clicks in the signal, we smooth gain changes and changes in signal phase. To do this, we store the previously calculated gain value in our processor \[1\]:

```
private:
    //==============================================================================
    juce::AudioProcessorValueTreeState parameters;
    float previousGain; // [1]
 
    std::atomic* phaseParameter = nullptr;
    std::atomic* gainParameter = nullptr；
 
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TutorialProcessor)
};
```

また、コンストラクタの最後にパラメータへのポインタを保存しておき、後でそれらを再参照できるようにしておく：

```
phaseParameter = parameters.getRawParameterValue ("invertPhase")；
        gainParameter = parameters.getRawParameterValue ("gain")；
```

The changes are initialised in the `チュートリアルプロセッサ::prepareToPlay()` function:

```
void prepareToPlay (double, int) override
    {
        auto phase = *phaseParameter < 0.5f ?1.0f : -1.0f；
        previousGain = *gainParameter * phase；
    }
```

Here we calculate the phase inversion factor (+1 or -1) and multiply this by the gain, ready for the first processing callback. You can see that we use the [AudioProcessorValueTreeState::getRawParameterValue()](classAudioProcessorValueTreeState.html#a645123ccd146258f28d77b6095169c91 "Returns a pointer to a floating point representation of a particular parameter which a realtime proce...") function to get a pointer to the `フロート` value representing the parameter value. We dereference this to get the actual value. The processing is performed in the `TutorialProcessor::processBlock()` function:

```
void processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&) override
    {
        auto phase = *phaseParameter < 0.5f ?1.0f : -1.0f；
        auto currentGain = *gainParameter * phase；
 
        if (juce::approximatelyEqual (currentGain, previousGain))
        {
            buffer.applyGain (currentGain)；
        }
        else
        {
            buffer.applyGainRamp (0, buffer.getNumSamples(), previousGain, currentGain)；
            previousGain = currentGain；
        }
    }
```

Here you can see that if the value hasn't changed, then we simply apply a constant gain. If the value has changed, then we apply the gain ramp, then update the `前ゲイン` value for next time.

## Storing and retrieving parameters

In addition to providing routines for processing audio you also need to provide methods for storing and retrieving the *全体* state of your plug-in into a block of memory. This should include the current values of all of your parameters, but it can also include other state information if needed (for example, if your plug-in deals with files, it might store the file paths).

Using an [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object to store your plug-in's state makes this really simple as a [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") object can easily be converted to and from XML.

The [AudioProcessor::getStateInformation()](classAudioProcessor.html#a5d79591b367a7c0516e4ef4d1d6c32b2 "The host will call this method when it wants to save the processor's internal state.") callback asks your plug-in to store its state into a [メモリーブロック](https://docs.juce.com/master/classMemoryBlock "A class to hold a resizable block of raw data.") object. To do this using XML via the [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") object the code is simply:

```
    void getStateInformation (juce::MemoryBlock& destData) override
    {
        auto state = parameters.copyState();
        std::unique_ptrxml (state.createXml())；
        copyXmlToBinary (*xml, destData)；
    }
```

The [XmlElement](https://docs.juce.com/master/classXmlElement "Used to build a tree of elements representing an XML document.") object created will have a *タグ名* of "APVTSTutorial", which we used to initialise the [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") object earlier.

XMLから状態を復元するのは、ほとんど簡単だ：

```
    void setStateInformation (const void* data, int sizeInBytes) override
    {
        std::unique_ptrxmlState (getXmlFromBinary (data, sizeInBytes))；
 
        if (xmlState.get() != nullptr)
            if (xmlState->hasTagName (parameters.state.getType()))
                parameters.replaceState (juce::ValueTree::fromXml (*xmlState))；
    }
```

Here we include some error checking for safety. We also check that the ValueTree-generated XML is of the correct [バリューツリー](https://docs.juce.com/master/classValueTree "A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...") *タイプ* for our plug-in by inspecting the XML element's *タグ名*.

# The gain editor

Take a look at the `ジェネリックエディター` class in the project. You might notice that the declaration of the `ジェネリックエディター` class is very simple:

```
クラス GenericEditor : public juce::AudioProcessorEditor
{
public：
```

You might expect that we would need to inherit from the [スライダー::リスナー](https://docs.juce.com/master/classSlider_1_1Listener "A class for receiving callbacks from a Slider.") class and the [ボタン::リスナー](https://docs.juce.com/master/classButton_1_1Listener "Used to receive callbacks when a button is clicked.") class in order to respond to slider and button interaction. But this is again one of the benefits of using the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class. Instead we can use the *添付ファイル* classes within the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class.

## Component attachments

In fact, as the names of these classes can become very long, we have included a `typedef` for each of the attachment classes we need:

```
typedef juce::AudioProcessorValueTreeState::SliderAttachment スライダーアタッチメント；
    typedef juce::AudioProcessorValueTreeState::ButtonAttachment ボタンアタッチメント；
```

Our `ジェネリックエディター` class contains a number of members, including a slider, a toggle button, and some of these attachment objects:

```
private:
    juce::AudioProcessorValueTreeState& valueTreeState;
 
    juce::Label gainLabel;
    juce::Slider gainSlider;
    std::unique_ptr gainAttachment;
 
    juce::ToggleButton invertButton;
    std::unique_ptrinvertAttachment；
};
```

We also need to refer to the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") object so we also keep a reference to that.

The constructor for our `ジェネリックエディター` class sets up these objects:

```
GenericEditor (juce::AudioProcessor& parent, juce::AudioProcessorValueTreeState& vts)
        : AudioProcessorEditor (parent)、
          valueTreeState (vts)
    {
        gainLabel.setText ("Gain", juce::dontSendNotification)；
        addAndMakeVisible (gainLabel)；
 
        addAndMakeVisible (gainSlider)；
        gainAttachment.reset (new SliderAttachment (valueTreeState, "gain", gainSlider))；
 
        invertButton.setButtonText ("Invert Phase")；
        addAndMakeVisible (invertButton)；
        invertAttachment.reset (new ButtonAttachment (valueTreeState, "invertPhase", invertButton))；
 
        setSize (paramSliderWidth + paramLabelWidth, juce::jmax (100, paramControlHeight * 2))；
    }
```

This is called by our processor's `TutorialProcessor::createEditor()` function:

You may notice that we don't even need to set up the slider's value range. This is done automatically by the [スライダー・アタッチメント](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1SliderAttachment) class. All we need to do is pass the *添付ファイル* constructor the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state."), the *パラメータID* and the [スライダー](https://docs.juce.com/master/classSlider "A slider control for changing a value.") object that it should attach to.

:::note

We still retain ownership of the [スライダー](https://docs.juce.com/master/classSlider "A slider control for changing a value.") object. You should ensure that the *添付ファイル* class has the same lifetime as the [スライダー](https://docs.juce.com/master/classSlider "A slider control for changing a value.") object.

:::

The [ボタンアタッチメント](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ButtonAttachment) class still requires us to provide the button name. (And the [AudioProcessorValueTreeState::ComboBoxAttachment](https://docs.juce.com/master/classAudioProcessorValueTreeState_1_1ComboBoxAttachment "An object of this class maintains a connection between a ComboBox and a parameter in an AudioProcesso...") class, which can attach to a [コンボボックス](https://docs.juce.com/master/classComboBox "A component that lets the user choose from a drop-down list of choices.") object, requires us to populate the [コンボボックス](https://docs.juce.com/master/classComboBox "A component that lets the user choose from a drop-down list of choices.") manually.)

-   プラグインを2チャンネルのメインバスのみに対応するように変更し、オプションで左右のチャンネルを入れ替えることができるチャンネルスワップパラメーターを追加する。
-   再び2チャンネル専用プラグインを使い、左右のチャンネルレベルをバランスさせるバランスパラメーターを追加します。

# Adding Parameters Programatically

You can also add parameters (or AudioProcessorParameterGroups) to an [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") programatically, by calling `追加` on it. An example of how to do this is shown below:

```
juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
{
    juce::AudioProcessorValueTreeState::ParameterLayout params;
 
    for (int i = 1; i < 9; ++i)
        params.add (std::make_unique(文字列 (i), 文字列 (i), 0, i, 0）；
 
    params を返します；
}
 
YourAudioProcessor()
    : parameters (*this, nullptr, "PARAMETERS", createParameterLayout())
{
    //...
StringJUCEのStringクラス！定義 juce_String.h:56
```

# Deprecated Methods

Before JUCE version 5.4 the only way to add parameters to an [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") was to use the now deprecated createAndAddParameter method with many function parameters.

以前は次のようなコードだった。

```
createAndAddParameter (paramID1, paramName1, ...)；
```

と書き換えることができる。

```
using Parameter = juce::AudioProcessorValueTreeState::Parameter;
createAndAddParameter (std::make_unique(paramID1、paramName1、...))；
```

but using the new [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") constructor described in this tutorial is a much better approach:

```
using Parameter = AudioProcessorValueTreeState::Parameter;
YourAudioProcessor()
    : apvts (*this, nullptr, "PARAMETERS", { std::make_unique (paramID1, paramName1, ...),
                                             std::make_unique(paramID2, paramName2, ...)、
                                             ...})
AudioProcessorValueTreeState::Parameter非推奨AudioProcessorValueTreeStateとの後方互換性を維持するパラメータクラス...定義 juce_AudioProcessorValueTreeState.h:450
```

# Summary

In this tutorial we have introduced the [オーディオプロセッサ値ツリー状態](https://docs.juce.com/master/classAudioProcessorValueTreeState "This class contains a ValueTree that is used to manage an AudioProcessor's entire state.") class and shown how it can help you to:

-   プラグインのパラメータを管理します。
-   XMLを使用してプラグインの状態を保存および取得します。
-   スレッドセーフな方法でプラグインパラメータをボタンやスライダに接続します。

# See also

-   [チュートリアルプラグインパラメータの追加](../tutorial_audio_parameter/)
-   [チュートリアルプラグインに適切なバスレイアウトを設定する](../tutorial_audio_bus_layouts/)
-   [チュートリアルValueTreeクラス](../tutorial_value_tree/)
-   [チュートリアルカスケードプラグインエフェクト](../tutorial_audio_processor_graph/)