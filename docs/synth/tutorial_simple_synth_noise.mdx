---
title: ホワイトノイズジェネレーターの構築
sidebar_position: 1
tags: [中級]
---

# チュートリアル: ホワイトノイズジェネレーターの構築

<SourcePageLink path="tutorial_simple_synth_noise" />

このチュートリアルでは、シンプルな音声合成と音声出力について紹介します。これは、JUCEにおけるオーディオアプリケーション(およびプラグイン)の概念を理解するための鍵となります。

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices."), [AudioSourceChannelInfo](# "Used by AudioSource::getNextAudioBlock()."), [AudioBuffer](https://docs.juce.com/master/classAudioBuffer.html "A multi-channel buffer containing floating point audio samples."), [Random](https://docs.juce.com/master/classRandom.html "A random number generator.")

## はじめに

このチュートリアルのデモプロジェクトをダウンロードしてください: [PIP](https://docs.juce.com/tutorials/PIPs/SimpleSynthNoiseTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/SimpleSynthNoiseTutorial.zip)。プロジェクトを解凍し、Projucerで最初のヘッダーファイルを開いてください。

この手順でヘルプが必要な場合は、[Tutorial: Projucer Part 1: Getting started with the Projucer](../../getting-started/tutorial_new_projucer_project/)を参照してください。

このチュートリアルでは、デジタルオーディオの基本原理に精通していることを前提としています。特に、サンプリングを使用して音声信号がどのように表現されるかを知っておく必要があります。また、この文脈における*サンプルレート*(サンプリングレート、サンプリング周波数、または他の類似の用語として知られている可能性があります)の概念にも精通している必要があります。

## デモプロジェクト

このデモプロジェクトは、[The Projucer](https://juce.com/projucer)の**Audio Application**テンプレートを使用して作成されました。

<CaptionImage
  src="/_images/tutorial_simple_synth_noise_screenshot1.png"
  caption="The Audio Application template shown highlighted within The Projucer."
/>

これは、JUCE で独自のオーディオアプリケーションを作成するための便利な出発点です。このデモプロジェクトは、ホワイトノイズを合成し、ターゲットデバイスのデフォルトのオーディオハードウェアから再生します。

## Audio Applicationテンプレート

このチュートリアルでは、音声出力のみを実装します。音声入力と音声入力データのリアルタイムオーディオ処理については、他のチュートリアルで説明します。Audio ApplicationテンプレートはGUI Applicationテンプレートと非常に似ていますが、以下の点が異なります:

- `MainContentComponent`クラスは、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスではなく、[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")クラスを継承します。
- デフォルトでプロジェクトに追加される他のオーディオ関連モジュールに加えて、`juce_audio_utils`モジュールがプロジェクトに追加されます。

Audio Applicationテンプレートは、ここで提供される例のようなシンプルなアプリケーションに使用できます。また、より複雑なアプリケーション、つまりターゲットデバイスのオーディオハードウェアと直接対話する必要があるアプリケーションにもスケーラブルです。JUCEでオーディオプラグインを作成することについては、他のチュートリアルで説明します。

### オーディオアプリケーションのライフサイクル

[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")クラスは抽象基底クラスであり、派生クラスで*必ず*実装する必要があるオーディオアプリケーションのライフサイクルを表す3つの[純粋仮想](http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/)関数があります:

- [AudioAppComponent::prepareToPlay()](https://docs.juce.com/master/classAudioAppComponent.html#a70634aa3ffaf6e7ff0d233e5933a063d "Tells the source to prepare for playing."): これは、音声処理が開始される直前に呼び出されます。
- [AudioAppComponent::releaseResources()](https://docs.juce.com/master/classAudioAppComponent.html#a588d9b990fc308774215548959e0fc50 "Allows the source to release anything it no longer needs after playback has stopped."): これは、音声処理が終了したときに呼び出されます。
- [AudioAppComponent::getNextAudioBlock()](https://docs.juce.com/master/classAudioAppComponent.html#aec5e36e694a5bd2edae903d1079166b1 "Called repeatedly to fetch subsequent blocks of audio data."): これは、オーディオハードウェアが新しい音声データのブロックを必要とするたびに呼び出されます。

これら3つのうち、最も重要なのはおそらく[AudioAppComponent::getNextAudioBlock()](https://docs.juce.com/master/classAudioAppComponent.html#aec5e36e694a5bd2edae903d1079166b1 "Called repeatedly to fetch subsequent blocks of audio data.")です。これは、JUCEオーディオアプリケーションで音声を生成または処理する場所だからです。これがどのように機能するかを理解するには、最新のコンピュータがどのように音声を生成するかについて少し知る必要があります。オーディオハードウェアは、1秒間の音声ごとにチャンネルあたり一定数のサンプルを生成する必要があります。CD品質のサンプルレートは44.1kHzです。つまり、再生のためにオーディオハードウェアに送信される必要があるサンプルは、チャンネルあたり1秒あたり44100サンプルです。サンプルは1つずつオーディオハードウェアに渡されるのではなく、一定数のサンプルを含むバッファ(またはブロック)で渡されます。たとえば、44.1kHzでブロックサイズが441の場合、[AudioAppComponent::getNextAudioBlock()](https://docs.juce.com/master/classAudioAppComponent.html#aec5e36e694a5bd2edae903d1079166b1 "Called repeatedly to fetch subsequent blocks of audio data.")関数は1秒あたり100回呼び出されます。

:::tip
上記の441サンプルのバッファサイズは、説明のために算術をシンプルに保つために使用されています。実際には、441のバッファサイズは珍しいでしょう。ハードウェアバッファサイズはほぼ確実に偶数であり、2の累乗(256、512、1024など)になる傾向があります。アプリケーションが*任意の*バッファサイズに対応できるように準備することが重要です。サンプルレートとバッファサイズの設定の詳細については、[Tutorial: The AudioDeviceManager class](../../audio/tutorial_audio_device_manager/)を参照してください。
:::

本質的に、[AudioAppComponent::getNextAudioBlock()](https://docs.juce.com/master/classAudioAppComponent.html#aec5e36e694a5bd2edae903d1079166b1 "Called repeatedly to fetch subsequent blocks of audio data.")は、オーディオハードウェアの*オーディオコールバック*にサービスを提供しています。この関数は別のスレッド(ほとんどの場合*オーディオスレッド*)から呼び出されることに注意することが重要です。

JUCEオーディオアプリケーションが正しく動作するためには、さらに2つの重要な関数があります。今回は、実装するのではなく、呼び出す必要があります:

- [AudioAppComponent::setAudioChannels()](https://docs.juce.com/master/classAudioAppComponent.html#a1cb6b457848fa80df7efc39cf095d465 "A subclass should call this from their constructor, to set up the audio."): 必要な入出力チャンネル数を登録するために、これを呼び出す必要があります。通常、これはコンストラクタで行います。この関数は、アプリケーションでの音声処理の開始をトリガーします。
- [AudioAppComponent::shutdownAudio()](https://docs.juce.com/master/classAudioAppComponent.html#a40f1e657f048d02c5d065de566a84d92 "Shuts down the audio device and clears the audio source."): オーディオシステムをシャットダウンするために、これを呼び出す必要があります。通常、これはデストラクタで行います。

### オーディオアプリケーションの初期化

それでは、オーディオアプリケーションのライフサイクルをより詳細に調べて、ノイズジェネレーターのシンプルな実装を見てみましょう。コンストラクタでは、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")オブジェクトのサイズを設定する必要があります([Tutorial: The main component](../../graphics/tutorial_main_component/)を参照)。また、少なくとも1つの音声出力を初期化する必要があります:

```cpp
MainContentComponent()
{
    setSize (800, 600);
    setAudioChannels (0, 2); // no inputs, two outputs
}
```

前述のように、[AudioAppComponent::setAudioChannels()](https://docs.juce.com/master/classAudioAppComponent.html#a1cb6b457848fa80df7efc39cf095d465 "A subclass should call this from their constructor, to set up the audio.")関数の呼び出しは、オーディオシステムの起動をトリガーします。特に、`prepareToPlay()`関数を呼び出します:

```cpp
void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override
{
    juce::String message;
    message << "Preparing to play audio...\\n";
    message << " samplesPerBlockExpected = " << samplesPerBlockExpected << "\\n";
    message << " sampleRate = " << sampleRate;
    juce::Logger::getCurrentLogger()->writeToLog (message);
}
```

ここでは、デバッグのためにいくつかの情報を標準出力にログ出力します。[AudioAppComponent::prepareToPlay()](https://docs.juce.com/master/classAudioAppComponent.html#a70634aa3ffaf6e7ff0d233e5933a063d "Tells the source to prepare for playing.")関数は、オーディオ処理の開始の準備をするための良い場所です。たとえば、音声処理に必要なリソースを割り当てることができます。

### 音声の表現

デジタルオーディオシステムでは、音声は通常、浮動小数点値として表現され、値±1.0で最大振幅に達します。たとえば、フルスケールのサイン波は次のようになります:

<CaptionImage
  src="/_images/tutorial_simple_synth_noise_graph1.png"
  caption="A full scale ±1.0 sine wave."
/>

このような±1.0のピークレベルでは、出力レベルは*非常に*大きくなります。実際、これはクリッピングなしでオーディオシステムが生成できる最大の音量です。通常、この±1.0の制限を超えない音声を出力する必要があります(ただし、最終出力が低い限り、処理の中間段階がこの制限を超えても問題ありません)。

### AudioSampleBufferクラス

AudioSampleBufferクラスは(非常に基本的なレベルでは)`float`値のマルチチャンネル配列に過ぎませんが、音声データを扱うための便利な関数セットを提供します。これらの関数の多くは後のチュートリアルで取り上げられますが、ここでは以下の関数を使用します:

- [AudioSampleBuffer::getNumChannels()](https://docs.juce.com/master/classAudioBuffer.html#a3a9ecde91bf5b96871ce3a474c1d831f): これは、バッファに格納されているオーディオチャンネルの数を返します。この場合、値は、先に[AudioAppComponent::setAudioChannels()](https://docs.juce.com/master/classAudioAppComponent.html#a1cb6b457848fa80df7efc39cf095d465 "A subclass should call this from their constructor, to set up the audio.")関数の呼び出しで要求した出力チャンネル数と一致するはずです。(この値は常に入力チャンネル数と出力チャンネル数の最大値になります。)
- [AudioSampleBuffer::getWritePointer()](https://docs.juce.com/master/classAudioBuffer.html#a10cfe91eb4965895bc258cee02409d3b): これは、特定のサンプルオフセットでの`float`値のバッファへのポインタを返します。

ホワイトノイズを生成するシンプルなアプリケーションでは、バッファの要求されたセクションをランダムな値で埋める必要があります。これを行うには、バッファ内のチャンネルを反復処理し、そのチャンネルのバッファ内の開始サンプルを見つけ、目的のサンプル数をバッファに書き込みます:

```cpp
void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override
{
    for (auto channel = 0; channel < bufferToFill.buffer->getNumChannels(); ++channel)
    {
        // Get a pointer to the start sample in the buffer for this audio output channel
        auto* buffer = bufferToFill.buffer->getWritePointer (channel, bufferToFill.startSample);

        // Fill the required number of samples with noise between -0.125 and +0.125
        for (auto sample = 0; sample < bufferToFill.numSamples; ++sample)
            buffer[sample] = random.nextFloat() * 0.25f - 0.125f;
    }
}
```

### Randomクラスを使用したホワイトノイズの生成

ここでは、ランダムな値を生成するために[Random](https://docs.juce.com/master/classRandom.html "A random number generator.")クラスを使用します([Tutorial: The Random class](../../utility-classes/tutorial_random/)を参照)。ホワイトノイズを生成するには、ゼロを中心に一様分布するランダムな数値を生成する必要があります。ここでは、まず[Random::nextFloat()](https://docs.juce.com/master/classRandom.html#aec88d4e5cf44faaa038f6cfb41e96406 "Returns the next random floating-point number.")関数を呼び出して、-0.125から+0.125の間のランダムな値を生成します。これにより、0から1の間の値が生成されます。次に、この結果に0.25を掛けて0.125を引きます。(このプロセスの詳細については、[Tutorial: Control audio levels](../tutorial_synth_level_control/)を参照してください。)他のチュートリアル([Tutorial: The Random class](../../utility-classes/tutorial_random/)で示されているように、共有*システム*[Random](https://docs.juce.com/master/classRandom.html "A random number generator.")オブジェクトを取得するために[Random::getSystemRandom()](https://docs.juce.com/master/classRandom.html#ad7d9d42dd0efbb68d569e975b0778518 "The overhead of creating a new Random object is fairly small, but if you want to avoid it,...")関数を使用しなかったことに注意してください。これは、オーディオスレッドで[Random::nextFloat()](https://docs.juce.com/master/classRandom.html#aec88d4e5cf44faaa038f6cfb41e96406 "Returns the next random floating-point number.")関数を呼び出しているためです。独自の[Random](https://docs.juce.com/master/classRandom.html "A random number generator.")オブジェクトを作成する必要があります。そうしないと、他のスレッドがその共有[Random](https://docs.juce.com/master/classRandom.html "A random number generator.")オブジェクトを使用することで値が破損する可能性があります。これを実現するために、[Random](https://docs.juce.com/master/classRandom.html "A random number generator.")クラスのインスタンスを`MainContentComponent`クラスに追加します:

```cpp
private:
juce::Random random;

JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)
};
```

### オーディオアプリケーションのシャットダウン

アプリケーションが閉じられると、デストラクタが呼び出されます。この時点で、[AudioAppComponent::shutdownAudio()](https://docs.juce.com/master/classAudioAppComponent.html#a40f1e657f048d02c5d065de566a84d92 "Shuts down the audio device and clears the audio source.")関数を呼び出す必要があります:

```cpp
~MainContentComponent() override
{
    shutdownAudio();
}
```

[AudioAppComponent::shutdownAudio()](https://docs.juce.com/master/classAudioAppComponent.html#a40f1e657f048d02c5d065de566a84d92 "Shuts down the audio device and clears the audio source.")関数を呼び出すと、[AudioAppComponent::releaseResources()](https://docs.juce.com/master/classAudioAppComponent.html#a588d9b990fc308774215548959e0fc50 "Allows the source to release anything it no longer needs after playback has stopped.")関数が呼び出されます。これは、音声プロセスの実行中に割り当てたリソース(メモリを割り当てたり、ファイルを開いたりした場合など)を破棄するのに適した場所です。この場合、追加のリソースは必要なかったため、単純なメッセージで関数呼び出しをログに記録するだけです:

```cpp
void releaseResources() override
{
    juce::Logger::getCurrentLogger()->writeToLog ("Releasing audio resources");
}
```

:::note
演習: 音声出力の数を変更してみてください。モノラルノイズはステレオノイズとは微妙に異なって聞こえることに注意してください。マルチチャンネルサウンドカードをお持ちの場合、2チャンネル以上のノイズを生成できる可能性があります。また、生成されるノイズのレベルを変更してみることもできます。たとえば、レベル0.1でノイズを生成するには、ランダムに生成された値に0.2を掛けて0.1を引く必要があります。
:::

## まとめ

このチュートリアルでは、Audio Applicationテンプレートで使用される[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")クラスを使用して音声を生成する方法を紹介しました。以下のトピックを取り上げました:

- オーディオシステムの初期化とシャットダウン。
- オーディオコールバックに応答して音声データを書き込む。
- [AudioSourceChannelInfo](# "Used by AudioSource::getNextAudioBlock().")構造体とAudioSampleBufferクラスの使用。

## 関連項目

- [Tutorial: The AudioDeviceManager class](../../audio/tutorial_audio_device_manager/)
- [Tutorial: Build a sine wave synthesiser](../tutorial_sine_synth/)
- [Tutorial: Control audio levels using decibels](../tutorial_synth_db_level_control/)
- [Tutorial: Control audio levels](../tutorial_synth_level_control/)
- [Tutorial: Build a MIDI synthesiser](../tutorial_synth_using_midi_input/)
- [Tutorial: Wavetable synthesis](../tutorial_wavetable_synth/)
