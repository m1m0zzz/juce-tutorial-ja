---
title: MIDIシンセサイザーの構築
sidebar_position: 5
tags: [中級]
---

# チュートリアル: MIDIシンセサイザーの構築

<SourcePageLink path="tutorial_synth_using_midi_input" />

このチュートリアルでは、MIDI入力に応答するポリフォニックサイン波シンセサイザーを実装します。これは、[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")クラスと関連クラスを利用します。

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds."), [SynthesiserVoice](https://docs.juce.com/master/classSynthesiserVoice.html "Represents a voice that a Synthesiser can use to play a SynthesiserSound."), [SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play."), [AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio."), [MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...")

## はじめに

:::tip
JUCEでのMIDI入力の処理とサイン波の生成方法に精通している必要があります。[Tutorial: Handling MIDI events](../../midi/tutorial_handling_midi_events/)と[Tutorial: Build a sine wave synthesiser](../tutorial_sine_synth/)を参照してください。
:::

このチュートリアルのデモプロジェクトをダウンロードしてください: [PIP](https://docs.juce.com/tutorials/PIPs/SynthUsingMidiInputTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/SynthUsingMidiInputTutorial.zip)。プロジェクトを解凍し、Projucerで最初のヘッダーファイルを開いてください。

この手順でヘルプが必要な場合は、[Tutorial: Projucer Part 1: Getting started with the Projucer](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

このデモプロジェクトは、シンプルなサイン波シンセサイザーを演奏するために使用できる画面上のキーボードを表示します。

<CaptionImage
  src="/_images/tutorial_synth_using_midi_input_screenshot1.png"
  caption="The application window containing a MidiKeyboardComponent"
/>

コンピュータキーボードのキー(A、S、D、Fなどのキーを使用して音楽ノートC、D、E、Fなどを制御)を使用して、画面上のキーボードを制御できます。これにより、シンセサイザーをポリフォニックに演奏できます。

## Synthesiserクラス

このチュートリアルでは、JUCE [Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")クラスを使用してポリフォニックシンセサイザーを実装します。これは、独自のアプリケーションで独自のサウンドでシンセサイザーをカスタマイズするために必要なすべての基本要素を示しています。これを機能させるために必要なさまざまなクラスがあり、標準の`MainContentComponent`クラスに加えて、これらは次のとおりです:

- `SynthAudioSource`: これは、[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")クラス自体を含む、`SynthAudioSource`と呼ばれるカスタム[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスを実装します。これは、シンセサイザーからのすべての音声を出力します。
- `SineWaveVoice`: これは、`SineWaveVoice`と呼ばれるカスタム[SynthesiserVoice](https://docs.juce.com/master/classSynthesiserVoice.html "Represents a voice that a Synthesiser can use to play a SynthesiserSound.")クラスです。ボイスクラスは、[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")オブジェクト内の他の鳴っているボイスとミックスして、シンセサイザーのボイスの1つをレンダリングします。ボイスクラスの単一のインスタンスは、1つのボイスをレンダリングします。
- `SineWaveSound`: これには、`SineWaveSound`と呼ばれるカスタム[SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play.")クラスが含まれています。サウンドクラスは、ボイスとして作成できるサウンドの説明です。たとえば、これにはサンプラーボイスのサンプルデータやウェーブテーブルシンセサイザーのウェーブテーブルデータが含まれる場合があります。

### キーボードのセットアップ

`MainContentComponent`クラスには、次のデータメンバーが含まれています。

```cpp
juce::MidiKeyboardState keyboardState;
SynthAudioSource synthAudioSource;
juce::MidiKeyboardComponent keyboardComponent;

JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)
};
```

`synthAudioSource`と`keyboardComponent`メンバーは、`MainContentComponent`コンストラクタで初期化されます。

```cpp
MainContentComponent()
    : synthAudioSource (keyboardState),
      keyboardComponent (keyboardState, juce::MidiKeyboardComponent::horizontalKeyboard)
{
    addAndMakeVisible (keyboardComponent);
    setAudioChannels (0, 2);

    setSize (600, 160);
    startTimer (400);
}
```

[MidiKeyboardComponent](https://docs.juce.com/master/classMidiKeyboardComponent.html "A component that displays a piano keyboard, whose notes can be clicked on.")クラスの詳細については、[Tutorial: Handling MIDI events](../../midi/tutorial_handling_midi_events/)を参照してください。

アプリケーションの開始直後にコンピュータのキーボードからキーボードを演奏できるように、キーボードフォーカスを取得します。これを行うために、400ms後に起動するシンプルなタイマーを使用します:

```cpp
void timerCallback() override
{
    keyboardComponent.grabKeyboardFocus();
    stopTimer();
}
```

### AudioAppComponent関数

アプリケーションは、[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")を使用してシンプルなオーディオアプリケーションをセットアップします(最も基本的なアプリケーションについては、[Tutorial: Build a white noise generator](../tutorial_simple_synth_noise/)を参照してください)。必要な3つの[純粋仮想](http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/)関数は、カスタム[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスの対応する関数を呼び出すだけです:

```cpp
void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override
{
    synthAudioSource.prepareToPlay (samplesPerBlockExpected, sampleRate);
}

void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override
{
    synthAudioSource.getNextAudioBlock (bufferToFill);
}

void releaseResources() override
{
    synthAudioSource.releaseResources();
}
```

### SynthAudioSourceクラス

`SynthAudioSource`クラスは、もう少し作業を行います:

```cpp
class SynthAudioSource : public juce::AudioSource
{
public:
    SynthAudioSource (juce::MidiKeyboardState& keyState)
        : keyboardState (keyState)
    {
        for (auto i = 0; i < 4; ++i) // [1]
            synth.addVoice (new SineWaveVoice());

        synth.addSound (new SineWaveSound()); // [2]
    }

    void setUsingSineWaveSound()
    {
        synth.clearSounds();
    }

    void prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate) override
    {
        synth.setCurrentPlaybackSampleRate (sampleRate); // [3]
    }

    void releaseResources() override {}

    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override
    {
        bufferToFill.clearActiveBufferRegion();

        juce::MidiBuffer incomingMidi;
        keyboardState.processNextMidiBuffer (incomingMidi, bufferToFill.startSample, bufferToFill.numSamples, true); // [4]

        synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, bufferToFill.startSample, bufferToFill.numSamples); // [5]
    }

private:
    juce::MidiKeyboardState& keyboardState;
    juce::Synthesiser synth;
};
```

- \[1\]: シンセサイザーにいくつかのボイスを追加します。追加されたボイスの数によって、シンセサイザーのポリフォニーが決まります。
- \[2\]: シンセサイザーが再生できるサウンドを知ることができるように、サウンドを追加します。
- \[3\]: シンセサイザーは、音声出力のサンプルレートを知る必要があります。
- \[4\]: `getNextAudioBlock()`関数では、[MidiKeyboardState](https://docs.juce.com/master/classMidiKeyboardState.html "Represents a piano keyboard, keeping track of which keys are currently pressed.")オブジェクトからMIDIデータのバッファを取得します。
- \[5\]: これらのMIDIのバッファは、ノートオンおよびノートオフメッセージ(および他のMIDIチャンネルボイスメッセージ)のタイムスタンプを使用してボイスをレンダリングするために使用されるシンセサイザーに渡されます。

:::warning
[SynthesiserVoice](https://docs.juce.com/master/classSynthesiserVoice.html "Represents a voice that a Synthesiser can use to play a SynthesiserSound.")オブジェクトは、1つの[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")オブジェクトにのみ追加する必要があります。[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")オブジェクトは、ボイスの寿命を管理します。
:::

[SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play.")オブジェクトは、必要に応じて[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")オブジェクト間で共有できます。[SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play.")クラスは、[ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting.")クラスの一種であるため、[SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play.")オブジェクトの寿命は自動的に処理されます。

:::tip
[SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play.")オブジェクトへのポインタを保持する必要がある場合は、このメモリ管理が機能するように、`YourSoundClass::Ptr`変数に格納する必要があります。
:::

### SineWaveSoundクラス

サウンドクラスは非常にシンプルで、データを含む必要さえありません。特定のMIDIチャンネルとそのチャンネル上の特定のノートまたはノート範囲でこのサウンドを再生する必要があるかどうかを報告するだけです。シンプルなケースでは、`appliesToNote()`と`appliesToChannel()`関数の両方に対して`true`を返すだけです。前述のように、サウンドクラスは、サウンドを作成するために必要なデータ(ウェーブテーブルなど)を格納する場所である可能性があります。

```cpp
struct SineWaveSound : public juce::SynthesiserSound
{
    SineWaveSound() {}

    bool appliesToNote (int) override { return true; }
    bool appliesToChannel (int) override { return true; }
};
```

### サイン波ボイスの状態

`SineWaveVoice`クラスはもう少し複雑です。シンセサイザーのボイスの1つの状態を維持する必要があります。サイン波の場合、これらのデータメンバーが必要です:

```cpp
private:
    double currentAngle = 0.0, angleDelta = 0.0, level = 0.0, tailOff = 0.0;
};
```

最初の3つについては、[Tutorial: Build a sine wave synthesiser](../tutorial_sine_synth/)を参照してください。`tailOff`メンバーは、各ボイスに振幅エンベロープへのわずかにソフトな*リリース*を与えるために使用されます。これにより、各ボイスは急激に停止するのではなく、最後に少しフェードアウトします。

<CaptionImage
  src="/_images/tutorial_synth_using_midi_input_graph1.png"
  caption="Exponential release envelope"
/>

### 再生できるサウンドのチェック

[SynthesiserVoice::canPlaySound()](https://docs.juce.com/master/classSynthesiserVoice.html#aa9fb097ca96dc39fae8e6f7b9139df9f "Must return true if this voice object is capable of playing the given sound.")関数をオーバーライドして、ボイスがサウンドを再生できるかどうかを返す必要があります。この場合は単に`true`を返すこともできますが、この例では、渡されるサウンドクラスのタイプをチェックするために`dynamic_cast`を使用する方法を示しています。

```cpp
bool canPlaySound (juce::SynthesiserSound* sound) override
{
    return dynamic_cast<SineWaveSound*> (sound) != nullptr;
}
```

### ボイスの開始

ボイスは、[SynthesiserVoice::startNote()](https://docs.juce.com/master/classSynthesiserVoice.html#af3b872622dd9bb540030420189175762 "Called to start a new note.")関数を呼び出すことによって、所有するシンセサイザーによって開始されます。これをオーバーライドする必要があります:

```cpp
void startNote (int midiNoteNumber, float velocity, juce::SynthesiserSound*, int /*currentPitchWheelPosition*/) override
{
    currentAngle = 0.0;
    level = velocity * 0.15;
    tailOff = 0.0;

    auto cyclesPerSecond = juce::MidiMessage::getMidiNoteInHertz (midiNoteNumber);
    auto cyclesPerSample = cyclesPerSecond / getSampleRate();

    angleDelta = cyclesPerSample * 2.0 * juce::MathConstants<double>::pi;
}
```

これも、[Tutorial: Build a sine wave synthesiser](../tutorial_sine_synth/)からよく知っているはずです。`tailOff`値は、各ボイスの開始時にゼロに設定されます。また、MIDIノートオンイベントのベロシティを使用して、ボイスのレベルを制御します。

### ボイスのレンダリング

[SynthesiserVoice::renderNextBlock()](https://docs.juce.com/master/classSynthesiserVoice.html#a72ab7856c1e7651b1ce955388645a0a1 "Renders the next block of data for this voice.")関数をオーバーライドして、音声を生成する必要があります。

```cpp
void renderNextBlock (juce::AudioSampleBuffer& outputBuffer, int startSample, int numSamples) override
{
    if (angleDelta != 0.0)
    {
        if (tailOff > 0.0) // [7]
        {
            while (--numSamples >= 0)
            {
                auto currentSample = (float) (std::sin (currentAngle) * level * tailOff);

                for (auto i = outputBuffer.getNumChannels(); --i >= 0;)
                    outputBuffer.addSample (i, startSample, currentSample);

                currentAngle += angleDelta;
                ++startSample;

                tailOff *= 0.99; // [8]

                if (tailOff <= 0.005)
                {
                    clearCurrentNote(); // [9]

                    angleDelta = 0.0;
                    break;
                }
            }
        }
        else
        {
            while (--numSamples >= 0) // [6]
            {
                auto currentSample = (float) (std::sin (currentAngle) * level);

                for (auto i = outputBuffer.getNumChannels(); --i >= 0;)
                    outputBuffer.addSample (i, startSample, currentSample);

                currentAngle += angleDelta;
                ++startSample;
            }
        }
    }
}
```

- \[6\]: このループは、キーが押されている間のボイスの*通常*の状態で使用されます。[AudioSampleBuffer::addSample()](https://docs.juce.com/master/classAudioBuffer.html#ab46e9ad400252255daa1086b354454b8)関数を使用していることに注意してください。これは、`currentSample`値をインデックス`startSample`の値と混合します。これは、シンセサイザーがすべてのボイスを反復処理するためです。各ボイスは、出力をバッファの現在の内容とミックスする責任があります。
- \[7\]: キーが離されると、`tailOff`値はゼロより大きくなります。合成アルゴリズムは似ています。
- \[8\]: シンプルな指数減衰エンベロープ形状を使用します。
- \[9\]: `tailOff`値が小さい場合、ボイスが終了したと判断します。この時点で、ボイスがリセットされて再利用できるように、[SynthesiserVoice::clearCurrentNote()](https://docs.juce.com/master/classSynthesiserVoice.html#a55d1e7a062f8dc9a6cd78526b0da049c "Resets the state of this voice after a sound has finished playing.")関数を呼び出す*必要*があります。

:::warning
`startSample`引数に注意することは*非常に*重要です。シンセサイザーは、出力ブロックの途中で`renderNextBlock()`関数を呼び出す可能性が非常に高いです。これは、ノートが任意のサンプルで開始される可能性があるためです。これらの開始時間は、受信したMIDIデータのタイムスタンプに基づいています。
:::

### ボイスの停止

ボイスは、所有するシンセサイザーが[SynthesiserVoice::stopNote()](https://docs.juce.com/master/classSynthesiserVoice.html#ae1faf9289de24cdeb1d42289754601e6 "Called to stop a note.")関数を呼び出すことによって停止されます。これをオーバーライドする必要があります:

```cpp
void stopNote (float /*velocity*/, bool allowTailOff) override
{
    if (allowTailOff)
    {
        if (tailOff == 0.0)
            tailOff = 1.0;
    }
    else
    {
        clearCurrentNote();
        angleDelta = 0.0;
    }
}
```

これには、MIDIノートオフメッセージからのベロシティ情報が含まれる場合がありますが、多くの場合、これを無視できます。すぐにボイスを停止するように求められる場合があります。その場合、すぐに[SynthesiserVoice::clearCurrentNote()](https://docs.juce.com/master/classSynthesiserVoice.html#a55d1e7a062f8dc9a6cd78526b0da049c "Resets the state of this voice after a sound has finished playing.")関数を呼び出します。通常の状況では、シンセサイザーはボイスが自然に終了することを許可します。この場合、シンプルなテールオフエンベロープがあります。`tailOff`メンバーを`1.0`に設定することで、テールオフをトリガーします。

:::note
演習: ボイスが急激に開始しないように、ボイスにより遅いアタックを追加してみてください。
:::

## 外部MIDI入力の追加

画面上のキーボードに加えて、外部MIDIソースがシンセサイザーを制御できるように機能を追加しましょう。

:::warning
おそらく、モバイルプラットフォームではなく、macOS、Windows、Linuxなどのデスクトッププラットフォームのいずれかで試す必要があります。
:::

### SynthAudioSourceへのMIDI入力の提供

まず、`SynthAudioSource`クラスのメンバーとして[MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...")オブジェクトを追加します。これにより、MIDIメッセージを送信でき、`SynthAudioSource`クラスがそれらを使用できる場所が提供されます:

```cpp
juce::MidiMessageCollector midiCollector;
};
```

MIDIデータのタイムスタンプを処理するために、[MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...")クラスは音声サンプルレートを知る必要があります。これを`SynthAudioSource::prepareToPlay()`関数で設定します\[10\]:

```cpp
void prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate) override
{
    synth.setCurrentPlaybackSampleRate (sampleRate);
    midiCollector.reset (sampleRate); // [10]
}
```

次に、[MidiMessageCollector::removeNextBlockOfMessages()](https://docs.juce.com/master/classMidiMessageCollector.html#ac72b6cf4965e63b90d1a2402b73b1798 "Removes all the pending messages from the queue as a buffer.")関数を使用して、各音声ブロックのMIDIメッセージを取得できます\[11\]:

```cpp
void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override
{
    bufferToFill.clearActiveBufferRegion();

    juce::MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples); // [11]

    keyboardState.processNextMidiBuffer (incomingMidi, bufferToFill.startSample, bufferToFill.numSamples, true);

    synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, bufferToFill.startSample, bufferToFill.numSamples);
}
```

`SynthAudioSource`クラスの外部からこの[MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...")オブジェクトにアクセスする必要があるため、次のように`SynthAudioSource`クラスにアクセサを追加します:

```cpp
juce::MidiMessageCollector* getMidiCollector()
{
    return &midiCollector;
}
```

`MainContentComponent`クラスでは、この[MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...")オブジェクトを、アプリケーションの[AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.")オブジェクトに[MidiInputCallback](https://docs.juce.com/master/classMidiInputCallback.html "Receives incoming messages from a physical MIDI input device.")オブジェクトとして追加します。

### MIDI入力のリスト表示

ユーザーにMIDI入力デバイスのリストを表示するために、[Tutorial: Handling MIDI events](../../midi/tutorial_handling_midi_events/)のコードを使用します。`MainContentComponent`クラスにいくつかのメンバーを追加します:

```cpp
juce::ComboBox midiInputList;
juce::Label midiInputListLabel;
int lastInputIndex = 0;
```

次に、次のコードを`MainContentComponent`コンストラクタに追加します。

```cpp
addAndMakeVisible (midiInputListLabel);
midiInputListLabel.setText ("MIDI Input:", juce::dontSendNotification);
midiInputListLabel.attachToComponent (&midiInputList, true);

auto midiInputs = juce::MidiInput::getAvailableDevices();
addAndMakeVisible (midiInputList);
midiInputList.setTextWhenNoChoicesAvailable ("No MIDI Inputs Enabled");

juce::StringArray midiInputNames;
for (auto input : midiInputs)
    midiInputNames.add (input.name);

midiInputList.addItemList (midiInputNames, 1);
midiInputList.onChange = [this] { setMidiInput (midiInputList.getSelectedItemIndex()); };

for (auto input : midiInputs)
{
    if (deviceManager.isMidiInputDeviceEnabled (input.identifier))
    {
        setMidiInput (midiInputs.indexOf (input));
        break;
    }
}

if (midiInputList.getSelectedId() == 0)
    setMidiInput (0);
```

上記のコードで呼び出される`setMidiInput()`関数を追加します:

```cpp
void setMidiInput (int index)
{
    auto list = juce::MidiInput::getAvailableDevices();

    deviceManager.removeMidiInputDeviceCallback (list[lastInputIndex].identifier,
        synthAudioSource.getMidiCollector()); // [12]

    auto newInput = list[index];

    if (!deviceManager.isMidiInputDeviceEnabled (newInput.identifier))
        deviceManager.setMidiInputDeviceEnabled (newInput.identifier, true);

    deviceManager.addMidiInputDeviceCallback (newInput.identifier, synthAudioSource.getMidiCollector()); // [13]
    midiInputList.setSelectedId (index + 1, juce::dontSendNotification);

    lastInputIndex = index;
}
```

`SynthAudioSource`オブジェクトから[MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...")オブジェクトを、指定されたMIDI入力デバイスの[MidiInputCallback](https://docs.juce.com/master/classMidiInputCallback.html "Receives incoming messages from a physical MIDI input device.")オブジェクトとして追加していることに注意してください[13]。また、ユーザーがコンボボックスを使用して選択したデバイスを変更した場合に備えて、以前に選択したMIDI入力デバイスの以前の[MidiInputCallback](https://docs.juce.com/master/classMidiInputCallback.html "Receives incoming messages from a physical MIDI input device.")オブジェクトを削除する必要があります[12]。

`resized()`関数で、この[ComboBox](https://docs.juce.com/master/classComboBox.html "A component that lets the user choose from a drop-down list of choices.")オブジェクトを配置し、[MidiKeyboardComponent](https://docs.juce.com/master/classMidiKeyboardComponent.html "A component that displays a piano keyboard, whose notes can be clicked on.")オブジェクトの位置を調整する必要があります:

```cpp
void resized() override
{
    midiInputList.setBounds (200, 10, getWidth() - 210, 20);
    keyboardComponent.setBounds (10, 40, getWidth() - 20, getHeight() - 50);
}
```

アプリケーションを再度実行すると、次のように表示されるはずです:

<CaptionImage
  src="/_images/tutorial_synth_using_midi_input_screenshot2.png"
  caption="The application window showing the MIDI input device list"
/>

もちろん、リストされるデバイスは、特定のシステム構成によって異なります。

:::tip
このアプリケーションの変更版のソースコードは、デモプロジェクトの`SynthUsingMidiInputTutorial_02.h`ファイルにあります。
:::

:::note
演習: 各ボイスのテールオフの長さを制御するスライダーを追加してみてください。以前の演習でアタックを追加した場合は、アタックの長さを制御するスライダーも追加できます。
:::

## まとめ

このチュートリアルでは、[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")クラスを紹介しました。このチュートリアルを読んだ後、次のことができるようになります:

- 音声を生成するために[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")サブクラス内に[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")クラスをセットアップする。
- 適切な[SynthesiserVoice](https://docs.juce.com/master/classSynthesiserVoice.html "Represents a voice that a Synthesiser can use to play a SynthesiserSound.")および[SynthesiserSound](https://docs.juce.com/master/classSynthesiserSound.html "Describes one of the sounds that a Synthesiser can play.")クラスを作成し、[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")オブジェクトに追加する。
- 画面上のキーボードと外部MIDIソースからMIDIメッセージを[Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.")オブジェクトに送信する。

## 関連項目

- [Tutorial: Handling MIDI events](../../midi/tutorial_handling_midi_events/)
- [Tutorial: Build a white noise generator](../tutorial_simple_synth_noise/)
- [Tutorial: Build a sine wave synthesiser](../tutorial_sine_synth/)
- [Tutorial: Control audio levels using decibels](../tutorial_synth_db_level_control/)
- [Tutorial: Control audio levels](../tutorial_synth_level_control/)
- [Tutorial: Wavetable synthesis](../tutorial_wavetable_synth/)
