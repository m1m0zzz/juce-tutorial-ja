---
title: ファイル読み込み
sidebar_position: 3
tags: [初級]
---

# チュートリアル：ファイル読み込み

<SourcePageLink path="tutorial_file_reading" />

テキストファイルとバイナリファイルからデータを開いて読み込みます。

**レベル:** 初級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [File](https://docs.juce.com/master/classFile.html "Represents a local file or directory."), [FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file."), [FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se..."), [TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box."), [String](https://docs.juce.com/master/classString.html "The JUCE String class!"), [MemoryBlock](https://docs.juce.com/master/classMemoryBlock.html "A class to hold a resizable block of raw data.")

## はじめに

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/FileReadingTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/FileReadingTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルをProjucerで開いてください。

この手順についてサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucerを始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトは、[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")オブジェクトを使用してファイルを選択できるシンプルなウィンドウを表示します。このファイルは開かれ、文字列として読み込まれ、[TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box.")コンポーネントに表示されます。

## JUCEでのファイル操作

このチュートリアルでは、JUCEを使用したファイル読み込みの基本的な技術を説明します。ファイルはクロスプラットフォーム開発の一側面であり、異なるオペレーティングシステム上のファイルシステムは時として非常に異なる方法で動作するため、慎重に扱う必要があります。JUCEを使用する開発者としてこれらの問題から免除されるわけではありませんが、JUCEは異なるプラットフォーム間でより一貫した体験を提供し、デバッグビルドでコードが問題につながる可能性のある何かを行っていることを検出した場合、アサーションを発生させることがよくあります。

### Fileクラス

JUCEの[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")クラスは、ファイルまたはディレクトリへの_絶対_パス（実際に存在するかどうかに関わらず）を表します。[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")オブジェクトを作成する最も簡単な方法は、絶対パスを含む[String](https://docs.juce.com/master/classString.html "The JUCE String class!")を渡すことです。例えば、macOS、Linux、またはAndroidでは、以下が絶対パスになります：

```cpp
juce::File path ("/path/to/file.txt");
```

しかし、[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")クラスは、親ディレクトリに対して相対的な子ファイルを要求したり、親ディレクトリを取得したりすることで、パスを操作する方法を提供します。例えば、上記のコードは[File::getChildFile()](https://docs.juce.com/master/classFile.html#a087bb8f0a60069234b13ab965fb5014a "Returns a file that represents a relative (or absolute) sub-path of the current one.")関数を使用して以下のように書き換えることができます：

```cpp
juce::File path (File ("/path").getChildFile ("to").getChildFile ("file.txt"));
```

この例ではコードがより冗長になりましたが、実際のシナリオでは同じディレクトリから複数のファイルにアクセスする必要があることがよくあります。したがって、親ディレクトリを1つの[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")オブジェクトに格納し、必要に応じて子ファイルを要求することは理にかなっています。

Windowsでは、同等の絶対パスは次のようになります：

```cpp
juce::File path ("C:\\path\\to\\file.txt");
```

子ディレクトリと親ディレクトリの扱いは各プラットフォームで同じです。JUCEがプラットフォームの違い（パス区切り文字など）を処理します。

### FilenameComponentクラス

このチュートリアルでは、[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")オブジェクトを使用して、ユーザーが標準のオペレーティングシステムウィンドウを使用してファイルを選択できるようにします。[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")オブジェクトにリスナーをアタッチでき（[チュートリアル：リスナーとブロードキャスター](../../interface-design/tutorial_listeners_and_broadcasters/)を参照）、ファイルが変更されると、現在選択されているファイルを[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")オブジェクトとして取得できます。

[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")オブジェクトは、絶対パスを含むテキストボックスを表示します。また、オペレーティングシステムからファイルを選択するためのボタンも提供します。最近使用したファイルのリストを含むドロップダウンメニューもあります。これは使用中に自動的に入力されますが、これらの最近使用したファイルは手動で追加することもできます（例えば、アプリケーションにハードコードされたり、設定ファイルから取得したりできます）。

すぐに見るように、[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")コンストラクタにはかなりの数の引数があり、デフォルトコンストラクタがありません。このような場合、子コンポーネントをstd::unique_ptrオブジェクトに格納する方が簡単です（これは、コンストラクタ内のクラス初期化子リストで初期化する必要がないためです）。結果を表示するために使用する[TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box.")コンポーネントも必要です。[TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box.")クラスにはデフォルトコンストラクタ_がありますが_、一貫性のために両方のコンポーネントオブジェクトをstd::unique_ptrオブジェクトに格納します：

```cpp
std::unique_ptr<juce::FilenameComponent> fileComp;
std::unique_ptr<juce::TextEditor> textContent;
```

`MainContentComponent`コンストラクタで、新しい[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")オブジェクトを割り当て、ファイルを開くのに適した設定で初期化します（[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")クラスはファイルを保存する場所を選択するためにも使用できます）。このコンストラクタ内で、選択できるファイルサフィックスのリストを提供できます（例：`"*.txt;*.foo"`）。サフィックスを強制することもできます（これはファイルを保存する場合により便利です）。これらの両方の引数で空の文字列を渡します。これはフィルタリングが行われないことを意味します。他の引数は自明であり、[FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")オブジェクトに望む他の動作方法を定義します（コード内のコメントを参照）：

```cpp
MainContentComponent()
{
    fileComp.reset (new juce::FilenameComponent ("fileComp",
        {}, // current file
        false, // can edit file name,
        false, // is directory,
        false, // is for saving,
        {}, // browser wildcard suffix,
        {}, // enforced suffix,
        "Select file to open")); // text when nothing selected
    addAndMakeVisible (fileComp.get());
    fileComp->addListener (this);
```

[FilenameComponentListener](https://docs.juce.com/master/classFilenameComponentListener.html "Listens for events happening to a FilenameComponent.")コールバックで、現在選択されているファイルを取得し、`readFile()`関数に渡します：

```cpp
void filenameComponentChanged (juce::FilenameComponent* fileComponentThatHasChanged) override
{
    if (fileComponentThatHasChanged == fileComp.get())
        readFile (fileComp->getCurrentFile());
}
```

以下の各例では、`readFile()`関数は異なる方法で選択されたファイルを読み込みます。しかし、結果を表示する場所が必要なので、`MainContentComponent`コンストラクタで[TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box.")コンポーネントも設定します：

```cpp
textContent.reset (new juce::TextEditor());
addAndMakeVisible (textContent.get());
textContent->setMultiLine (true);
textContent->setReadOnly (true);
textContent->setCaretVisible (false);

setSize (600, 400);
}
```

### ファイル全体を文字列に読み込む

[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")クラスは主にファイルへのパスを格納および操作するために設計されていますが、本当にシンプルな方法でファイルを読み込むための便利な関数がいくつかあります。例えば、[File::loadFileAsString()](https://docs.juce.com/master/classFile.html#a07b95f6831ee4ed5b49241ce6af8539d "Reads a file into memory as a string.")関数はまさにその名の通りのことを行います：ファイル全体を[String](https://docs.juce.com/master/classString.html "The JUCE String class!")オブジェクトに読み込みます。もちろん、選択されたファイルがテキストファイルでない場合、結果は意味不明かもしれません（ただしJUCEはクラッシュしません）。この関数はUTF-8とUTF-16の両方の形式を検出して読み込むことができます：

```cpp
void readFile (const juce::File& fileToRead)
{
    if (!fileToRead.existsAsFile()) // [1]
        return;

    auto fileText = fileToRead.loadFileAsString();

    textContent->setText (fileText);
}
```

選択されたファイルが実際に存在するかどうかを確認していることに注意してください [1]。オペレーティングシステムからファイルを選択したため、これは失敗しないはずですが、ファイルを扱う際にはこの種のチェックを行うことが良い習慣です。アプリを実行し、デモプロジェクトの`Resources`ディレクトリにある`juce.txt`テキストファイルをロードしてください。結果は以下のスクリーンショットのようになります：

<CaptionImage
  src="/_images/tutorial_file_reading_screenshot1.png"
  caption="テキストファイルの読み込みと表示"
/>

ファイル全体を[MemoryBlock](https://docs.juce.com/master/classMemoryBlock.html "A class to hold a resizable block of raw data.")オブジェクトに読み込む同等の関数 --- [File::loadFileAsData()](https://docs.juce.com/master/classFile.html#a889b8b0784b4f97c5bf93ffc24c3650d "Loads a file's contents into memory as a block of binary data.") --- もあります。

### ファイルを行ごとに読み込む

ファイル読み込みプロセスをより制御するには、[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")オブジェクトを使用する必要があります。これを行う1つの方法は、読み込みたいファイルを表す[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")オブジェクトをコンストラクタに渡して[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")オブジェクトを構築することです [2]。

:::tip
[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")クラスは、データを読み込むストリームの基本クラスである[InputStream](https://docs.juce.com/master/classInputStream.html "The base class for streams that read data.")クラスのサブクラスです。
:::

以下のコードを追加してください：

```cpp
void readFile (const juce::File& fileToRead)
{
    if (!fileToRead.existsAsFile())
        return; // file doesn't exist

    juce::FileInputStream inputStream (fileToRead); // [2]

    if (!inputStream.openedOk())
        return; // failed to open
```

ファイルを行ごとに読み込みますが、「\*」文字で始まる行を検出します。次に、これらの行を異なるフォントでフォーマットし、他のテキストの見出しとしてこれらの行を使用します。以下のコードを追加してください：

```cpp
textContent->clear();

auto normalFont = textContent->getFont();
auto titleFont = normalFont.withHeight (normalFont.getHeight() * 1.5f).boldened();
juce::String asterix ("*");
```

次の部分は、ストリームが使い果たされるまで[3]、`while()`ループで`inputStream`オブジェクトからデータを読み込むことです。以下を追加してください：

```cpp
while (!inputStream.isExhausted()) // [3]
{
    auto line = inputStream.readNextLine();

    if (line.startsWith (asterix))
    {
        line = line.removeCharacters (asterix);
        textContent->setFont (titleFont);
    }
    else
    {
        textContent->setFont (normalFont);
    }

    // append the text to the textContent
    textContent->insertTextAtCaret (line + juce::newLine);
}
}
```

これが行うことは：

- [InputStream::readNextLine()](https://docs.juce.com/master/classInputStream.html#af16acc8f2fd769adb559a781ece8e903 "Reads a UTF-8 string from the stream, up to the next linefeed or carriage return.")関数を使用して行を読み込みます
- 行が「\*」で始まるかどうかを確認します
- それに応じて`textContent`オブジェクトのフォントを設定します
- 必要に応じて「\*」文字を削除します
- `textContent`オブジェクトにテキスト行を追加します

同じ`juce.txt`ファイルをロードすると、以下のスクリーンショットのようになるはずです：

<CaptionImage
  src="/_images/tutorial_file_reading_screenshot2.png"
  caption="ファイルを行ごとに読み込む"
/>

:::tip
このサブセクションの例のコードは、デモプロジェクトの`FileReadingTutorial_02.h`ファイルにあります。
:::

### ファイルをバイトごとに読み込む

[InputStream](https://docs.juce.com/master/classInputStream.html "The base class for streams that read data.")、したがって[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")クラスには、ファイルをより小さな単位で、一度に1バイトまで読み込む関数もあります。これを説明するために、テキストファイルをロードして各単語を異なる色で表示しましょう。まず、ランダムな色を生成する関数を追加しましょう。この関数はランダムな色を生成しますが、明るさを指定された最小値に制限します（これは黒い背景に対して色が見えるようにするためです）：

```cpp
static juce::Colour getRandomColour (float minBrightness)
{
    auto& random = juce::Random::getSystemRandom();
    juce::Colour colour ((juce::uint8) random.nextInt (256),
        (juce::uint8) random.nextInt (256),
        (juce::uint8) random.nextInt (256));

    return colour.getBrightness() >= minBrightness ? colour
                                                   : colour.withBrightness (minBrightness);
}
```

次に、[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")オブジェクトからスペース文字に達するまでデータを読み込む関数を追加しましょう。これにより、スペースを含むまでのテキストが返されます。[MemoryBlock](https://docs.juce.com/master/classMemoryBlock.html "A class to hold a resizable block of raw data.")クラスを使用して小さなメモリバッファを作成し、[InputStream::readByte()](https://docs.juce.com/master/classInputStream.html#a2e5944641712d84b6da2eee5d394326a "Reads a byte from the stream.")関数を使用して`inputStream`オブジェクトから一度に1バイトずつバイトを読み込みます：

```cpp
static juce::String readUpToNextSpace (juce::FileInputStream& inputStream)
{
    juce::MemoryBlock buffer (256);
    auto* data = static_cast<char*> (buffer.getData());
    size_t i = 0;

    while ((data[i] = inputStream.readByte()) != 0 && i < buffer.getSize())
        if (data[i++] == ' ')
            break;

    return juce::String::fromUTF8 (data, (int) i); // [4]
}
```

[String::fromUTF8()](https://docs.juce.com/master/classString.html#aa0116dc51d7bdd363d14c72bba60060a "Creates a String from a UTF-8 encoded buffer.") [4]関数は、生のバイナリデータを[String](https://docs.juce.com/master/classString.html "The JUCE String class!")オブジェクトに変換しようとします。

最後に、`readFile()`関数で、`readUpToNextSpace`関数を使用してストリームが使い果たされるまでテキストファイルから単語を読み込みます。以下のコードを追加してください：

```cpp
void readFile (const juce::File& fileToRead)
{
    if (!fileToRead.existsAsFile())
        return; // file doesn't exist

    juce::FileInputStream inputStream (fileToRead);

    if (!inputStream.openedOk())
        return; // failed to open

    textContent->clear();

    while (!inputStream.isExhausted())
    {
        auto nextWord = readUpToNextSpace (inputStream);
        textContent->setColour (juce::TextEditor::textColourId, getRandomColour (0.75f));
        textContent->insertTextAtCaret (nextWord);
    }
}
```

このコードを実行すると、以下のスクリーンショットのようになります。

<CaptionImage
  src="/_images/tutorial_file_reading_screenshot3.png"
  caption="ファイルをより小さなチャンクで読み込む"
/>

:::tip
このサブセクションの例のコードは、デモプロジェクトの`FileReadingTutorial_03.h`ファイルにあります。
:::

[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")オブジェクトを作成する別の方法は、[File::createInputStream()](https://docs.juce.com/master/classFile.html#a668db4b90ac7839c70f0a9ac22124c29 "Creates a stream to read from this file.")関数を使用することです。この関数は、`new`演算子を使用してヒープに割り当てられた[FileInputStream](https://docs.juce.com/master/classFileInputStream.html "An input stream that reads from a local file.")オブジェクトを返します。これは、終了したらオブジェクトを解放することが_非常に_重要であることを意味します。理想的には、このためにstd::unique_ptrオブジェクトを使用する必要があります。ここでのわずかな違いは、ファイルストリームが開けない場合、[File::createInputStream()](https://docs.juce.com/master/classFile.html#a668db4b90ac7839c70f0a9ac22124c29 "Creates a stream to read from this file.")関数が`nullptr`値を返すことです。以下のコードは、この場合に使用すべき典型的なパターンを示しています：

```cpp
void readFile (const juce::File& fileToRead)
{
    if (!fileToRead.existsAsFile())
        return; // file doesn't exist

    if (std::unique_ptr<juce::FileInputStream> inputStream { fileToRead.createInputStream() })
    {
        textContent->clear();

        while (!inputStream->isExhausted())
        {
            auto nextWord = readUpToNextSpace (*inputStream);
            textContent->setColour (juce::TextEditor::textColourId, getRandomColour (0.75f));
            textContent->insertTextAtCaret (nextWord);
        }
    }
}
```

:::note
演習：一部の行末の単語の色が次の行の先頭の単語の色と同じであることに気づくかもしれません。これは、区切り文字としてスペース文字のみを検索しているためです。改行、キャリッジリターン、タブ文字も検索するようにコードを変更してください（これらは文字`'\n'`、`'\r'`、`'\t'`です）。
:::

## バイナリデータの読み込み

このチュートリアルでは、ファイルから文字列データを読み込む方法を見てきました。ファイルから単一のバイトを読み込むことに加えて、[InputStream](https://docs.juce.com/master/classInputStream.html "The base class for streams that read data.")クラスには他の基本型を読み込む関数も含まれています。例えば：

- [InputStream::readInt()](https://docs.juce.com/master/classInputStream.html#a59eb456ebfbe9d4c7fdfd4c14337e19a "Reads four bytes from the stream as a little-endian 32-bit value.") --- ストリームから`int`（32ビット）を読み込みます。
- [InputStream::readShort()](https://docs.juce.com/master/classInputStream.html#a0c4b0f9f1fa9515fea5a98d2ffe7ae02 "Reads two bytes from the stream as a little-endian 16-bit value.") --- ストリームから`short`（16ビット）整数を読み込みます。
- [InputStream::readFloat()](https://docs.juce.com/master/classInputStream.html#a46d7f191f1872bc27550db3fa0733f59 "Reads four bytes as a 32-bit floating point value.") --- ストリームから`float`（32ビット）を読み込みます。

これらはすべてリトルエンディアンのバイト順序を使用してマルチバイト値を読み込みます。ビッグエンディアン値として読み込むには代替バージョンがあります --- 例えば、[InputStream::readIntBigEndian()](https://docs.juce.com/master/classInputStream.html#a84ab1bcc547eee621c4c6c2502af808d "Reads four bytes from the stream as a big-endian 32-bit value.")関数。[InputStream::read()](https://docs.juce.com/master/classInputStream.html#aa5350c414bad6b97ae3b463a3401c0d6 "Reads some data from the stream into a memory buffer.")または[InputStream::readIntoMemoryBlock()](https://docs.juce.com/master/classInputStream.html#a7708d25af96e8d8b937a4642dcf55a23 "Reads from the stream and appends the data to a MemoryBlock.")関数を使用してストリームからデータブロックを読み込むこともできます。

これらは、既存のファイルをバイナリ形式で読み込む必要がある場合や、データをバイナリとして格納する本当の必要がある場合に便利です。ほとんどの場合、データの格納と読み込みにはXML（[XmlDocument](https://docs.juce.com/master/classXmlDocument.html "Parses a text-based XML document and creates an XmlElement object from it.")と[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")クラスを使用）または[JSON](https://docs.juce.com/master/classJSON.html "Contains static methods for converting JSON-formatted text to and from var objects.")（varオブジェクトにデータを格納することで）を使用する方がおそらく望ましいでしょう。

## まとめ

このチュートリアルでは、テキストファイルをさまざまな方法で読み込むことを通じて、JUCEを使用したシンプルなファイル読み込み技術を紹介しました。特に以下のことができるはずです：

- [FilenameComponent](https://docs.juce.com/master/classFilenameComponent.html "Shows a filename as an editable text box, with a 'browse' button and a drop-down list for recently se...")と[FilenameComponentListener](https://docs.juce.com/master/classFilenameComponentListener.html "Listens for events happening to a FilenameComponent.")を使用してファイルパスを格納し、ユーザーにファイルを選択する手段を提供する。
- ファイルの内容全体を[String](https://docs.juce.com/master/classString.html "The JUCE String class!")オブジェクトに読み込む。
- 適切な[InputStream](https://docs.juce.com/master/classInputStream.html "The base class for streams that read data.")関数を使用してファイルをより小さなチャンクで読み込む。

## 関連項目

- [チュートリアル：JUCEの色](../../interface-design/tutorial_colours/)
- [チュートリアル：Labelクラス](../../interface-design/tutorial_label/)
- [チュートリアル：オーディオプレーヤーを構築する](../../audio/tutorial_playing_sound_files/)
