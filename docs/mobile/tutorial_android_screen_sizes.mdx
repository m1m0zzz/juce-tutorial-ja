---
title: Androidの画面サイズの管理
sidebar_position: 2
tags: [中級]
---

# チュートリアル：Androidの画面サイズの管理

<SourcePageLink path="tutorial_android_screen_sizes" />

さまざまな画面サイズに対応したアプリケーションを構築します。Androidには多くの利用可能な画面サイズがあり、このチュートリアルではこれを管理するためのいくつかの戦略を検討します。

**レベル:** 中級<br/>
**プラットフォーム:** Android, macOS, Windows<br/>
**クラス:** [Desktop](https://docs.juce.com/master/classDesktop.html "Describes and controls aspects of the computer's desktop."), [AffineTransform](https://docs.juce.com/master/classAffineTransform.html "Represents a 2D affine-transformation matrix."), [TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")

## はじめに

このチュートリアルでは、JUCEを使用してAndroidプラットフォームでさまざまな画面サイズを管理するためのいくつかの戦略を説明します。このチュートリアルには、いくつかのデモプロジェクトが付属しています。これらのプロジェクトへのダウンロードリンクは、チュートリアルの関連セクションで提供されています。

これらのセクションのそれぞれでこの手順についてサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucerを始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

このチュートリアルで提供されるデモプロジェクトは、JUCEを使用してAndroidプラットフォームでさまざまな画面サイズを管理するためのいくつかの異なる方法を示しています。大まかに、これらの方法は以下のとおりです：

- メインコンポーネント内の子コンポーネントのリサイズ。
- トランスフォームを使用したメインコンポーネントのリサイズ。
- 異なる向きに対して異なるコンポーネントレイアウトを設計する。
- 異なるサイズに対して異なるコンポーネントレイアウトを設計する。

## Androidの画面サイズ

特にフルスクリーン操作を期待するデバイス（モバイルデバイスなど）では、すべての画面サイズとさまざまなデバイスの向きに対して効果的なユーザーインターフェースを設計することは課題です。これは、多くの可能な画面サイズと解像度があるAndroidプラットフォームでは特に課題となります。ここには3つの主な問題があります：

- _物理サイズ_：標準的な測定単位で測定された画面の物理サイズ（一般的な測定は画面の対角線の距離で、インチで測定されます）。
- _解像度_：ピクセル単位で測定された画面解像度。
- _向き_：デバイスの向き、横向きまたは縦向き。

物理サイズと解像度の関係は重要です。物理ピクセルが標準解像度画面よりも小さく、より密に詰まっている高解像度画面を検討する場合、特に重要です。特定の物理画面サイズとその解像度の組み合わせにより、画面の_ドット・パー・インチ_（DPI）が決まります。これは画面の_ピクセル密度_に関連しています。これは、標準密度画面上のピクセルとして、各次元で「ソフトウェア」ピクセルのスペースを占める物理ピクセルの数です。

一部のアプリケーションでは、物理サイズが最も重要になります。例えば、繊細な指の動きを含む複雑なインタラクションを使用するアプリケーションの場合です。この場合、画面サイズと典型的なユーザーの手のサイズが重要です。他のアプリケーションでは、画面のDPIがより重要です。例えば、テキストはより高いDPIではより小さいフォントサイズでも読みやすくなります。しかし、画面上の物理サイズで測定した場合、テキストがどれだけ読みやすくなるかには限界があります。アプリケーションを設計する際には、物理サイズと解像度（したがってDPI）の両方を考慮する必要がある場合があります。

デフォルトでは、JUCEは画面のピクセル密度に基づいて座標システムをスケーリングします。これは、高密度画面に描画される図形やテキストは、標準密度画面での物理サイズとほぼ同じに見えるはずであることを意味します。JUCEでは、[Desktop](https://docs.juce.com/master/classDesktop.html "Describes and controls aspects of the computer's desktop.")クラスを介して特定のディスプレイに関する情報にアクセスできます。ここでは、利用可能なディスプレイとどれが「メインディスプレイ」としてマークされているか（特に複数のディスプレイがある場合）を確認できます。

残念ながら、JUCEがディスプレイのDPIを取得するためにアクセスできる値は近似値に過ぎません（すべての画面デバイスがこの情報を正しく報告するわけではないため）。これは、ユーザーの画面の物理サイズを正確に測定できないことを意味します。しかし、[Desktop](https://docs.juce.com/master/classDesktop.html "Describes and controls aspects of the computer's desktop.")クラスが提供する情報は、アプリケーションのニーズに応じてユーザーインターフェースをスケーリングするためのガイドとしては十分なはずです。

以下の各例では、親コンポーネント（`MainContentComponent`）によって管理およびリサイズされる`ResizingComp`という子コンポーネントを使用しています。

:::tip
これらのプロジェクトをmacOSまたはWindowsでテストすると、メインウィンドウの幅と高さを動的にリサイズできます。これはある程度機能しますが、テスト目的を除いて、プロジェクトの機能として意図されていません。プロジェクトは、サイズの変更がまれであることを期待するように設計されています。例えば、アプリケーションが起動するときの1回限りの設定、またはユーザーがAndroidデバイスを回転させたときです。
:::

## 子コンポーネントのリサイズ（シンプルリサイズ）

このセクションのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/AndroidScreenSizesTutorialSimpleResize.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/AndroidScreenSizesTutorialSimpleResize.zip)。プロジェクトを解凍し、最初のヘッダファイルをProjucerで開いてください。

この例では、スライダーとボタンのコレクションを含むシンプルなインターフェースを使用しています。これらの子コンポーネントはそれぞれ、画面の高さの一部（エッジの周りの小さな境界を差し引いた）が与えられます。水平方向でも同様のアプローチを取ることができます。シンプルにするために、スライダーとボタンは画面の全幅を占めるだけです（同様に、小さな境界を差し引いた）。縦向きで数百ピクセルの範囲のサイズの画面では、以下のスクリーンショットのようになります：

<CaptionImage
  src="/_images/tutorial_android_screen_sizes_screenshot1.png"
  caption="子コンポーネントのシンプルリサイズ：縦向き"
/>

横向きでは、以下のスクリーンショットのようになります：

<CaptionImage
  src="/_images/tutorial_android_screen_sizes_screenshot2.png"
  caption="子コンポーネントのシンプルリサイズ：横向き"
/>

### コンポーネントの配列

`ResizingComp`クラスにボタンとスライダーを格納するために、[OwnedArray](https://docs.juce.com/master/classOwnedArray.html "An array designed for holding objects.")テンプレートクラスを使用します（これは、これらの子コンポーネントが`ResizingComp`デストラクタで自動的に削除されることを意味します）。まず、`ResizingComp`コンストラクタで、[Colour](https://docs.juce.com/master/classColour.html "Represents a colour, also including a transparency value.")オブジェクトの配列を構築します。これらは、ボタン、スライダーのサム、スライダートラックの色を設定するために使用されます：

```cpp
ResizingComp()
{
    juce::Array<juce::Colour> colours { juce::Colour (0xffb3c3Da), juce::Colour (0xff5973b8), juce::Colour (0xffd65667), juce::Colour (0xffd99154), juce::Colour (0xffe5ad6c), juce::Colour (0xffecc664), juce::Colour (0xffefe369), juce::Colour (0xffdddB74) };
```

:::tip
これらはたまたまJUCEロゴの色です！
:::

次に、`for()`ループを使用して複数のボタンを割り当てて設定します：

```cpp
for (auto i = 0; i < 6; ++i)
{
    auto* button = buttons.add (new juce::TextButton (juce::String ("Button ") + juce::String (i + 1)));
    addAndMakeVisible (button);

    button->setColour (juce::TextButton::buttonColourId,
        colours.getUnchecked (i % colours.size()));
}
```

スライダーも同様に設定されます（ただし、興味深く保つために色の配列を使用して色の選択を混ぜています）：

```cpp
for (auto i = 0; i < 6; ++i)
{
    auto* slider = sliders.add (new juce::Slider());
    addAndMakeVisible (slider);

    slider->setColour (juce::Slider::thumbColourId,
        colours.getUnchecked ((buttons.size() + i) % colours.size()));
    slider->setColour (juce::Slider::backgroundColourId,
        colours.getUnchecked ((buttons.size() + i + 2) % colours.size()).withAlpha (0.4f));
    slider->setColour (juce::Slider::trackColourId,
        colours.getUnchecked ((buttons.size() + i + 2) % colours.size()));
    slider->setColour (juce::Slider::textBoxTextColourId, juce::Colours::black);
}
```

### カスタムスライダーサムサイズの使用

タッチスクリーンインターフェースでより使いやすくするために、スライダーのサムは通常、標準サイズよりも大きくなるようにカスタマイズされています。これを行うために、[LookAndFeel_V4](https://docs.juce.com/master/classLookAndFeel__V4.html "The latest JUCE look-and-feel style, as introduced in 2017.")のサブクラスを追加し、[LookAndFeel::getSliderThumbRadius()](https://docs.juce.com/master/structjuce_1_1Slider_1_1LookAndFeelMethods.html#aae2d9ccbd37bf4a8758f809339f797b2)関数をオーバーライドしました。

```cpp
class CustomLookAndFeel : public juce::LookAndFeel_V4
{
public:
    int getSliderThumbRadius (juce::Slider& slider) override
    {
        return juce::jmin (slider.getWidth(), slider.getHeight()) / 2;
    }
};
```

このクラスのインスタンスを`ResizingComp`クラスのメンバーとして追加します：

```cpp
juce::OwnedArray<juce::Button> buttons;
juce::OwnedArray<juce::Slider> sliders;
CustomLookAndFeel lf;
};
```

そして、`ResizingComp`コンストラクタの最後で、これをこのコンポーネントとそのすべての子のルック・アンド・フィールとして設定します。

```cpp
setLookAndFeel (&lf);
```

`ResizingComp`デストラクタでは、これをnullptrに設定します。

```cpp
~ResizingComp() override
{
    setLookAndFeel (nullptr);
}
```

### ボタンとスライダーのリサイズ

`ResizingComp::resized()`関数では、ボタンとスライダーの配列を反復処理し、それらの境界を設定します：

```cpp
void resized() override
{
    auto space = 8;
    auto widgetHeight = (getHeight() - space) / (buttons.size() + sliders.size()) - space;

    for (auto* button : buttons)
        button->setBounds (space, space + (widgetHeight + space) * buttons.indexOf (button), getWidth() - space - space, widgetHeight);

    for (auto* slider : sliders)
        slider->setBounds (space, space + (widgetHeight + space) * (sliders.indexOf (slider) + buttons.size()), getWidth() - space - space, widgetHeight);
}
```

ここでは、コンポーネントを分離するために定数値（8）を使用します。次に、利用可能な高さと「ウィジェット」（ボタンとスライダー）の数に基づいて「ウィジェットの高さ」を計算します。

画面サイズが小さすぎると、以下のスクリーンショットに示されるように、インターフェースは使用不能になり読めなくなります：

<CaptionImage
  src="/_images/tutorial_android_screen_sizes_screenshot3.png"
  caption="画面が小さすぎる場合のシンプルリサイズ"
/>

とはいえ、ほとんどのAndroidデバイスでは妥当に見えるはずです。

:::note
演習：インターフェース内のスライダーとボタンの数を変更してみてください。
:::

## トランスフォームを使用したメインコンポーネントのリサイズ

このセクションのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/AndroidScreenSizesTutorialTransform.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/AndroidScreenSizesTutorialTransform.zip)。プロジェクトを解凍し、最初のヘッダファイルをProjucerで開いてください。

この例では、子コンポーネントのリサイズの代替手段を使用します。代わりに、`ResizingComp`コンポーネントは公称サイズ（480×640ピクセル）に設定され、`MainContentComponent`オブジェクトは画面サイズに合わせてスケールアップまたはスケールダウンするためのアフィン変換を適用します。これは、同じアスペクト比を維持しながら行われます（スライダーとボタンの横または上下に空白が残ります）。`ResizingComp`クラスのコードは、[シンプルリサイズ](#tutorial_android_screen_sizes_resizing_child_components)の例と同じです。しかし、`MainContentComponent::resized()`関数では、`ResizingComp`コンポーネントのサイズを設定してから、必要な変換を計算します：

```cpp
void resized() override
{
    auto contentWidth = 480;
    auto contentHeight = 640;

    auto scaleX = (float) getWidth() / static_cast<float> (contentWidth);
    auto scaleY = (float) getHeight() / static_cast<float> (contentHeight);
    auto scale = juce::jmin (scaleX, scaleY);

    resizingComp->setTransform (juce::AffineTransform::scale (scale, scale));
    resizingComp->centreWithSize (contentWidth, contentHeight);
}
```

このコードは、公称サイズとソフトウェアピクセルでの画面の実際のサイズとの比率を計算します。次に、アスペクト比を維持しながら、すべてのコンテンツを画面上に保つために、これらの比率の最小値を選択します。次に、[AffineTransform::scale()](https://docs.juce.com/master/classAffineTransform.html#a43665170b0ec3ef0d1afef4053e77a24 "Returns a new transform which is a re-scale about the origin.")関数を使用して[AffineTransform](https://docs.juce.com/master/classAffineTransform.html "Represents a 2D affine-transformation matrix.")クラスのインスタンスを作成し、スケール変換を画面の中央に配置します。変換はComponent::setTransform()関数を使用してコンポーネントに適用されます。結果は[シンプルリサイズ](#tutorial_android_screen_sizes_resizing_child_components)方法とはかなり異なります。

<CaptionImage
  src="/_images/tutorial_android_screen_sizes_screenshot4.png"
  caption="トランスフォームを使用してUI全体をスケーリング（縦向きと横向きの両方を表示）"
/>

:::tip
コンポーネントにトランスフォームを適用すると、ユーザーインターフェースの描画だけでなく、タッチ（およびマウス）アクティビティの位置も変換されます。
:::

## 異なる向きに対して異なるレイアウトを設計する

このセクションのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/AndroidScreenSizesTutorialLayoutsOrientation.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/AndroidScreenSizesTutorialLayoutsOrientation.zip)。プロジェクトを解凍し、最初のヘッダファイルをProjucerで開いてください。

この例では、画面（またはデバイス）の向きに応じて異なるレイアウトを表示する1つの方法を見ています。[Desktop::getCurrentOrientation()](https://docs.juce.com/master/classDesktop.html#a02ae21e312faf1715e8311f1f53e5e00 "In a tablet device which can be turned around, this returns the current orientation.")関数は、デバイスの向きにアクセスする手段を提供します。実際には、4つの可能な向きがあります：

- 直立（縦向き）。
- 上下逆（縦向きを180度回転）。
- デバイスを時計回りに90度回転（横向きの1つのバージョン）。
- デバイスを反時計回りに90度回転（横向きのもう1つのバージョン）。

シンプルにするために、このチュートリアルでは、縦向きを高さが幅より大きい画面として扱い、横向きを幅が高さより大きい画面として扱います。

この例では、以前に見た[トランスフォームを使用した](#tutorial_android_screen_sizes_resizing_main_component_transform)ユーザーインターフェースをスケーリングするのと同じ技術を使用します。違いは、この`ResizingComp`クラスは向きに応じて異なるレイアウトを使用し、`MainContentComponent`クラスには2つの公称サイズ（横向き用と縦向き用）があることです。向きは`MainContentComponent::resized()`関数で決定されます：

```cpp
void resized() override
{
    auto isLandscape = getWidth() > getHeight();
    auto contentWidth = isLandscape ? 640 : 480;
    auto contentHeight = isLandscape ? 480 : 640;
```

次に、`ResizingComp::resized()`関数で、向きに応じて2つのリサイズ関数から選択します：

```cpp
void resized() override
{
    if (getHeight() > getWidth())
        resizedPortrait();
    else
        resizedLandscape();
}
```

`resizedPortrait()`と`resizedLandscape()`関数は、ボタンとスライダーをレイアウトするために異なる算術を使用します。

横向きが使用される場合、ボタンとスライダーは1列ではなく2列で表示されます。これは以下のスクリーンショットに示されています：

<CaptionImage
  src="/_images/tutorial_android_screen_sizes_screenshot5.png"
  caption="横向きで異なるレイアウトを使用"
/>

:::note
演習：画面の幅と高さを比較する代わりに、[Desktop::getCurrentOrientation()](https://docs.juce.com/master/classDesktop.html#a02ae21e312faf1715e8311f1f53e5e00 "In a tablet device which can be turned around, this returns the current orientation.")関数を使用して画面の向きを決定するようにコードを変更してください。
:::

## 異なる画面サイズに対して異なるレイアウトを設計する

このセクションのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/AndroidScreenSizesTutorialLayoutsSize.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/AndroidScreenSizesTutorialLayoutsSize.zip)。プロジェクトを解凍し、最初のヘッダファイルをProjucerで開いてください。

この最後の例では、異なる画面の向きと画面サイズに対して異なるレイアウトを使用します。このような技術は、画面の向きに対してまったく異なるレイアウトを使用したい場合、またはAndroidの電話とタブレット用のユニバーサルアプリケーションを作成したい場合に特に便利かもしれません。ここで使用される方法は、コンポーネントが単一のページに収まらない場合に、[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")クラスを使用してコンポーネントのページを配置することです。

このプロジェクトでの`ResizingComp`クラスの責任は、以前の3つのプロジェクトと比較して少し変わります。特に、ボタンとスライダーを直接の子コンポーネントとして追加しません。以下のコンストラクタのコードで、Component::addAndMakeVisible()関数の呼び出しがないことに注意してください：

```cpp
ResizingComp()
{
    juce::Array<juce::Colour> colours { juce::Colour (0xffb3c3Da), juce::Colour (0xff5973b8), juce::Colour (0xffd65667), juce::Colour (0xffd99154), juce::Colour (0xffe5ad6c), juce::Colour (0xffecc664), juce::Colour (0xffefe369), juce::Colour (0xffdddB74) };

    for (auto i = 0; i < 6; ++i)
    {
        auto* button = buttons.add (new juce::TextButton (juce::String ("Button ") + juce::String (i + 1)));

        button->setColour (juce::TextButton::buttonColourId,
            colours.getUnchecked (i % colours.size()));
    }

    for (auto i = 0; i < 6; ++i)
    {
        auto* slider = sliders.add (new juce::Slider());

        slider->setColour (juce::Slider::thumbColourId,
            colours.getUnchecked ((buttons.size() + i) % colours.size()));
        slider->setColour (juce::Slider::backgroundColourId,
            colours.getUnchecked ((buttons.size() + i + 2) % colours.size()).withAlpha (0.4f));
        slider->setColour (juce::Slider::trackColourId,
            colours.getUnchecked ((buttons.size() + i + 2) % colours.size()));
        slider->setColour (juce::Slider::textBoxTextColourId, juce::Colours::black);
    }

    setLookAndFeel (&lf);
}
```

`ResizingComp`クラスはボタンとスライダーの寿命を管理しますが、コンポーネント階層の観点からは、それらは`ComponentHolder`と呼ばれる別のコンポーネントクラスの1つ以上のインスタンスに追加されます。

### シングルページまたは複数ページの選択

画面サイズが大きい場合、これらの`ComponentHolder`コンポーネントの1つだけが作成され、すべてのボタンとスライダーがそれに追加されます。画面サイズが小さい場合、`ResizingComp`クラスは[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")オブジェクトを使用し、[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")のタブを形成するために`ComponentHolder`クラスの2つのインスタンスを追加します。シングルページまたは複数ページを使用するかどうかの決定は、`ResizingComp::resized()`関数で`ResizingComp`クラスによって管理されます。

```cpp
void resized() override
{
    if (holder.get() != nullptr)
    {
        removeChildComponent (holder.get());
        holder.reset();
    }

    auto minimumDimension = juce::jmin (getWidth(), getHeight());

    if (minimumDimension >= 480)
        layoutSinglePage();
    else
        layoutTabs();
}
```

ここでは、「大きな」画面はその寸法の1つが480ソフトウェアピクセル以上であるものと言っています。もちろん、アプリケーションに異なる値を選択できます。`ResizingComp::layoutSinglePage()`関数は簡単です：

```cpp
void layoutSinglePage()
{
    holder.reset (new ComponentHolder());

    for (auto* button : buttons)
        dynamic_cast<ComponentHolder*> (holder.get())->addComp (button);

    for (auto* slider : sliders)
        dynamic_cast<ComponentHolder*> (holder.get())->addComp (slider);

    addAndMakeVisible (holder.get());
    holder->setBounds (getLocalBounds());
}
```

ここでは、すべてのボタンとスライダーを`ComponentHolder`インスタンスに追加し、`ResizingComp`オブジェクトの子コンポーネントとして追加しています。`ResizingComp::layoutTabs()`関数はもう少し複雑です：

```cpp
void layoutTabs()
{
    auto orientation = getWidth() < getHeight() ? juce::TabbedButtonBar::TabsAtBottom
                                                : juce::TabbedButtonBar::TabsAtLeft;

    holder.reset (new juce::TabbedComponent (orientation)); // [1]
    addAndMakeVisible (holder.get()); // [2]

    auto* buttonTab = new ComponentHolder(); // [3]
    auto* sliderTab = new ComponentHolder();

    dynamic_cast<juce::TabbedComponent*> (holder.get())->addTab ("Buttons", juce::Colours::white, buttonTab, true); // [4]
    dynamic_cast<juce::TabbedComponent*> (holder.get())->addTab ("Sliders", juce::Colours::white, sliderTab, true);

    for (auto* button : buttons) // [5]
        buttonTab->addComp (button);

    for (auto* slider : sliders) // [6]
        sliderTab->addComp (slider);

    holder->setBounds (getLocalBounds()); // [7]
}
```

- [1]：画面の向きを使用してタブボタンを配置し、[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")オブジェクトを作成して`holder`メンバーに格納します。
- [2]：[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")オブジェクトを子コンポーネントとして追加します。
- [3]：`ComponentHolder`オブジェクトを作成します。
- [4]：これらを[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")オブジェクトにタブとして追加します（最後の`true`引数は、[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")オブジェクトに、不要になったときに`ComponentHolder`オブジェクトを削除できることを伝えます）。
- [5]：ボタンを「Buttons」タブに追加します。
- [6]：スライダーを「Sliders」タブに追加します。
- [7]：[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")オブジェクトのサイズを`ResizingComp`オブジェクトの境界を埋めるように設定します。

画面のサイズが「小さい」と判断された場合、以下のスクリーンショットに示すように[TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")が使用されます。

<CaptionImage
  src="/_images/tutorial_android_screen_sizes_screenshot6.png"
  caption="タブ付きインターフェース"
/>

:::note
演習：インターフェース内のスライダーとボタンの数を増やし、必要に応じてこれらのコントロールを2つ以上のタブに分散させる方法を考案してください。
:::

## まとめ

このチュートリアルでは、Androidデバイスの画面サイズと向きに関するさまざまな問題を検討しました。特に：

- 親コンポーネントの寸法に基づいてコンポーネントをスケーリングする基本的な方法を示しました。
- [AffineTransform](https://docs.juce.com/master/classAffineTransform.html "Represents a 2D affine-transformation matrix.")クラスを使用してコンポーネントをスケーリングする方法を示しました。
- デバイスの向きに応じて異なるコンテンツを表示する方法を示しました。
- [TabbedComponent](https://docs.juce.com/master/classTabbedComponent.html "A component with a TabbedButtonBar along one of its sides.")クラスを使用してユーザーインターフェースを複数のページに分散させる方法を示しました。

## 関連項目

- [チュートリアル：Androidの始め方](../tutorial_android_studio/)
- [チュートリアル：親コンポーネントと子コンポーネント](../../interface-design/tutorial_component_parents_children/)
- [チュートリアル：FlexBoxとGridを使用したレスポンシブGUIレイアウト](../../interface-design/tutorial_flex_box_grid/)
