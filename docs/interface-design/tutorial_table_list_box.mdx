---
title: TableListBox クラス
sidebar_position: 12
tags: [中級]
---

# チュートリアル：TableListBox クラス

<SourcePageLink path="tutorial_table_list_box" />

JUCE ユーザーインターフェースにテーブルを組み込みます。XML ファイルから読み込んだデータを表示し、テーブルの形式をカスタマイズします。

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header."), [TableListBoxModel](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents."), [ListBox](https://docs.juce.com/master/classListBox.html "A list of items that can be scrolled vertically."), [ListBoxModel](https://docs.juce.com/master/classListBoxModel.html "A subclass of this is used to drive a ListBox."), [TableHeaderComponent](https://docs.juce.com/master/classTableHeaderComponent.html "A component that displays a strip of column headings for a table, and allows these to be resized,..."), [XmlDocument](https://docs.juce.com/master/classXmlDocument.html "Parses a text-based XML document and creates an XmlElement object from it."), [XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")

## はじめに

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/TableListBoxTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/TableListBoxTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルを Projucer で開いてください。

:::warning
このプロジェクトの PIP バージョンを使用する場合は、`Resources`フォルダを生成された Projucer プロジェクトにコピーしてください。
:::

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucer を始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトは、JUCE モジュールに関する情報を含む XML ファイルから読み込んだテーブルを表示します。テーブルは選択した列に従ってソートでき、特定のエントリは編集可能で、列は非表示にできます。

<CaptionImage
  src="/_images/tutorial_table_list_box_screenshot1.png"
  caption="アプリウィンドウ"
/>

## ListBox クラス

JUCE でテーブルを表示できる基本の[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスは[ListBox](https://docs.juce.com/master/classListBox.html "A list of items that can be scrolled vertically.")クラスと呼ばれます。[ListBox](https://docs.juce.com/master/classListBox.html "A list of items that can be scrolled vertically.")の動作は、表示するデータモデルを記述する[ListBoxModel](https://docs.juce.com/master/classListBoxModel.html "A subclass of this is used to drive a ListBox.")クラスによって管理されます。これは、スクロール可能なビューポートに項目のリストを表示するのに便利ですが、列を記述するヘッダー付きの適切なテーブルにするには、それぞれ[TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header.")と[TableListBoxModel](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")クラスを使用できます。これらのクラスは対応するクラスと同じ動作をカプセル化しますが、列ヘッダーを表示するための[TableHeaderComponent](https://docs.juce.com/master/classTableHeaderComponent.html "A component that displays a strip of column headings for a table, and allows these to be resized,...")の機能を組み込んでいます。

[TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header.")を実装し、[TableListBoxModel](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")を継承する場合、オーバーライドすべきいくつかの関数があります：

- `getNumRows()`：テーブル内の現在の行数を返す必要があります。
- `paintRowBackground()`：提供された[Graphics](https://docs.juce.com/master/classGraphics.html "A graphics context, used for drawing a component or image.")コンテキストを使用して、行番号で指定された行の背景を描画する必要があります。
- `paintCell()`：提供された[Graphics](https://docs.juce.com/master/classGraphics.html "A graphics context, used for drawing a component or image.")コンテキストを使用して、行番号と列番号で指定されたセルを描画する必要があります。
- `refreshComponentForCell()`：オプションで、テーブル内のカスタムコンポーネントを作成および更新するためにこのメソッドをオーバーライドできます。
- `getColumnAutoSizeWidth()`：列の幅に自動サイズを使用する場合、オプションで列がどのようにリサイズするかを指定できます。
- `sortOrderChanged()`：カスタムソート順序を使用する場合、オプションで列がどのように並べ替えられるかを指定できます。

追加機能のためにオーバーライドできる他の関数もありますが、このチュートリアルではここに示されている関数を実装します。

## XML からのデータの読み込み

テーブルに表示したいデータを XML ドキュメントから読み込むことから始めましょう。

プロジェクトの`Resources`フォルダには、このチュートリアルで使用するサンプルデータが`TableData.xml`というファイルに以下の形式で含まれています：

```cpp
<TABLE_DATA>
<HEADERS>
<COLUMN columnId="1" name="ID" width="50"/>
//...
</HEADERS>
<DATA>
<ITEM ID="01" Module="juce_module" Name="JUCE example classes" Version="5.2.0" License="ISC" Groups="2" Dependencies="1" Description="..." Select="0"/>
//...
</DATA>
</TABLE_DATA>
```

ここでは、ファイル全体を`TABLE_DATA`タグでカプセル化し、テーブルヘッダーと実際のデータはそれぞれ`HEADERS`と`DATA`タグを使用して分離されています。列は個々の`COLUMN`タグで定義され、行は`ITEM`タグを使用して定義され、その行の各列のコンテンツには属性が使用されます。

このプロジェクトのコードの実装は、このファイル構造に合わせて作られていますが、XML タグは好きなように変更できます。

`TableTutorialComponent`クラスでは、ファイルの内容を単一の[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")メンバー変数に一時的に格納するポインタを定義し、また列コンテンツと行コンテンツのための 2 つの追加の XmlElement も定義します。以下に示されています：

```cpp
class TableTutorialComponent : public juce::Component,
                               public juce::TableListBoxModel
{
```

```cpp
std::unique_ptr<juce::XmlElement> tutorialData;
juce::XmlElement* columnList = nullptr;
juce::XmlElement* dataList = nullptr;
```

クラスコンストラクタでは、表示するデータファイルを選択するために[`FileChooser`](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")を起動します。[`FileChooser`](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")が完了すると、`callback`ラムダ関数を呼び出して、ファイルコンテンツを[`XmlElement`](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")オブジェクトに読み込みます[1]。XML ファイルからデータを読み込んだら、for()ループと[`XmlElement::getChildIterator`](https://docs.juce.com/master/classXmlElement.html#ac620244d67b05fb572a37bc5f01f6d0d "Allows iterating the children of an XmlElement using range-for syntax.")を使用して列ヘッダーを反復処理し、`addColumn()`関数を使用してテーブルヘッダーを割り当てます[2]：

```cpp
TableTutorialComponent()
{
    const auto callback = [this] (const juce::FileChooser& chooser) {
loadData (chooser.getResult()); // [1]
```

```cpp
if (columnList != nullptr)
{
    for (auto* columnXml : columnList->getChildIterator())
    {
        table.getHeader().addColumn (columnXml->getStringAttribute ("name"), // [2]
            columnXml->getIntAttribute ("columnId"),
            columnXml->getIntAttribute ("width"),
            50,
            400,
            juce::TableHeaderComponent::defaultFlags);
    }
}
```

この関数は、列のソート可能性とリサイズ可能性を定義するプロパティフラグとともに、列の名前、幅、ID を指定します。

コンストラクタで呼び出される`loadData()`ヘルパー関数では、まず`Resources`ディレクトリと読み込む XML ファイルを見つけ、この[File](https://docs.juce.com/master/classFile.html "Represents a local file or directory.")オブジェクトを`parse()`関数を使用して解析します[3]。次に、XML 構造をトラバースし、`getChildByName()`関数で対応するタグを見つけることで、一時的な[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")から行と列を取得できます[4]。これは、データ[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")に対して`getNumChildElements()`を呼び出すことで行数を設定するのに適した場所です[5]：

```cpp
void loadData (juce::File tableFile)
{
    if (tableFile == juce::File() || !tableFile.exists())
        return;

    tutorialData = juce::XmlDocument::parse (tableFile); // [3]

    dataList = tutorialData->getChildByName ("DATA");
    columnList = tutorialData->getChildByName ("HEADERS"); // [4]

    numRows = dataList->getNumChildElements(); // [5]
}
```

:::warning
このチュートリアルのリソースで提供されている「TableData.xml」ファイルを選択してください。
:::

また、後で便利になる`getAttributeNameForColumnId()`というヘルパー関数を定義しましょう。これは ID に基づいて列の名前を返します：

```cpp
juce::String getAttributeNameForColumnId (const int columnId) const
{
    for (auto* columnXml : columnList->getChildIterator())
    {
        if (columnXml->getIntAttribute ("columnId") == columnId)
            return columnXml->getStringAttribute ("name");
    }

    return {};
}
```

ここでは、子 XML 要素を反復処理し、一致する列 ID を見つけてその名前属性を返します。

## カスタムセルコンポーネント

[TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header.")は、テキストだけでなく、セルにカスタムコンポーネントを保持できます。以下のセクションでは、列の 1 つに[ToggleButton](https://docs.juce.com/master/classToggleButton.html "A button that can be toggled on/off.")を組み込む方法と、ユーザー入力をリッスンする編集可能な[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")を探ります。

### 編集可能なラベル

`EditableTextCustomComponent`クラスでは、まず[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")クラスを継承して、ユーザーがダブルクリックしたときに編集可能に設定します：

```cpp
class EditableTextCustomComponent : public juce::Label
{
public:
    EditableTextCustomComponent (TableTutorialComponent& td)
        : owner (td)
    {
        setEditable (false, true, false);
    }
```

```cpp
private:
    TableTutorialComponent & owner;
    int row, columnId;
    juce::Colour textColour;
};
```

ここでは、このオブジェクトがどの行と列に表示されているかと、実際のテーブルへの参照も追跡しています。

ユーザーが[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")を操作するとき、テーブルでの複数選択を考慮して、通常の`mouseDown()`機能を拡張する必要があります。これは、テーブルに対して`selectRowsBasedOnModifierKeys()`を呼び出し、修飾キーを引数として渡すことで実現されます。ここでも、元の動作を維持するために基底クラスの関数を呼び出す必要があることに注意してください：

```cpp
void mouseDown (const juce::MouseEvent& event) override
{
    owner.table.selectRowsBasedOnModifierKeys (row, event.mods, false);

    Label::mouseDown (event);
}
```

ユーザーが[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")のテキストを編集すると、`textWasEdited()`関数からコールバックを受け取り、対応する[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")オブジェクトに変更を保存するために、`TableTutorialComponent`クラスで後で定義されるヘルパー関数`setText()`を呼び出します：

```cpp
void textWasEdited() override
{
    owner.setText (columnId, row, getText());
}
```

以下の関数は、`EditableTextCustomComponent`オブジェクトを作成または更新するときに[`TableListBoxModel`](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")によって呼び出され、後で定義される`getText()`ヘルパー関数を使用して、行、列、および[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")からの表示テキストを設定します：

```cpp
void setRowAndColumn (const int newRow, const int newColumn)
{
    row = newRow;
    columnId = newColumn;
    setText (owner.getText (columnId, row), juce::dontSendNotification);
}
```

`getText()`と`setText()`ヘルパー関数は以下のように定義されています：

```cpp
juce::String getText (const int columnNumber, const int rowNumber) const
{
    return dataList->getChildElement (rowNumber)->getStringAttribute (getAttributeNameForColumnId (columnNumber));
}
```

ここでは、[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")内の子要素から行番号と列番号のテキストを見つけます。

```cpp
void setText (const int columnNumber, const int rowNumber, const juce::String& newText)
{
    const auto& columnName = table.getHeader().getColumnName (columnNumber);
    dataList->getChildElement (rowNumber)->setAttribute (columnName, newText);
}
```

ここでは、行番号と列番号から[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")内の子要素にテキストを格納します。

### 選択可能なボタン

`SelectionColumnCustomComponent`クラスでは、まず[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスを継承して、[ToggleButton](https://docs.juce.com/master/classToggleButton.html "A button that can be toggled on/off.")を子[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")として設定し、ユーザーが操作したときに呼び出されるコールバック関数を割り当てます：

```cpp
class SelectionColumnCustomComponent : public Component
{
public:
    SelectionColumnCustomComponent (TableTutorialComponent& td)
        : owner (td)
    {
        addAndMakeVisible (toggleButton);

        toggleButton.onClick = [this] { owner.setSelection (row, (int) toggleButton.getToggleState()); };
    }
```

```cpp
private:
    TableTutorialComponent & owner;
    juce::ToggleButton toggleButton;
    int row, columnId;
};
```

ここでは、このオブジェクトがどの行と列に表示されているかと、実際のテーブルへの参照も追跡しています。ラムダ関数は、ボタンのトグル状態を設定する`setSelection()`ヘルパー関数を呼び出します。

```cpp
void resized() override
{
    toggleButton.setBoundsInset (juce::BorderSize<int> (2));
}
```

`resized()`関数は、[ToggleButton](https://docs.juce.com/master/classToggleButton.html "A button that can be toggled on/off.")オブジェクトの境界を設定します。

以下の関数は、`SelectionColumnCustomComponent`オブジェクトを作成または更新するときに[`TableListBoxModel`](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")によって呼び出され、後で定義される`getSelection()`ヘルパー関数を使用して、行、列、および[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")からのトグル状態を設定します：

```cpp
void setRowAndColumn (int newRow, int newColumn)
{
    row = newRow;
    columnId = newColumn;
    toggleButton.setToggleState ((bool) owner.getSelection (row), juce::dontSendNotification);
}
```

`getSelection()`と`setSelection()`ヘルパー関数は以下のように定義されています：

```cpp
int getSelection (const int rowNumber) const
{
    return dataList->getChildElement (rowNumber)->getIntAttribute ("Select");
}
```

ここでは、[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")内の子要素から行番号と列番号のトグル状態を見つけます。

```cpp
void setSelection (const int rowNumber, const int newSelection)
{
    dataList->getChildElement (rowNumber)->setAttribute ("Select", newSelection);
}
```

ここでは、行番号と列番号から[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")内の子要素にトグル状態を格納します。

:::note
演習：[ComboBox](https://docs.juce.com/master/classComboBox.html "A component that lets the user choose from a drop-down list of choices.")、[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")、または[Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.")コンポーネントを組み込んだ追加のカスタムセルコンポーネントを作成してください。
:::

## データのソート

テーブルが選択した列に基づいて要素をソートするには、[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")オブジェクトの`sortChildElements()`関数によって使用されるテンプレートクラスとして渡すことができるコンパレータクラスを定義する必要があります。

このクラスを`TutorialDataSorter`と名付け、ソートする[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")属性の名前とソートアルゴリズムの昇順または降順の方向を追跡します：

```cpp
class TutorialDataSorter
{
public:
    TutorialDataSorter (const juce::String& attributeToSortBy, bool forwards)
        : attributeToSort (attributeToSortBy),
          direction (forwards ? 1 : -1)
    {
    }
```

```cpp
private:
    juce::String attributeToSort;
    int direction;
};
```

`sortChildElements()`関数が`TutorialDataSorter`を有効なコンパレータとして認識するためには、2 つの[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")オブジェクトを受け取り、順序を int として返す`compareElements()`という名前の関数を宣言する必要があります。

この関数は以下を返す必要があります：

- 最初のものが 2 番目のものより前に来る場合は負の値。
- 2 つのオブジェクトが等価な場合は 0 の値。
- 2 番目のものが最初のものより前に来る場合は正の値。

```cpp
int compareElements (juce::XmlElement* first, juce::XmlElement* second) const
{
    auto result = first->getStringAttribute (attributeToSort)
                      .compareNatural (second->getStringAttribute (attributeToSort)); // [1]

    if (result == 0)
        result = first->getStringAttribute ("ID")
                     .compareNatural (second->getStringAttribute ("ID")); // [2]

    return direction * result; // [3]
}
```

したがって、上記の関数では、同じルールセットで int を返す[String](https://docs.juce.com/master/classString.html "The JUCE String class!")クラスの`compareNatural()`メソッドを使用して、両方の XmlElement の文字列属性を比較します[1]。問題の属性の 2 つの文字列が等価な場合、これら 2 つの要素の ID 列を比較します[2]。最後に、ソートの方向が逆の場合は結果を反転する必要があります[3]。

## モデルの設定

[TableListBoxModel](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")を実装して、すべてのピースを組み立てましょう。

まず、ここに示すように`TableTutorialComponent`クラスで[TableListBoxModel](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")クラスを継承します：

```cpp
class TableTutorialComponent : public juce::Component,
                               public juce::TableListBoxModel
{
```

```cpp
private:
    juce::TableListBox table { {}, this };
    juce::Font font { 14.0f };

    std::unique_ptr<juce::XmlElement> tutorialData;
    juce::XmlElement* columnList = nullptr;
    juce::XmlElement* dataList = nullptr;
    int numRows = 0;
```

ここでは、[TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header.")メンバー変数を定義し、このクラスをその[TableListBoxModel](https://docs.juce.com/master/classTableListBoxModel.html "One of these is used by a TableListBox as the data model for the table's contents.")として設定します。これは、このシナリオではモデルクラスが実際にテーブル自体を保持していることを意味します。また、モデルが必要とするテーブル内の行数も追跡しています。

クラスコンストラクタでは、[TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header.")を子[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")として追加します[1]。また、アウトライン色とその厚さなど、テーブルの外観のプロパティを指定することもできます[2]。

```cpp
addAndMakeVisible (table); // [1]

table.setColour (juce::ListBox::outlineColourId, juce::Colours::grey); // [2]
table.setOutlineThickness (1);
```

```cpp
table.getHeader().setSortColumnId (1, true); // [3]

table.setMultipleSelectionEnabled (true); // [4]
```

ソート列と列の表示/非表示は、テーブルの[TableHeaderComponent](https://docs.juce.com/master/classTableHeaderComponent.html "A component that displays a strip of column headings for a table, and allows these to be resized,...")に対して対応する関数を呼び出すことで設定され[3]、テーブルでの複数選択も許可します[4]。

オーバーライドする最初の関数は、行数を保持するメンバー変数を返す`getNumRows()`関数です。この関数は、モデルがテーブルを適切に更新するために必要です：

```cpp
int getNumRows() override
{
    return numRows;
}
```

`paintRowBackground()`関数は、まずテーブルのデフォルト背景色を補完する交互色を見つけることで実装されます：

```cpp
void paintRowBackground (juce::Graphics& g, int rowNumber, int /*width*/, int /*height*/, bool rowIsSelected) override
{
    auto alternateColour = getLookAndFeel().findColour (juce::ListBox::backgroundColourId).interpolatedWith (getLookAndFeel().findColour (juce::ListBox::textColourId), 0.03f);
    if (rowIsSelected)
        g.fillAll (juce::Colours::lightblue);
    else if (rowNumber % 2)
        g.fillAll (alternateColour);
}
```

行が選択されている場合は薄い青で塗りつぶされ、そうでなければこの交互色で他のすべての行を塗りつぶします。

セルにコンテンツを埋めるために、`paintCell()`関数を以下のようにオーバーライドします：

```cpp
void paintCell (juce::Graphics& g, int rowNumber, int columnId, int width, int height, bool rowIsSelected) override
{
    g.setColour (rowIsSelected ? juce::Colours::darkblue : getLookAndFeel().findColour (juce::ListBox::textColourId)); // [5]
    g.setFont (font);

    if (auto* rowElement = dataList->getChildElement (rowNumber))
    {
        auto text = rowElement->getStringAttribute (getAttributeNameForColumnId (columnId));

        g.drawText (text, 2, 0, width - 4, height, juce::Justification::centredLeft, true); // [6]
    }

    g.setColour (getLookAndFeel().findColour (juce::ListBox::backgroundColourId));
    g.fillRect (width - 1, 0, 1, height); // [7]
}
```

- [5]：まず、行が選択されているかどうかに応じて適切なテキストの色を選択し、フォントサイズを設定します。
- [6]：子行要素が[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")オブジェクトに存在する場合、行から適切な列を取得し、セルに[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")からの対応するテキストを埋めます。
- [7]：最後に、デフォルトの背景色でセルの右側に区切り線を描画します。

```cpp
void sortOrderChanged (int newSortColumnId, bool isForwards) override
{
    if (newSortColumnId != 0)
    {
        TutorialDataSorter sorter (getAttributeNameForColumnId (newSortColumnId), isForwards);
        dataList->sortChildElements (sorter);

        table.updateContent();
    }
}
```

ユーザーによってソート順序の変更が要求されると、`sortOrderChanged()`コールバック関数が呼び出され、ソート列が有効な場合、正しい属性と方向で`TutorialDataSorter`オブジェクトをインスタンス化します。次に、そのオブジェクトを[XmlElement](https://docs.juce.com/master/classXmlElement.html "Used to build a tree of elements representing an XML document.")の`sortChildElements()`関数に渡し、テーブルに対して`updateContent()`を呼び出すことでテーブルの更新を強制します。

`refreshComponentForCell()`関数は、カスタムセルコンポーネントをインスタンス化および更新できる場所です：

```cpp
Component* refreshComponentForCell (int rowNumber, int columnId, bool /*isRowSelected*/, Component* existingComponentToUpdate) override
{
    if (columnId == 9) // [8]
    {
        auto* selectionBox = static_cast<SelectionColumnCustomComponent*> (existingComponentToUpdate);

        if (selectionBox == nullptr)
            selectionBox = new SelectionColumnCustomComponent (*this);

        selectionBox->setRowAndColumn (rowNumber, columnId);
        return selectionBox;
    }

    if (columnId == 8) // [9]
    {
        auto* textLabel = static_cast<EditableTextCustomComponent*> (existingComponentToUpdate);

        if (textLabel == nullptr)
            textLabel = new EditableTextCustomComponent (*this);

        textLabel->setRowAndColumn (rowNumber, columnId);
        return textLabel;
    }

    jassert (existingComponentToUpdate == nullptr);
    return nullptr; // [10]
}
```

- [8]：関数が選択セルの正しい「Select」列で呼び出された場合、`SelectionColumnCustomComponent`がセルに既に存在するかどうかをチェックします。存在しない場合は新しいインスタンスをインスタンス化し、`setRowAndColumn()`関数を呼び出してその内容を更新し、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")を返します。
- [9]：関数がテキストエディターセルの正しい「Description」列で呼び出された場合、`EditableTextCustomComponent`がセルに既に存在するかどうかをチェックします。存在しない場合は新しいインスタンスをインスタンス化し、`setRowAndColumn()`関数を呼び出してその内容を更新し、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")を返します。
- [10]：それ以外の場合、関数が通常の列で呼び出されたことを意味し、そのセルのカスタム[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")オブジェクトは存在しないはずです。

最後に、[TableListBox](https://docs.juce.com/master/classTableListBox.html "A table of cells, using a TableHeaderComponent as its header.")は、`getColumnAutoSizeWidth()`関数で以下に定義された自動動作に従って列をリサイズできる便利な機能を提供します：

```cpp
int getColumnAutoSizeWidth (int columnId) override
{
    if (columnId == 9)
        return 50;

    int widest = 32;

    for (auto i = getNumRows(); --i >= 0;)
    {
        if (auto* rowElement = dataList->getChildElement (i))
        {
            auto text = rowElement->getStringAttribute (getAttributeNameForColumnId (columnId));

            widest = juce::jmax (widest, font.getStringWidth (text));
        }
    }

    return widest + 8;
}
```

ここでは、特定の列のすべての要素を検査し、セル内の最も幅の広いテキストを取得することを決定します。次に、パディングを追加した幅、または列がカスタム[ToggleButton](https://docs.juce.com/master/classToggleButton.html "A button that can be toggled on/off.")を持つ「Select」列の場合は固定幅を返します。

:::note
演習：追加の列やデータを追加し、それに応じて実装を変更して、XML ドキュメントの内容を変更してください。
:::

## まとめ

このチュートリアルでは、テーブルに情報を表示する方法を学びました。特に、以下のことを行いました：

- XML を使用してテーブルにデータを読み込む。
- テーブルセルにカスタムコンポーネントを組み込む。
- カスタムソート動作に従ってテーブルデータをソートする。

## 関連項目

- [チュートリアル：Label クラス](../tutorial_label/)
- [チュートリアル：ComboBox クラス](../tutorial_combo_box/)
- [チュートリアル：Slider クラス](../tutorial_slider_values/)
- [チュートリアル：ラジオボタンとチェックボックス](../tutorial_radio_buttons_checkboxes/)
