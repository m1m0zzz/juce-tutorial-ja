---
title: 親コンポーネントと子コンポーネント
sidebar_position: 1
tags: [初級]
---

# チュートリアル：親コンポーネントと子コンポーネント

<SourcePageLink path="tutorial_component_parents_children" />

このチュートリアルでは、1 つのコンポーネントが 1 つ以上のネストされた子コンポーネントを含むことができる[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスの階層的な性質を紹介します。これは JUCE でユーザーインターフェースをレイアウトするための鍵となります。

**レベル:** 初級<br/>
**プラットフォーム:** Windows, macOS, Linux, iOS, Android<br/>
**クラス:** [Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects."), [Path](https://docs.juce.com/master/classPath.html "A path is a sequence of lines and curves that may either form a closed shape or be open-ended."), [Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)")

## はじめに

:::tip
このチュートリアルは[チュートリアル：Graphics クラス](../../graphics/tutorial_graphics_class/)の続きです。まず最初にそのチュートリアルを読んで理解しておく必要があります。
:::

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/ComponentParentsChildrenTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/ComponentParentsChildrenTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルを Projucer で開いてください。

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucer を始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトは、以下のスクリーンショットに示すように、家のシンプルな描画を含むシーンを表示します：

<CaptionImage
  src="/_images/tutorial_component_parents_children_screenshot1.png"
  caption="別々の要素で構成されたシーン"
/>

見覚えがありますか？[チュートリアル：Graphics クラス](../../graphics/tutorial_graphics_class/)の最終結果とかなり似ています！ここでの違いは、各パーツが別々の`paint()`関数を使用して別々の[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")オブジェクトに描画されていることです。後で見るように、これらは論理的にグループ化されています。例えば、家の壁と屋根は 1 つの「家」オブジェクトにグループ化されています。

これがどのように組み立てられているか、そしてなぜこのようにコンポーネントを構造化することが良いアイデアなのかを探りましょう。

## Component クラスの階層

ほとんどのユーザーインターフェースは、テキスト、ボタン、スライダー、メニューなど、多数の要素で構成されています。例えば、以下のスクリーンショットは[AudioDeviceSelectorComponent](https://docs.juce.com/master/classAudioDeviceSelectorComponent.html "A component containing controls to let the user change the audio settings of an AudioDeviceManager ob...")クラスを示しています（これはオーディオハードウェア設定を制御するためのものです。詳細については[チュートリアル：AudioDeviceManager クラス](../../audio/tutorial_audio_device_manager/)を参照してください）。これにはボタン、いくつかのラベル、いくつかのメニュー（コンボボックス）、いくつかのラジオボタン、オーディオレベルインジケーターが含まれています。

<CaptionImage
  src="/_images/tutorial_component_parents_children_screenshot2.png"
  caption="オーディオハードウェア設定を制御するためのユーザーインターフェース"
/>

個々のユーザーインターフェース要素の中には、他のユーザーインターフェース要素をグループ化してより便利なコントロールを形成するものもあります。例えば、JUCE の[Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.")クラスは、スライダー自体だけでなく、スライダーの現在の値を表示するテキストボックスも含むことができます。これは以下のスクリーンショットに示されています：

<CaptionImage
  src="/_images/tutorial_component_parents_children_screenshot3.png"
  caption="JUCEのSliderクラス"
/>

これらの各ケースで、個々の要素を階層の別々の部分に分離することで、インターフェースのレイアウトを設計し（ユーザーインタラクションに応答する）ことがはるかに容易になります。一部のコンポーネントは`paint()`関数を使用して自分自身を描画します。他のコンポーネントは単に他のコンポーネントを含むだけです。一部のコンポーネントは他のコンポーネントを含み*かつ*描画も行います。設計の選択はかなり柔軟です。

## MainContentComponent クラス

このチュートリアルでは、`MainContentComponent`クラスは別のコンポーネントクラスのインスタンスをメンバーとして含んでいます。これは実際のシーンを描画する`SceneComponent`クラスです。プロジェクト内の`MainContentComponent`クラスを見てください。SceneComponent オブジェクトが private メンバーとして追加されています：

```cpp
private:
    SceneComponent scene;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)
};
```

### 子コンポーネントの追加

`MainContentComponent`コンストラクタ内で、この`SceneComponent`オブジェクトは*子*コンポーネントとして追加され、`MainContentComponent`オブジェクトはその*親*になります。

:::warning
子コンポーネントは常に 1 つの親を持つ必要があります。必要に応じて、子コンポーネントを親から削除してから別の親に追加できます。
:::

子コンポーネントを表示するには、可視にする必要もあります。これら 2 つのステップは別々に行うこともできますが、JUCE では一般的に Component::addAndMakeVisible()関数を使用して両方のアクションを 1 つのステップで実行します：

```cpp
MainContentComponent()
{
    addAndMakeVisible (scene);
    setSize (600, 400);
}
```

### 子コンポーネントの境界の設定

`MainContentComponent`クラスは構築中に独自のサイズを設定しますが、多くのコンポーネントオブジェクトは最初はゼロサイズです。Component::setSize()関数の呼び出しは、`MainContentComponent::resized()`関数の呼び出しをトリガーします。これは子コンポーネントのサイズと位置を設定するのに適した場所です：

```cpp
void resized() override
{
    scene.setBounds (0, 0, getWidth(), getHeight());
}
```

ここで重要なのは、`SceneComponent::setBounds()`関数の呼び出しの座標は、親コンポーネント（この場合は`MainContentComponent`オブジェクト）に対して相対的であるということです。これは、親コンポーネントの左上隅が点`(0, 0)`であり、子コンポーネントはその左上隅がこの点に対して相対的に配置されることを意味します。実際、`SceneComponent`オブジェクトは`MainContentComponent`オブジェクトの内容全体を埋めます。これを書く別の方法は、Component::getLocalBounds()関数を使用することです。これは、呼び出したコンポーネントの境界を表す[Rectangle](https://docs.juce.com/master/classRectangle.html "Manages a rectangle and allows geometric operations to be performed on it.")オブジェクトを返します。これにより、位置`(0, 0)`と幅と高さのサイズを持つ矩形が得られます。この[Rectangle](https://docs.juce.com/master/classRectangle.html "Manages a rectangle and allows geometric operations to be performed on it.")オブジェクトは`SceneComponent::setBounds()`関数に渡すことができます。代替コードは以下のコードスニペットに示されています：

```cpp
void resized() override
{
    scene.setBounds (getLocalBounds());
}
```

このチュートリアルの次のセクションは、この`SceneComponent`オブジェクトの構造を反映しています。

:::tip
子コンポーネントは親コンポーネントの境界を超える位置に配置できますが、親コンポーネントの境界外のすべては描画されません。コンポーネントが見えない場合は、境界が正しく設定されていることを確認してください（例えば、親コンポーネントの`resized()`関数内で）。
:::

## シーン

`SceneComponent`クラスは独自の描画を行い、2 つの子コンポーネント（床と家を表す）を含んでいます。`SceneComponent`の宣言は以下のとおりです：

```cpp
class SceneComponent : public juce::Component
{
    // ...
private:
    FloorComponent floor;
    HouseComponent house;

    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SceneComponent)
};
```

`FloorComponent`と`HouseComponent`オブジェクトはコンストラクタで追加され、可視にされます：

```cpp
SceneComponent()
{
    addAndMakeVisible (floor);
    addAndMakeVisible (house);
}
```

空を描画するために、`SceneComponent::paint()`関数でコンポーネント全体を水色で塗りつぶします。

```cpp
void paint (juce::Graphics& g) override
{
    g.fillAll (juce::Colours::lightblue);
}
```

床と家は`SceneComponent::resized()`関数内で境界が位置付けられます：

```cpp
void resized() override
{
    floor.setBounds (10, 297, 580, 5);
    house.setBounds (300, 70, 200, 220);
}
```

:::tip
コンポーネントは最初に自分自身を描画し、次に子コンポーネントがその上に描画されます。子コンポーネントの上に描画する必要がある場合は、Component::paintOverChildren()関数をオーバーライドできます。子コンポーネントは親コンポーネントに追加された順序で描画されます。これは後で Component::toFront()、Component::toBack()、Component::toBehind()、または Component::setAlwaysOnTop()関数を使用して調整できます。
:::

床と家がそれぞれのクラス内でどのように描画されているか見てみましょう。

### 床

床は[チュートリアル：Graphics クラス](../../graphics/tutorial_graphics_class/)と同様に、5 ピクセルの太さの緑色の水平線として描画され、コンポーネント内で垂直方向に中央に配置され、全幅にわたります。`FloorComponent::paint()`関数（`FloorComponent`クラスから）は以下のとおりです：

```cpp
void paint (juce::Graphics& g) override
{
    g.setColour (juce::Colours::green);
    g.drawLine (0.0f, (float) getHeight() / 2.0f, (float) getWidth(), (float) getHeight() / 2.0f, 5.0f);
}
```

### 家

家自体は独自の描画を行わず（`paint()`関数を持たない）、`HouseComponent`クラス内の 2 つの他のコンポーネント（家の壁と屋根を表す）で構成されています：

```cpp
class HouseComponent : public juce::Component
{
    // ...
private:
    WallComponent wall;
    RoofComponent roof;

    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HouseComponent)
};
```

`WallComponent`と`RoofComponent`オブジェクトはコンストラクタで追加され、可視にされます：

```cpp
HouseComponent()
{
    addAndMakeVisible (wall);
    addAndMakeVisible (roof);
}
```

これらは`HouseComponent::resized()`関数内で比例的に位置付けられます：

```cpp
void resized() override
{
    auto separation = juce::jlimit (2, 10, getHeight() / 20); // [1]

    roof.setBounds (0, 0, getWidth(), (int) (getHeight() * 0.2) - separation / 2); // [2]
    wall.setBounds (0, (int) (getHeight() * 0.20) + separation / 2, getWidth(), (int) (getHeight() * 0.80) - separation); // [3]
}
```

- [1]：まず屋根と壁の間の隔を計算します。家の高さの<sup>1</sup>⁄<sub>20</sub>にしますが、[jlimit()](https://docs.juce.com/master/namespacejuce.html#a595f2864812b76f88ed833402d0dfc93)関数を使用して 2 ピクセルより小さくならないようにします。これにより、高さが小さい場合でも屋根と壁の間に常にギャップができます。高さが大きい場合、ギャップは高さに比例したままになります。
- [2]：屋根は家の全幅で、家の高さの<sup>1</sup>/<sub>5</sub>に設定されます。これは間隔を考慮して調整されます。
- [3]：壁は屋根の下に位置し、家の高さの<sup>4</sup>/<sub>5</sub>を占めます。これも間隔を考慮して調整されます。

#### 壁

`WallComponent`クラスはシンプルです。`WallComponent::paint()`関数（`WallComponent`クラスから）でチェッカーボードパターンで自分自身を塗りつぶすだけです：

```cpp
void paint (juce::Graphics& g) override
{
    g.fillCheckerBoard (getLocalBounds().toFloat(), 30, 10, juce::Colours::sandybrown, juce::Colours::saddlebrown);
}
```

#### 屋根

`RoofComponent`クラスは`RoofComponent::paint()`関数で[Path](https://docs.juce.com/master/classPath.html "A path is a sequence of lines and curves that may either form a closed shape or be open-ended.")オブジェクトを使用して三角形を描画します：

```cpp
void paint (juce::Graphics& g) override
{
    g.setColour (juce::Colours::red);

    juce::Path roof;
    roof.addTriangle (0.0f, (float) getHeight(), (float) getWidth(), (float) getHeight(), (float) getWidth() / 2.0f, 0.0f);
    g.fillPath (roof);
}
```

`RoofComponent`オブジェクトの幅を`w`、高さを`h`とすると、三角形を構成する 3 つの点は：`(0, h)`、`(w, h)`、(<sup>w</sup>/<sub>2</sub>, 0)です。

:::note
演習：シーン内のオブジェクトの位置を変更してみてください。
:::

## 太陽の追加

シーンに太陽を追加しましょう。`SunComponent`クラスにいくつかの空の関数が用意されており、すぐにコードを追加します。

まず、`SceneComponent`クラスにいくつかの変更を加える必要があります。private セクションに`SunComponent`クラスのインスタンスを追加します[4]：

```cpp
private:
    FloorComponent floor;
    HouseComponent house;
    SunComponent sun; // [4]

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SceneComponent)
};
```

次に太陽を追加して可視にします[5]：

```cpp
SceneComponent()
{
    addAndMakeVisible (floor);
    addAndMakeVisible (house);
    addAndMakeVisible (sun); // [5]
}
```

そして太陽を右上隅に位置付けます[6]：

```cpp
void resized() override
{
    floor.setBounds (10, 297, 580, 5);
    house.setBounds (300, 70, 200, 220);
    sun.setBounds (530, 10, 60, 60); // [6]
}
```

`SunComponent::paint()`関数（`SunComponent`クラス内）に描画コードを追加する必要があります：

```cpp
void paint (juce::Graphics& g) override
{
    g.setColour (juce::Colours::yellow);

    auto lineThickness = 3.0f;
    g.drawEllipse (lineThickness * 0.5f,
        lineThickness * 0.5f,
        (float) getWidth() - lineThickness * 2,
        (float) getHeight() - lineThickness * 2,
        lineThickness);
}
```

楕円をコンポーネントの境界内にわずかに位置付ける必要があることに注意してください。これは線の太さに依存する必要があります。これは、線の中心が指定された座標に正確に位置するためです。例えば、コンポーネントの端に線を描画すると、線の太さの半分がコンポーネントの境界外に位置します。楕円の位置とサイズをわずかに調整しなかった場合に何が起こるかを見るために、以下のスクリーンショットを見てください。

<CaptionImage
  src="/_images/tutorial_component_parents_children_screenshot4.png"
  caption="描画はコンポーネントの境界にクリップされる"
/>

:::tip
これを回避する別の方法は、Component::setPaintingIsUnclipped()関数を使用して、コンポーネントが境界を超えて描画できるようにすることです。この関数の使用にはいくつかの注意点があるため、必ず[API](https://juce.com/doc/classes)ドキュメントを読んでください。
:::

最終的なシーンは次のようになります：

<CaptionImage
  src="/_images/tutorial_component_parents_children_screenshot5.png"
  caption="最終的なシーン"
/>

:::tip
このステップの変更されたコードは、デモプロジェクトの`ComponentParentsChildrenTutorial_02.h`ファイルにあります。
:::

<!-- -->

:::note
演習：上記のコードを使用すると、太陽は常に楕円として描画されます。`SunComponent`オブジェクトを正方形に指定しているため、この潜在的な問題に気づきません。`SunComponent`クラスを修正して、幅と高さが同じでなくても、常に境界内に楕円ではなく円を描画するようにしてください。
:::

## コンポーネントの再利用

[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスが使用する座標系の主な利点の 1 つは、描画が常にコンポーネントの左上に対して相対的に実行されることです。描画を別のクラスにカプセル化するもう 1 つの利点は、簡単に再利用できることです。

例えば、`SceneComponent`クラスに別の家[7]を簡単に追加できます：

```cpp
private:
    FloorComponent floor;
    HouseComponent house;
    HouseComponent smallHouse; // [7]
    SunComponent sun;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SceneComponent)
};
```

次に`SceneComponent`コンストラクタで追加して可視にします[8]：

```cpp
SceneComponent()
{
    addAndMakeVisible (floor);
    addAndMakeVisible (house);
    addAndMakeVisible (smallHouse); // [8]
    addAndMakeVisible (sun);
}
```

そして`SceneComponent::resized()`関数で位置付けます[9]：

```cpp
void resized() override
{
    floor.setBounds (10, 297, 580, 5);
    house.setBounds (300, 70, 200, 220);
    smallHouse.setBounds (50, 50, 50, 50); // [9]
    sun.setBounds (530, 10, 60, 60);
}
```

小さな家を追加すると、シーンは次のようになります：

<CaptionImage
  src="/_images/tutorial_component_parents_children_screenshot6.png"
  caption="追加の小さな家を含む最終的なシーン"
/>

:::tip
この最終ステップの変更されたコードは、デモプロジェクトの`ComponentParentsChildrenTutorial_03.h`ファイルにあります。
:::

<!-- -->

:::note
演習：複数の`HouseComponent`オブジェクトを一列に並べて街を形成する新しいクラス`StreetComponent`を作成し、プロジェクトに追加してください。`SceneComponent`クラスを変更して、いくつかの街と個々の家を含むようにしてください。
:::

## まとめ

このチュートリアルでは、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスが使用する階層的な親子システムを紹介しました。特に以下のことを学びました：

- Component::addAndMakeVisible()関数を使用して子コンポーネントを他のコンポーネントに追加する方法。
- 子コンポーネントを親コンポーネントに対して相対的に位置付けてサイズ設定する方法。
- コンポーネントは独自の描画を行うことも、描画を行う子コンポーネントを含むことも、両方を行うこともできること。
- コンポーネントは最初に描画を行い、次に子コンポーネントが親に追加された順序で描画されること。
- 描画は通常コンポーネントの境界にクリップされること。

## 関連項目

- [チュートリアル：Graphics クラス](../../graphics/tutorial_graphics_class/)
- [チュートリアル：アプリのルック＆フィールをカスタマイズ](../tutorial_look_and_feel_customisation/)
- [チュートリアル：Point、Line、Rectangle クラス](../tutorial_point_line_rectangle/)
- [チュートリアル：高度な GUI レイアウト技術](../tutorial_rectangle_advanced/)
- [チュートリアル：OpenGL アプリケーションの構築](../../graphics/tutorial_open_gl_application/)
