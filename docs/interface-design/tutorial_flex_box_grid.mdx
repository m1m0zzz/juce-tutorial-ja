---
title: FlexBox と Grid を使用したレスポンシブ GUI レイアウト
sidebar_position: 6
tags: [中級]
---

# チュートリアル：FlexBox と Grid を使用したレスポンシブ GUI レイアウト

<SourcePageLink path="tutorial_flex_box_grid" />

[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")と[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")クラスを使用して、さまざまな画面サイズと向きで動作するレスポンシブ GUI レイアウトを構築します。

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux, iOS, Android<br/>
**クラス:** [FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects."), [FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container."), [Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ..."), [GridItem](https://docs.juce.com/master/classGridItem.html "Defines an item in a Grid.")

## はじめに

このチュートリアルは、[チュートリアル：高度な GUI レイアウト技術](../tutorial_rectangle_advanced/)で説明されている[Rectangle](https://docs.juce.com/master/classRectangle.html "Manages a rectangle and allows geometric operations to be performed on it.")クラスを使用したシンプルなレイアウト技術の理解を前提としています。まだ行っていない場合は、まずそのチュートリアルを読んでください。

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/FlexBoxGridTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/FlexBoxGridTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルを Projucer で開いてください。

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucer を始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトは、可変画面サイズと解像度を扱うときに[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")と[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")オブジェクトを使用したさまざまなレスポンシブレイアウト技術を示します。最初にプロジェクトを初期状態で実行すると、以下のようになるはずです：

<CaptionImage
  src="/_images/tutorial_flex_box_grid_screenshot1.png"
  caption="デモプロジェクトアプリケーションウィンドウ"
/>

現在、レイアウトは一般的な非レスポンシブ技術を使用して画面上にコンポーネントをレイアウトしており、向きの変更に対応していません。これらの問題を解消するために[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")と[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")アイテムを使用します。

## FlexBox と Grid レイアウトシステム

[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")と[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")クラスは、CSS Web 開発で使用されるレスポンシブレイアウトプラクティスに強くインスパイアされています。以前にレスポンシブ Web サイトをデザインしたことがあれば、このセクションで説明するレイアウトシステムに馴染みがあるはずです。

[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")を使用する場合、まずレイアウトの方向を水平または垂直として定義する必要があり、その後のすべての計算はこの基礎に基づいて実行されます。この方向を*メイン軸*と呼び、その垂直方向を*クロス軸*と呼びます。この情報に基づいて、以下のプロパティが次のようにレイアウトに影響します：

- 配置（Justification）はメイン軸に沿った項目の位置に影響します。
- 整列（Alignment）はクロス軸に沿った項目の位置に影響します。
- 折り返し（Wrapping）はメイン軸での項目のオーバーフロー時にクロス軸に溢れることで実行されます。

コンテナ内の項目は[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")クラスによって定義され、動的リサイズに影響する 3 つの柔軟なプロパティがあります：

- Flex-grow は必要に応じて項目が成長する能力を定義します。
- Flex-shrink は必要に応じて項目が縮小する能力を定義します。
- Flex-basis は動的リサイズ前の項目のデフォルトサイズを定義します。

2 次元レイアウトシステムとして、[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")は*行*軸と*列*軸の両方で動作します。[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")と同様に、以下のプロパティが次のようにレイアウトに影響します：

- 配置（Justification）は行軸に沿った項目の位置に影響します。
- 整列（Alignment）は列軸に沿った項目の位置に影響します。
- 折り返し（Wrapping）は行または列での項目のオーバーフロー時に実行できます。

[GridItem](https://docs.juce.com/master/classGridItem.html "Defines an item in a Grid.")オブジェクトは[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")内に含まれ、サイズに影響する便利なプロパティがあります：

- マージンは特定の項目の周りにギャップを提供できます。
- [Span](https://docs.juce.com/master/classSpan.html "A non-owning view over contiguous objects stored in an Array or vector or other similar container.")は複数のグリッドセルを埋めるように項目を拡張できます。

特定のプロパティがこれらのレイアウトシステムにどのように影響するかがわかったので、デモプロジェクトでこれらの変更を実装し始めることができます。

## FlexItem と GridItem オブジェクトの使用

まず、[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")を使用して`RightSidePanel::resized()`メソッドのボタンレイアウトを置き換えましょう：

```cpp
void resized() override
{
    juce::FlexBox fb; // [1]
    fb.flexWrap = juce::FlexBox::Wrap::wrap; // [2]
    fb.justifyContent = juce::FlexBox::JustifyContent::center; // [3]
    fb.alignContent = juce::FlexBox::AlignContent::center; // [4]

    for (auto* b : buttons) // [5]
        fb.items.add (juce::FlexItem (*b).withMinWidth (50.0f).withMinHeight (50.0f));

    fb.performLayout (getLocalBounds()); // [6]
}
```

- [1]：[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")オブジェクトを作成します。
- [2]：オーバーフローの場合にオブジェクトを折り返すかどうかを指定できます。
- [3]：コンテンツを境界の中央に配置します。
- [4]：コンテンツの整列を中央に指定します。
- [5]：[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")コンポーネントを反復し、[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")オブジェクトの items 配列に[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")オブジェクトとして追加します。[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")は、この場合ボタンの最小幅と高さを設定するように制約できます。`withMaxWidth()`と`withMaxHeight()`メソッドを使用して最大幅と高さを設定することもできます。
- [6]：`performLayout()`メソッドに境界を指定して[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")オブジェクトにレイアウトロジックを実行します。

左側パネルの回転スライダーレイアウトについては、`LeftSidePanel::resized()`メソッドを調整します：

```cpp
void resized() override
{
    //==============================================================================
    juce::FlexBox knobBox;
    knobBox.flexWrap = juce::FlexBox::Wrap::wrap;
    knobBox.justifyContent = juce::FlexBox::JustifyContent::spaceBetween; // [1]

    for (auto* k : knobs)
        knobBox.items.add (juce::FlexItem (*k).withMinHeight (50.0f).withMinWidth (50.0f).withFlex (1)); // [2]

    //==============================================================================
    juce::FlexBox fb; // [3]
    fb.flexDirection = juce::FlexBox::Direction::column;

    fb.items.add (juce::FlexItem (knobBox).withFlex (2.5)); // [4]

    fb.performLayout (getLocalBounds());
}
```

- [1]：今回は`JustifyContent::spaceBetween`プロパティを指定して項目を間隔を空けて配置したいことを指定します。
- [2]：ノブは同じ方法で items 配列に追加され、追加の flex-grow 値`1`があります。flex-grow ファクターは、コンテナ内で項目が占めるべきスペースの量を決定します。
- [3]：前に作成した[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")オブジェクトのコンテナとして機能する別の[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")が作成され、flex レイアウトのメイン軸が`Direction::column`プロパティで設定されます。
- [4]：前に定義した[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")が flex-grow ファクター`2.5`でコンテナ[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")に[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")として追加されます。

[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")オブジェクトをネストすると、コンポーネントの小さなグループをカプセル化することで、複雑なレスポンシブレイアウトを簡単に作成できます。

最後に、`MainPanel::resized()`メソッドでメインパネルのスライダーを向きの変更に対応させることができます：

```cpp
void resized() override
{
    auto isPortrait = getLocalBounds().getHeight() > getLocalBounds().getWidth(); // [1]

    juce::FlexBox fb;
    fb.flexDirection = isPortrait ? juce::FlexBox::Direction::column // [2]
                                  : juce::FlexBox::Direction::row;

    for (auto* s : sliders)
    {
        s->setSliderStyle (isPortrait ? juce::Slider::SliderStyle::LinearHorizontal // [3]
                                      : juce::Slider::SliderStyle::LinearVertical);

        fb.items.add (juce::FlexItem (*s).withFlex (0, 1, isPortrait ? (float) getHeight() / 5.0f // [4]
                                                                     : (float) getWidth() / 5.0f));
    }

    fb.performLayout (getLocalBounds());
}
```

- [1]：まず、幅と高さをチェックしてデバイスが縦向きか横向きかを判断します。
- [2]：次に、それに応じてメイン軸の方向を決定し、適切なプロパティを設定します。
- [3]：同様に、デバイスの向きに合わせて適切なスライダースタイルを設定します。
- [4]：スライダーを items 配列に追加するとき、フローの方向における各スライダーの比率を決定して flex-basis を提供します。

スライダーはデバイスの向きに適応し、それに応じて方向を調整するようになります。

最後に、パネルの全体的なレイアウトシステムも flex を使用するように変更できます：

```cpp
void resized() override
{
    juce::FlexBox fb;

    juce::FlexItem left ((float) getWidth() / 4.0f, (float) getHeight(), leftPanel);
    juce::FlexItem right ((float) getWidth() / 4.0f, (float) getHeight(), rightPanel);
    juce::FlexItem main ((float) getWidth() / 2.0f, (float) getHeight(), mainPanel);

    fb.items.addArray ({ left, main, right });
    fb.performLayout (getLocalBounds());
}
```

flex を使用するように修正したコードを実行すると、以下のようになるはずです：

<CaptionImage
  src="/_images/tutorial_flex_box_grid_screenshot2.png"
  caption="flexを使用したデモプロジェクトアプリケーションウィンドウ"
/>

:::tip
この修正版のコードのソースコードはデモプロジェクトの`FlexBoxGridTutorial_02.h`ファイルにあります。
:::

代わりに[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")クラスを使用してコードの最後の部分を実装してみましょう。ここでは、flex と同様にレイアウト操作を実行するための[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")オブジェクトを作成します：

```cpp
void resized() override
{
    juce::Grid grid;

    using Track = juce::Grid::TrackInfo;
    using Fr = juce::Grid::Fr;

    grid.templateRows = { Track (Fr (1)) };
    grid.templateColumns = { Track (Fr (1)), Track (Fr (2)), Track (Fr (1)) };

    grid.items = { juce::GridItem (leftPanel), juce::GridItem (mainPanel), juce::GridItem (rightPanel) };

    grid.performLayout (getLocalBounds());
}
```

ただし、個々の[FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")オブジェクトに flex-grow、flex-shrink、flex-basis の値を指定する代わりに、この場合は TrackInfo オブジェクトを使用して[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")オブジェクトに行と列の数を設定します。制約はそれぞれ`_fr`と`_px`サフィックスを使用して分数またはピクセルで指定できます。この例では、1 行 3 列のグリッドを定義し、中央の列が他の列の 2 倍のスペースを取ります。

:::warning
JUCE のピクセルは物理ピクセルと同等ではありません。内部計算により、画面の DPI 解像度に応じてピクセル密度が変換されます。
:::

<!-- -->

:::tip
この修正版のコードのソースコードはデモプロジェクトの`FlexBoxGridTutorial_03.h`ファイルにあります。
:::

## FlexBox と Grid クラスの長所と短所

レスポンシブレイアウトを作成するためにこれらのクラスのいずれかを使用できる多くのケースがあります。ただし、一方がより適切で、特定のレイアウト制約を解決するために必要な場合もあります。

[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")クラスの利点のいくつか：

- メイン軸が望ましいコンポーネントのレイアウトに適しています。
- コンテンツの折り返し、方向、整列が簡単に指定できます。
- クロス軸上の整列されていないコンテンツに対応できます。

[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")クラスの利点のいくつか：

- 行と列が整列された 2D グリッドタイプのレイアウトに適しています。
- コンポーネントの比率を分数またはピクセルで指定できます。
- 複数の行または列にまたがるコンテンツに対応できます。

:::note
演習：[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")クラスを使用して、前の[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")レイアウトを実装してください。[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")クラスがより適切だった不便なユースケースはありましたか？
:::

## まとめ

このチュートリアルでは、[FlexBox](https://docs.juce.com/master/classFlexBox.html "Represents a FlexBox container, which contains and manages the layout of a set of FlexItem objects.")と[Grid](https://docs.juce.com/master/classGrid.html "Container that handles geometry for grid layouts (fixed columns and rows) using a set of declarative ...")クラスを使用してレスポンシブレイアウトを設計する方法を学びました。特に以下のことを行いました：

- [FlexItem](https://docs.juce.com/master/classFlexItem.html "Describes the properties of an item inside a FlexBox container.")と[GridItem](https://docs.juce.com/master/classGridItem.html "Defines an item in a Grid.")オブジェクトのレイアウトロジックを学びました。
- 向きの変更を処理し、インターフェースを適応させました。
- これらのクラスの長所と短所について議論しました。

## 関連項目

- [チュートリアル：親コンポーネントと子コンポーネント](../tutorial_component_parents_children/)
- [チュートリアル：Graphics クラス](../../graphics/tutorial_graphics_class/)
- [チュートリアル：Point、Line、Rectangle クラス](../tutorial_point_line_rectangle/)
- [チュートリアル：高度な GUI レイアウト技術](../tutorial_rectangle_advanced/)
- [チュートリアル：Android の画面サイズの管理](../../mobile/tutorial_android_screen_sizes/)
