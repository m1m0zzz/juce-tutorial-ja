---
title: JUCE での色
sidebar_position: 3
tags: [初級]
---

# チュートリアル：JUCE での色

<SourcePageLink path="tutorial_colours" />

アプリケーション内でさまざまな方法で色を指定し適用します。

**レベル:** 初級<br/>
**プラットフォーム:** Windows, macOS, Linux, iOS, Android<br/>
**クラス:** [Colour](https://docs.juce.com/master/classColour.html "Represents a colour, also including a transparency value."), [Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)"), [LookAndFeel](https://docs.juce.com/master/classLookAndFeel.html "LookAndFeel objects define the appearance of all the JUCE widgets, and subclasses can be used to appl...")

## はじめに

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/ColoursTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/ColoursTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルを Projucer で開いてください。

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucer を始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトはいくつかの子コンポーネントを表示し、JUCE でコンポーネントに色を指定して適用する方法を示すシンプルな描画コマンドを実行します。アプリケーションは以下のスクリーンショットと同様に見えるはずです：

<CaptionImage
  src="/_images/tutorial_colours_screenshot1.png"
  caption="色デモアプリケーション"
/>

このチュートリアルの最初の部分では、より一般的な色の指定方法を見ていきます。これはデモアプリケーションの`paint()`関数内の描画コードを変更することで説明されます。チュートリアルの 2 番目の部分では、組み込みコンポーネントタイプ（ラベル、スライダーなど）の要素に色を指定する方法を示します。

## 色と一般的な描画操作

JUCE は赤、緑、青、アルファ（透明度）の値を使用して色を指定します。これはもちろん、コンピューティングで広く使用されている色を指定する方法ですが、すべての実装は若干異なります。特に、JUCE は色を操作するための便利なメソッドを提供しており、アプリケーションの一貫したカラーパレットを維持するのに役立ちます。まず、デモアプリケーションの`paint()`関数を見てみましょう：

```cpp
void paint (juce::Graphics& g) override
{
    g.fillAll (juce::Colours::lightgreen);
    g.setColour (juce::Colours::orange);

    auto centralArea = getLocalBounds().toFloat().reduced (10.0f);
    g.drawRoundedRectangle (centralArea, 5.0f, 3.0f);

    juce::Array<juce::Colour> colours { juce::Colours::red, juce::Colours::green, juce::Colours::blue };

    auto colourBarArea = centralArea.reduced (4.0f).withHeight (20.0f);
    auto colourArea = colourBarArea.withWidth (colourBarArea.getWidth() / (float) colours.size());

    for (auto colour : colours)
    {
        g.setColour (colour);
        g.fillRect (colourArea);

        colourArea.translate (colourArea.getWidth(), 0.0f);
    }
}
```

最初の行はグラフィックスコンテキスト全体を単一の色で塗りつぶします（これはコンポーネントの境界全体を意味します）：

```cpp
g.fillAll (juce::Colours::lightgreen);
```

次の行は、指定されたグラフィックスコンテキストで今後の描画操作の色を設定します。

```cpp
g.setColour (juce::Colours::orange);
```

次に、わずかにインセットした矩形を定義し、現在の色を使用して角丸矩形をボーダーとして描画します：

```cpp
auto centralArea = getLocalBounds().toFloat().reduced (10.0f);
g.drawRoundedRectangle (centralArea, 5.0f, 3.0f);
```

次に、異なる色の矩形の行を描画するために使用する色の配列を設定します。

```cpp
juce::Array<juce::Colour> colours { juce::Colours::red, juce::Colours::green, juce::Colours::blue };
```

この色付き矩形の行を描画するために、まずそれらが配置される領域を定義します：

```cpp
auto colourBarArea = centralArea.reduced (4.0f).withHeight (20.0f);
```

次に、最初の色付き矩形の領域を定義します。これは`colourBarArea`矩形の合計幅を使用する色の数で割った比率になります：

```cpp
auto colourArea = colourBarArea.withWidth (colourBarArea.getWidth() / colours.size());
```

最後に、色の配列を反復処理し、指定された色で矩形を塗りつぶし、次の反復のために`colourArea`矩形を右に移動します：

```cpp
for (auto colour : colours)
{
    g.setColour (colour);
    g.fillRect (colourArea);

    colourArea.translate (colourArea.getWidth(), 0.0f);
}
```

次のいくつかの例では、`colours`配列に追加する色を変更することで、色を指定するいくつかの方法を示します。

### 名前による色の指定

デモプロジェクトと上記のコードに示されているように、[Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)")名前空間のいくつかの定数を使用して JUCE で色を指定できます。

:::tip
利用可能な色の完全なリストについては、[Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)")名前空間の API ドキュメントを参照してください。これらはほとんど標準的な HTML 色です。
:::

[Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)")名前空間内の定数に加えて、[Colours::findColourForName()](https://docs.juce.com/master/namespacejuce_1_1Colours.html#af4f192e53312f7dd625afc1ce029025f "Attempts to look up a string in the list of known colour names, and return the appropriate colour.")関数を使用して、文字列を使用して目的の色名を検索できます。例えば、以下のコードを使用して`colours`配列を同じ赤、緑、青の色で埋めることができます：

```cpp
auto defaultColour = Colours::black;

juce::Array<juce::Colour> colours { juce::Colours::findColourForName ("red", defaultColour),
    juce::Colours::findColourForName ("green", defaultColour),
    juce::Colours::findColourForName ("blue", defaultColour) };
```

:::tip
名前付きの色の検索が失敗した場合に備えて、デフォルトの色を提供する必要があります（この場合は単に黒を使用）。
:::

[Colours::findColourForName()](https://docs.juce.com/master/namespacejuce_1_1Colours.html#af4f192e53312f7dd625afc1ce029025f "Attempts to look up a string in the list of known colour names, and return the appropriate colour.")関数は大文字と小文字を区別せずに検索し、文字列の先頭と末尾の空白を削除しますが、文字列内のスペースは削除しません。例えば、色は内部的にすべて小文字の文字列を使用して保存されていますが、以下のコードは期待通りに動作します：

```cpp
auto defaultColour = juce::Colours::black;

juce::Array<juce::Colour> colours { juce::Colours::findColourForName ("DarkRed", defaultColour),
    juce::Colours::findColourForName ("DarkGreen", defaultColour),
    juce::Colours::findColourForName ("DarkBlue", defaultColour) };
```

これにより以下の色が生成されます：

<CaptionImage
  src="/_images/tutorial_colours_screenshot2.png"
  caption="ダークレッド、グリーン、ブルー"
/>

しかし、色名内にスペースを含めると失敗し、各ケースで黒い色が返されます：

```cpp
auto defaultColour = Colours::black;

juce::Array<juce::Colour> colours { juce::Colours::findColourForName ("Dark Red", defaultColour),
    juce::Colours::findColourForName ("Dark Green", defaultColour),
    juce::Colours::findColourForName ("Dark Blue", defaultColour) };
```

これらのインスタンスで必要に応じて独自の関数を書くのは簡単です。例えば、文字列からすべてのスペースを削除する関数を書くことができます：

```cpp
static juce::String removeSpaces (const juce::String& text)
{
    return text.removeCharacters (" ");
}
```

そして[Colours::findColourForName()](https://docs.juce.com/master/namespacejuce_1_1Colours.html#af4f192e53312f7dd625afc1ce029025f "Attempts to look up a string in the list of known colour names, and return the appropriate colour.")関数に文字列を渡すときにそれを使用します：

```cpp
auto defaultColour = juce::Colours::black;

juce::Array<juce::Colour> colours { juce::Colours::findColourForName (removeSpaces ("Dark Red"), defaultColour),
    juce::Colours::findColourForName (removeSpaces ("Dark Green"), defaultColour),
    juce::Colours::findColourForName (removeSpaces ("Dark Blue"), defaultColour) };
```

### 値による色の指定

[Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)")は、生の赤、緑、青、アルファ値を使用して指定することもできます。ここでは、0.0〜1.0 の範囲の浮動小数点値、または 0〜255 の整数（uint8 型）を使用して[Colour](https://docs.juce.com/master/classColour.html "Represents a colour, also including a transparency value.")オブジェクトを作成できます。整数を使用すると、同じ赤、緑、青の色を次のように作成できます：

```cpp
juce::Array<juce::Colour> colours { juce::Colour (255, 0, 0), // red
    juce::Colour (0, 128, 0), // green
    juce::Colour (0, 0, 255) }; // blue
```

:::tip
標準の「green」色は、色の緑要素に最大値 255 を持っていません。
:::

この場合、アルファ値を省略するとアルファ値は最大（255）に設定され、色は完全に不透明になります。

単一の 16 進数値を使用して色を指定することもできます。この場合、色値要素の順序は：アルファ、赤、緑、青です：

```cpp
juce::Array<juce::Colour> colours { juce::Colour (0xffff0000), // red
    juce::Colour (0xff008000), // green
    juce::Colour (0xff0000ff) }; // blue
```

:::tip
この場合、アルファ値を指定しないとゼロに設定される（したがって透明になる）ため、必ずアルファ値を指定する必要があります。
:::

[Colour::fromFloatRGBA()](https://docs.juce.com/master/classColour.html#a3992d5ea9bdaf0471bd6caa0595b0185 "Creates a colour using floating point red, green, blue and alpha values.")関数を使用して浮動小数点値も使用できます：

```cpp
juce::Array<juce::Colour> colours { juce::Colour::fromFloatRGBA (1.0f, 0.0f, 0.0f, 1.0f), // red
    juce::Colour::fromFloatRGBA (0.0f, 0.5f, 0.0f, 1.0f), // green
    juce::Colour::fromFloatRGBA (0.0f, 0.0f, 1.0f, 1.0f) }; // blue
```

:::tip
整数値 128 は約 0.501961 の浮動小数点値に相当します。したがって、緑の色は前の例と*完全に*同じではありませんが、0.5 はこのデモには十分近いです。
:::

<!-- -->

:::note
異なる色値を試して、アプリケーションを実行して結果を確認してください。`colours`配列に追加する色は 3 つに限定されず、任意の数（1 以上）の色を使用できます。
:::

### 色相、彩度、明度

[Colour](https://docs.juce.com/master/classColour.html "Represents a colour, also including a transparency value.")オブジェクトは、色相、彩度、明度の値から初期化することもできます。これは、いくつかの知覚的特性を共有する異なる色を生成する 1 つの方法です。

例えば、以下のコードを使用して、明るい赤と暗い赤のシリーズを作成できます：

```cpp
juce::Array<juce::Colour> colours { juce::Colour::fromHSV (0.0f, // hue
                                        0.5f, // saturation
                                        0.3f, // brightness
                                        1.0f), // alpha
    juce::Colour::fromHSV (0.0f, 0.5f, 0.5f, 1.0f),
    juce::Colour::fromHSV (0.0f, 0.5f, 0.7f, 1.0f) };
```

ここでは、各色の色相、彩度、アルファ値は一定です（0.0f の色相は「赤」として認識される色を生成するはずです）。結果は以下のスクリーンショットに示されています：

<CaptionImage
  src="/_images/tutorial_colours_screenshot3.png"
  caption="彩度0.5、明度0.3、0.5、0.7の赤"
/>

[Colour](https://docs.juce.com/master/classColour.html "Represents a colour, also including a transparency value.")オブジェクトから色相、彩度、明度の値を取得することもできます。例えば、異なる明度の紫のシリーズが必要な場合は、以下のコードを使用できます：

```cpp
auto purpleHue = juce::Colours::purple.getHue();

juce::Array<juce::Colour> colours { juce::Colour::fromHSV (purpleHue, 0.5f, 0.3f, 1.0f),
    juce::Colour::fromHSV (purpleHue, 0.5f, 0.5f, 1.0f),
    juce::Colour::fromHSV (purpleHue, 0.5f, 0.7f, 1.0f) };
```

この結果は以下のスクリーンショットに示されています：

<CaptionImage
  src="/_images/tutorial_colours_screenshot4.png"
  caption="彩度0.5、明度0.3、0.5、0.7の紫"
/>

### 色値の操作

既存の色を使用して新しい色を作成することもできます。例えば、既存の色よりも若干明るいまたは暗い色を作成するには、それぞれ[Colour::brighter()](https://docs.juce.com/master/classColour.html#a614c7699a1b47dcf324106d548238bac "Returns a brighter version of this colour.")または[Colour::darker()](https://docs.juce.com/master/classColour.html#a9910d9b8385825a87ea0d62d96115872 "Returns a darker version of this colour.")関数を使用できます：

```cpp
auto baseColour = juce::Colours::orange;

juce::Array<juce::Colour> colours { baseColour.darker(),
    baseColour,
    baseColour.brighter() };
```

または、[Colour::interpolatedWith()](https://docs.juce.com/master/classColour.html#ac1500fb05c7775db2e1b21f07cc28c0c "Returns a colour that lies somewhere between this one and another.")関数を使用して 2 つの色をブレンドできます：

```cpp
auto colour1 = juce::Colours::red;
auto colour2 = juce::Colours::purple;

juce::Array<juce::Colour> colours { colour1,
    colour1.interpolatedWith (colour2, 0.5f),
    colour2 };
```

この結果は以下のスクリーンショットに示されています：

<CaptionImage
  src="/_images/tutorial_colours_screenshot5.png"
  caption="赤と紫、その間に赤と紫の等しいブレンド"
/>

ある色に対して、別の色に対して明確に見える色を作成するには、[Colour::contrasting()](https://docs.juce.com/master/classColour.html#a50e8a45cda60f6853cb74ed1ff1fb7d7 "Returns a colour that will be clearly visible against this colour.")関数を使用できます。これにより、引数を使用してコントラストの量を指定できます：

```cpp
auto baseColour = juce::Colours::darkcyan;

juce::Array<juce::Colour> colours { baseColour,
    baseColour.contrasting (0.5f) };
```

2 つの他の色に対してコントラストのある色を作成することもできます：

```cpp
auto colour1 = juce::Colours::lightblue;
auto colour2 = juce::Colours::darkred;

juce::Array<juce::Colour> colours { colour1,
    juce::Colour::contrasting (colour1, colour2),
    colour2 };
```

[Colour::overlaidWith()](https://docs.juce.com/master/classColour.html#a3c6c94ff6f05b403b783acaf7c68b439 "Returns a colour that is the result of alpha-compositing a new colour over this one.")関数を使用して、重ねられた色のアルファチャネルを考慮して 2 つの色をブレンドするなど、他にもさまざまな操作を実行できます。

## コンポーネントの色の指定

前のセクションでは、コンポーネントの`paint()`関数で独自の描画操作を実行するときの色の使用を探りました。組み込みコンポーネント（スライダー、ラベルなど）の色をカスタマイズするには、Component::setColour()または[LookAndFeel::setColour()](https://docs.juce.com/master/classLookAndFeel.html#a167a1e914771f32e433a0d45aaba45e3 "Registers a colour to be used for a particular purpose.")関数を使用する必要があります。

基本的に、各組み込み[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")サブクラスには、特定の色を持つことができるコンポーネントのさまざまな要素をリストする`enum`が含まれています。これらの各項目は*カラー ID*と呼ばれます。（これらのカラー ID の値は JUCE ライブラリ全体で一意です。）例えば、[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")クラスのカラー ID は以下のとおりです（[Label::ColourIds](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701 "A set of colour IDs to use to change the colour of various aspects of the label.")から）：

- [Label::backgroundColourId](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701a80bf4bb58a466a4debb994f3ee2c8cab "The background colour to fill the label with.")：ラベルを塗りつぶす背景色。
- [Label::textColourId](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701a1f25238374bf53d43f8c73e68c8e937c "The colour for the text.")：テキストの色。
- [Label::outlineColourId](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701ab67bf6af853bcef12b41b3e81f7d18bb "An optional colour to use to draw a border around the label.")：ラベルの周りにボーダーを描画するためのオプションの色。アウトラインを持たない場合は透明のままにします。
- [Label::backgroundWhenEditingColourId](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701a6ccfd805ecc818013ea4bdde69d4258b "The background colour when the label is being edited.")：ラベルが編集されているときの背景色。
- [Label::textWhenEditingColourId](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701adb6284340066b8c4d9ea389087c7d69d "The colour for the text when the label is being edited.")：ラベルが編集されているときのテキストの色。
- [Label::outlineWhenEditingColourId](https://docs.juce.com/master/classLabel.html#a41756012394513222e1323bb432fa701a6c7adfce6c830c9faa94efd3445f78cf "An optional border colour when the label is being edited.")：ラベルが編集されているときのオプションのボーダー色。

これらの色のいくつかを変更してみましょう。`MainContentComponent`コンストラクタを見ると、[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")、[TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box.")、[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")、および 2 つの[Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.")オブジェクトが子コンポーネントとして追加されています。ラベルのテキスト色を黒に変更するために、以下のように行[1]を追加します：

```cpp
MainContentComponent()
{
    label.setColour (juce::Label::textColourId, Colours::black); // [1]
    label.setEditable (true);
    addAndMakeVisible (label);
    //...
```

結果は以下のスクリーンショットと同様になるはずです：

<CaptionImage
  src="/_images/tutorial_colours_screenshot6.png"
  caption="カスタマイズされたテキスト色のラベルを表示"
/>

:::note
[TextEditor](https://docs.juce.com/master/classTextEditor.html "An editable text box.")、[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")、[Slider](https://docs.juce.com/master/classSlider.html "A slider control for changing a value.")クラスのカラー ID（[TextEditor::ColourIds](https://docs.juce.com/master/classTextEditor.html#aa805220923c93cd808a92fff0e3fb71d "A set of colour IDs to use to change the colour of various aspects of the editor.")、[TextButton::ColourIds](https://docs.juce.com/master/classTextButton.html#afb6c1da587aebb63b58a2569bed70c2c "A set of colour IDs to use to change the colour of various aspects of the button.")、[Slider::ColourIds](https://docs.juce.com/master/classSlider.html#a1012002c53381ccc7c1fe7e604a75f44 "A set of colour IDs to use to change the colour of various aspects of the slider.")）を確認し、デモアプリケーションの子コンポーネントに異なる色を設定して実験してください。
:::

### ルック＆フィールの色の設定

アプリケーション、またはアプリケーションの一部で、同じタイプのすべてのコンポーネントに同じカラーパレットが必要なことは非常に一般的です。前のセクションの演習で、両方のスライダーに同じ外観を与えるために Component::setColour()関数の呼び出しを繰り返す必要があることに気づいたかもしれません。[LookAndFeel](https://docs.juce.com/master/classLookAndFeel.html "LookAndFeel objects define the appearance of all the JUCE widgets, and subclasses can be used to appl...")クラスの 1 つの使用法は、これらの色を指定する単一のポイントを提供することです。これを説明するために、`MainContentComponent`コンストラクタを以下のように元の状態に戻します：

```cpp
MainContentComponent()
{
    label.setEditable (true);
    addAndMakeVisible (label);

    textEditor.setText ("This is a text editor.");
    addAndMakeVisible (textEditor);

    textButton.setClickingTogglesState (true);
    addAndMakeVisible (textButton);

    addAndMakeVisible (slider1);
    addAndMakeVisible (slider2);

    setSize (600, 210);
}
```

次に、両方のスライダーのサムの色を設定するために以下の行[2]を追加します：

```cpp
//...
getLookAndFeel().setColour (juce::Slider::thumbColourId, juce::Colours::red); // [2]
addAndMakeVisible (slider1);
addAndMakeVisible (slider2);
//...
```

これにより、以下のスクリーンショットと同様の結果が得られるはずです：

<CaptionImage
  src="/_images/tutorial_colours_screenshot7.png"
  caption="1行のコードで複数のスライダーサムの色をカスタマイズ"
/>

### カスタムルック＆フィールの色

[LookAndFeel](https://docs.juce.com/master/classLookAndFeel.html "LookAndFeel objects define the appearance of all the JUCE widgets, and subclasses can be used to appl...")クラス（[LookAndFeel_V1](https://docs.juce.com/master/classLookAndFeel__V1.html "The original JUCE look-and-feel, as used back from 2002 to about 2007ish.")、[LookAndFeel_V2](https://docs.juce.com/master/classLookAndFeel__V2.html "This LookAndFeel subclass implements the juce style from around 2008-12.")、[LookAndFeel_V3](https://docs.juce.com/master/classLookAndFeel__V3.html "The latest JUCE look-and-feel style, as introduced in 2013.")、または[LookAndFeel_V4](https://docs.juce.com/master/classLookAndFeel__V4.html "The latest JUCE look-and-feel style, as introduced in 2017.")）のサブクラスを作成し、コンストラクタで特定の色をカスタマイズすることもできます。これを行うには、`MainContentComponent`クラスのネストされたクラスとして以下のクラスを追加できます：

```cpp
class CustomLookAndFeel : public juce::LookAndFeel_V4
{
public:
    CustomLookAndFeel()
    {
        setColour (juce::Slider::thumbColourId, juce::Colours::red);
    }
};
```

このクラスのインスタンスを private メンバーセクションに追加します[3]：

```cpp
private:
    CustomLookAndFeel lf; // [3]
    juce::Label label { {}, "This is some label text." };
```

そして MainContentComponent クラスにこのルック＆フィールを使用するようにコンストラクタで設定します[4]：

```cpp
MainContentComponent()
{
    setLookAndFeel (&lf); // [4]

    label.setEditable (true);
```

:::tip
このサブセクションの変更されたコードは、デモプロジェクトの`ColoursTutorial_02.h`ファイルにあります。
:::

<!-- -->

:::note
`CustomLookAndFeel`コンストラクタでより多くの色をカスタマイズしてください。
:::

## まとめ

このチュートリアルでは、独自のアプリケーションで使用できる以下の項目を見てきました：

- [Colour](https://docs.juce.com/master/classColour.html "Represents a colour, also including a transparency value.")クラスと[Colours](https://docs.juce.com/master/namespacejuce_1_1Colours.html "Contains a set of predefined named colours (mostly standard HTML colours)")名前空間を使用して JUCE で色を指定する方法。
- 描画操作を実行するときにコンポーネントの`paint()`関数で色を使用する。
- カラー ID を使用して組み込みコンポーネントの要素の色を指定する。
- [LookAndFeel](https://docs.juce.com/master/classLookAndFeel.html "LookAndFeel objects define the appearance of all the JUCE widgets, and subclasses can be used to appl...")クラスを使用してアプリケーションの一部またはアプリケーション全体で色を指定する。

## 関連項目

- [チュートリアル：Random クラス](../../utility-classes/tutorial_random/)
- [チュートリアル：アプリのルック＆フィールをカスタマイズ](../tutorial_look_and_feel_customisation/)
- [チュートリアル：親コンポーネントと子コンポーネント](../tutorial_component_parents_children/)
- [チュートリアル：Point、Line、Rectangle クラス](../tutorial_point_line_rectangle/)
- [チュートリアル：高度な GUI レイアウト技術](../tutorial_rectangle_advanced/)
