---
title: リスナーとブロードキャスター
sidebar_position: 7
tags: [初級]
---

# チュートリアル：リスナーとブロードキャスター

<SourcePageLink path="tutorial_listeners_and_broadcasters" />

このチュートリアルでは、JUCE の重要な概念であるリスナーとブロードキャスターシステムを紹介します。ボタンクリックに応答するシンプルなアクションの実装を通じて、これを見ていきます。

**レベル:** 初級<br/>
**プラットフォーム:** Windows, macOS, Linux, iOS, Android<br/>
**クラス:** [Button](https://docs.juce.com/master/classButton.html "A base class for buttons."), [TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it."), [Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked."), [Time](https://docs.juce.com/master/classTime.html "Holds an absolute date and time.")

## はじめに

このチュートリアルのデモプロジェクトをこちらからダウンロードしてください：[PIP](https://docs.juce.com/tutorials/PIPs/ListenersAndBroadcastersTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/ListenersAndBroadcastersTutorial.zip)。プロジェクトを解凍し、最初のヘッダファイルを Projucer で開いてください。

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucer を始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

このチュートリアルのデモプロジェクトは、1 つのボタンと 1 つのラベルを持つシンプルなユーザーインターフェースを表示します。インターフェースは以下のスクリーンショットのようになるはずです：

<CaptionImage
  src="/_images/tutorial_listeners_and_broadcasters_screenshot1.png"
  caption="基本的なボタンとラベルのインターフェース"
/>

提供された状態ではインターフェースは何もしません。ボタンをクリックするとラベルに現在の日時を表示するコードを追加します。

## インターフェースの設定

`MainContentComponent`クラスは 2 つの子コンポーネントで構成されています：[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")オブジェクトと[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")オブジェクトです。[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")オブジェクトは特定のテキストを含むボタンを表示でき、[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")オブジェクトはテキストを表示できます。

:::tip
[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")クラスはボタンの 1 つのタイプを実装しています。JUCE には多くのタイプの[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")クラスがあります。詳細については、[ToggleButton](https://docs.juce.com/master/classToggleButton.html "A button that can be toggled on/off.")、[ShapeButton](https://docs.juce.com/master/classShapeButton.html "A button that contains a filled shape.")、[ImageButton](https://docs.juce.com/master/classImageButton.html "As the title suggests, this is a button containing an image.")、[DrawableButton](https://docs.juce.com/master/classDrawableButton.html "A button that displays a Drawable.")、[ArrowButton](https://docs.juce.com/master/classArrowButton.html "A button with an arrow in it.")クラスの API リファレンスドキュメントを参照してください。
:::

`MainContentComponent`クラスの宣言は以下のとおりです：

```cpp
class MainContentComponent : public juce::Component
{
public:
    //==============================================================================
    MainContentComponent()
    {
        // ...
    }

    ~MainContentComponent()
    {
        // ...
    }

    void resized() override
    {
        // ...
    }

private:
    juce::TextButton checkTheTimeButton;
    juce::Label timeLabel;

    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainContentComponent)
};
```

ボタンとラベルは`MainContentComponent`オブジェクトに追加され、`MainContentComponent`コンストラクタで可視化されます：

```cpp
MainContentComponent()
{
    addAndMakeVisible (checkTheTimeButton);
    checkTheTimeButton.setButtonText ("Check the time...");

    addAndMakeVisible (timeLabel);
    timeLabel.setColour (juce::Label::backgroundColourId, juce::Colours::black);
    timeLabel.setColour (juce::Label::textColourId, juce::Colours::white);
    timeLabel.setJustificationType (juce::Justification::centred);

    setSize (600, 110);
}
```

ここでは、ボタンのテキストを設定し、ラベルの特定の外観を設定しています。これにより、ラベルは黒い背景に白いテキストを表示します。デフォルトでは、ラベルはテキストを表示しません。

### リスナー基底クラスの追加

JUCE では、ボタン、スライダー、および状態の変化を他のオブジェクトに通知する必要がある他の多くのタイプのコントロールは、*ブロードキャスター*オブジェクトの一種です。ブロードキャスターオブジェクトの変化に応答するには、他のクラスはその特定のタイプのブロードキャスターの*リスナー*である必要があります。リスナーはまた、そのタイプの少なくとも 1 つの特定のブロードキャスターオブジェクトに登録する必要があります。（JUCE のブロードキャスター-リスナーシステムは[オブザーバーパターン](https://en.wikipedia.org/wiki/Observer_pattern)に従います。）多くのブロードキャスターオブジェクトには、そのタイプのブロードキャスターのリスナーになるために継承できるネストされた`Listener`クラスが含まれています。例えば、[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")クラスには、この目的のためにネストされたクラス[Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.")が含まれています。

:::tip
[Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.")クラスは、ここに示されている[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")クラスのインスタンスを含む、異なるボタンタイプのいずれかをリッスンするために使用できます。
:::

[Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.")クラスを使用するには、基底クラスとして追加する必要があります。私たちの場合、[Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.")クラスを`MainContentComponent`クラスの基底クラスとして追加する必要があります[1]：

```cpp
class MainContentComponent : public juce::Component,
                             public juce::Button::Listener // [1]
{
public:
```

カスタムクラスは、同様に複数のリスナー基底クラスを追加することで、異なるタイプのブロードキャスターのリスナーになることができます。

### リスナーのコールバックの宣言

通常、各リスナークラスには少なくとも 1 つの[純粋仮想](http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/)関数があります。これは、ブロードキャスターオブジェクトが変更をブロードキャストする必要があるときにコールバックとして呼び出される関数です。コードをコンパイルし、使用するためにはこれをオーバーライドする必要があります。

:::tip
リスナークラスには、オーバーライドできる他の仮想関数が含まれていることが多いですが、これらは少数のケースで必要とされるため、オプションです。例として[Slider::Listener](https://docs.juce.com/master/classSlider.html#a1977aeac9b4363e8ed0cac0ac103055a)クラスのドキュメントを参照してください。
:::

[Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.")クラスの[純粋仮想](http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/)関数は[Button::Listener::buttonClicked()](https://docs.juce.com/master/classButton_1_1Listener.html#a81499cef24b7189cd0d1581fd9dc9e14 "Called when the button is clicked.")関数です。ここに示すように、`MainContentComponent`クラス内にその宣言[2]を追加する必要があります：

```cpp
MainContentComponent()
{
    // ...
}

~MainContentComponent()
{
    // ...
}

void resized() override
{
    // ...
}

void buttonClicked (juce::Button* button) override // [2]
{
}

// ...
```

### リスナーコールバックの実装

では、`MainContentComponent::buttonClicked()`関数を実装しましょう。ここでは、変更をブロードキャストしたオブジェクトへのポインタが渡されます。このポインタを他のオブジェクトと比較して、どのオブジェクトかを判断できます：

```cpp
void buttonClicked (juce::Button* button) override // [2]
{
    if (button == &checkTheTimeButton) // [3]
    {
        auto currentTime = juce::Time::getCurrentTime(); // [4]

        auto includeDate = true;
        auto includeTime = true;
        auto currentTimeString = currentTime.toString (includeDate, includeTime); // [5]

        timeLabel.setText (currentTimeString, juce::dontSendNotification); // [6]
    }
}
```

- [3]：ここでは、関数に渡されたポインタをボタンのアドレスと比較して、一致するかどうかを確認します。ここのように 1 つしかボタンがなくても、これを行うべきです。関数に渡された基底[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")クラスへのポインタを、ここに示されている[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")クラスなどの[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")サブクラスのインスタンスと比較するのは安全です。
- [4]：これは[Time](https://docs.juce.com/master/classTime.html "Holds an absolute date and time.")クラスを使用してオペレーティングシステムから現在の時刻を取得します。
- [5]：これは[Time](https://docs.juce.com/master/classTime.html "Holds an absolute date and time.")オブジェクトを読みやすい文字列に変換します。2 つの`bool`値により、出力のカスタマイズが可能です（詳細は[Time::toString()](https://docs.juce.com/master/classTime.html#a330e0926141abd7ef42957bce8a9e054 "Returns a string version of this date and time, using this machine's local timezone.")関数のドキュメントを参照）。
- [6]：ここではラベル内に表示されるテキストを更新します。

:::tip
`dontSendNotification`引数[7]は、ラベルがリスナーを持っている場合、この変更をリスナーにブロードキャストすることを防ぎます。（[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")オブジェクトはテキストの編集にも使用できるため、リスナーを持つことができます。）この場合、リスナーを持つことができないことはわかっています（自分のプライベートメンバーなので）が、明示的にすることは良い習慣です。
:::

### ブロードキャスターへのリスナーとしての登録

ブロードキャストされるメッセージを受信するには、1 つ以上のブロードキャスターオブジェクトにリスナーオブジェクトを登録する必要があります。この場合、[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")オブジェクトに登録する必要があります。通常、これはリスナーサブクラスのコンストラクタ内で行われます[7]：

```cpp
MainContentComponent()
{
    addAndMakeVisible (checkTheTimeButton);
    checkTheTimeButton.setButtonText ("Check the time...");
    checkTheTimeButton.addListener (this); // [7]
```

:::tip
ほとんどのブロードキャスターオブジェクトには、この目的のための`addListener()`関数があります（[ChangeBroadcaster](https://docs.juce.com/master/classChangeBroadcaster.html "Holds a list of ChangeListeners, and sends messages to them when instructed.")オブジェクトは例外で、代わりに[ChangeBroadcaster::addChangeListener()](https://docs.juce.com/master/classChangeBroadcaster.html#ad68416fe79a94cd5c99519bdea6c2a06 "Registers a listener to receive change callbacks from this broadcaster.")関数があります）。
:::

### ブロードキャスターへのリスナー登録解除

ブロードキャスターには`removeListener()`関数もあります。例えば、[Button::removeListener()](https://docs.juce.com/master/classButton.html#aa7016d2e4b8ab37a12c2736057eb28de "Removes a previously-registered button listener.")関数を参照してください。ボタンはリスニングを行っているクラスと同じクラスに所有されているため、ボタンはリスナーと同時に破棄されるため、リスナーを削除する必要は実際には*ありません*。完全性のために、デストラクタにこれを追加*できます*：

```cpp
~MainContentComponent()
{
    checkTheTimeButton.removeListener (this);
}
```

:::warning
より複雑なブロードキャスター-リスナーシステムを設定する場合、リスナーを適切に削除することは重要です。
:::

アプリケーションをビルドして実行してください。ボタンをクリックすると、ラベル内に時刻が表示されるはずです。

<CaptionImage
  src="/_images/tutorial_listeners_and_broadcasters_screenshot2.png"
  caption="ボタンを使用して現在の時刻を表示"
/>

:::tip
このセクションの完成したコードは、このチュートリアルのデモプロジェクトの`ListenersAndBroadcastersTutorial_02.h`ファイルにあります。
:::

<!-- -->

:::note
演習：表示されるテキストの形式を変更してみてください。[Time::toString()](https://docs.juce.com/master/classTime.html#a330e0926141abd7ef42957bce8a9e054 "Returns a string version of this date and time, using this machine's local timezone.")関数に渡す引数を変更することで行えます。また、絶対時間ではなく、ボタンクリック間のミリ秒数を表示するようにコードを変更することもできます。
:::

<!-- -->

:::tip
この演習のコードの例は、このチュートリアルのデモプロジェクトの`ListenersAndBroadcastersTutorial_03.h`ファイルにあります。
:::

### Button コールバックの簡素化

このチュートリアルで示されているリスナーとブロードキャスターのパラダイムを使用する代わりに、最新の C++標準のラムダ関数を使用してボタンコールバックを簡素化できます。これは、複雑な実装を必要としないシンプルなコールバックに特にうまく機能します。

まず、[Button::Listener](https://docs.juce.com/master/classButton_1_1Listener.html "Used to receive callbacks when a button is clicked.")クラスからの継承を削除し、MainContentComponent クラスの定義を以下のように復元します：

```cpp
class MainContentComponent : public juce::Component
{
public:
```

次に、MainContentComponent を[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")のリスナーとして追加する代わりに、[Button::onClick](https://docs.juce.com/master/classButton.html#a30b76ab312dc7f66e67596ae20540ec2 "You can assign a lambda to this callback object to have it called when the button is clicked.")ヘルパーオブジェクトにラムダ関数を割り当てます[8]：

```cpp
MainContentComponent()
{
    addAndMakeVisible (checkTheTimeButton);
    checkTheTimeButton.setButtonText ("Check the time...");
    checkTheTimeButton.onClick = [this] { checkTime(); }; // [8]
```

これは、ユーザーが[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")をクリックしたときに呼び出す関数を[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")オブジェクトに伝えます。

最後に、コールバック関数の名前を checkTime()[9]に変更し、どの[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")が関数を呼び出したかをチェックする必要がなくなったので、[Button](https://docs.juce.com/master/classButton.html "A base class for buttons.")オブジェクトへのポインタをチェックする if()文を削除します：

```cpp
void checkTime() // [9]
{
    auto currentTime = juce::Time::getCurrentTime();

    auto includeDate = true;
    auto includeTime = true;
    auto currentTimeString = currentTime.toString (includeDate, includeTime);

    timeLabel.setText (currentTimeString, juce::dontSendNotification);
}
```

:::tip
このコードの実装は、このチュートリアルのデモプロジェクトの`ListenersAndBroadcastersTutorial_04.h`ファイルにあります。
:::

## まとめ

このチュートリアルでは、JUCE のブロードキャスター-リスナーシステムの基本を紹介しました。このチュートリアルではボタンに焦点を当てましたが、同じ技術は JUCE コードの多くの領域に適用できます。特に、以下のことを学びました：

- カスタムクラスの 1 つをリスナータイプのオブジェクトにする方法。
- リスナーコールバック関数を追加する方法。
- ブロードキャスターオブジェクトへのリスナーとしての登録と登録解除の方法。
- [Time](https://docs.juce.com/master/classTime.html "Holds an absolute date and time.")クラスを使用して現在の時刻にアクセスする方法。
- ラムダ関数でコールバックを簡素化する方法。

## 関連項目

- [チュートリアル：Label クラス](../tutorial_label/)
- [チュートリアル：ComboBox クラス](../tutorial_combo_box/)
- [チュートリアル：ラジオボタンとチェックボックス](../tutorial_radio_buttons_checkboxes/)
- [チュートリアル：Slider クラス](../tutorial_slider_values/)
- [チュートリアル：オーディオプレーヤーの構築](../../audio/tutorial_playing_sound_files/)
