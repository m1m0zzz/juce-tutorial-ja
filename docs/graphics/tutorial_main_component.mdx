---
title: メインコンポーネント
sidebar_position: 2
tags: [初級]
---

# チュートリアル：メインコンポーネント

<SourcePageLink path="tutorial_main_component" />

このチュートリアルでは、メインコンテンツコンポーネントを作成してアプリケーションウィンドウにグラフィカルコンテンツを追加する方法を示します。これはウィンドウ内でユーザーにコンテンツを表示するために重要です。

**レベル:** 初級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [DocumentWindow](https://docs.juce.com/master/classDocumentWindow.html "A resizable window with a title bar and maximise, minimise and close buttons."), [Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects."), [Graphics](https://docs.juce.com/master/classGraphics.html "A graphics context, used for drawing a component or image.")

## はじめに

Projucer を起動し、**MainComponentTutorial**という名前で新しい GUI アプリケーションプロジェクトを作成します。**Files to Auto-Generate:**フィールドで**Create a Main.cpp file only**を選択してください。

この手順でサポートが必要な場合は、[チュートリアル：Projucer Part 1: Projucer を始めよう](../../getting-started/tutorial_new_projucer_project/)を参照してください。

以下のように`MainWindow`クラスを含めるように`MainComponentTutorialApplication`クラスを変更します：

```cpp
//==============================================================================
class MainComponentTutorialApplication : public juce::JUCEApplication
{
public:
    //...

    //==============================================================================
    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow (juce::String name) : DocumentWindow (name,
                                             juce::Colours::lightgrey,
                                             DocumentWindow::allButtons)
        {
            setUsingNativeTitleBar (true);
            centreWithSize (300, 200);
            setVisible (true);
        }

        void closeButtonPressed() override
        {
            JUCEApplication::getInstance()->systemRequestedQuit();
        }

    private:
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainWindow)
    };

private:
    std::unique_ptr<MainWindow> mainWindow;
};
```

`initialise()`関数に以下の行を追加します：

```cpp
void initialise (const juce::String& commandLine) override
{
    mainWindow.reset (new MainWindow (getApplicationName()));
}
```

最後に、`shutdown()`関数に以下の行を追加します：

```cpp
void shutdown() override
{
    mainWindow = nullptr;
}
```

## はじめに

前回のチュートリアル（[チュートリアル：アプリケーションウィンドウ](../tutorial_main_window/)）では、アプリケーションのグラフィカルインターフェースが存在するフレームとなるメインウィンドウについて説明しました。このチュートリアルでは、アプリのインターフェースの*コンテンツ*を表示するオブジェクトである*メインコンテンツコンポーネント*を作成します。メインコンテンツコンポーネントはすべての JUCE アプリにとって必須のオブジェクトです。

[Projucer](https://juce.com/projucer)で新しい GUI アプリケーションを作成すると、自動的にメインコンテンツコンポーネントが生成されます。しかし、この概念に慣れ、JUCE アプリがどのように構造化されているかを理解する良い方法は、そのようなメインコンテンツコンポーネントを自分で作成することです。これがこのチュートリアルで行うことです。

IDE でチュートリアルプロジェクトを開いてください。前回のチュートリアルで到達した同じ場所から始めます：空のアプリケーションウィンドウがある状態です。`Main.cpp`ファイルには`MainWindow`クラスがあります。前回のチュートリアル（[チュートリアル：アプリケーションウィンドウ](../tutorial_main_window/)）でその使い方をすでに学びました。今度は、このウィンドウにコンテンツを入れていきます！

しかし、その前に、まず*コンポーネント*の概念についてもう少し探ってみましょう。

## Component クラス

すべての JUCE グラフィカルインターフェースの最も重要な基本クラスは[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスです。JUCE では、ボタン、スライダー、テキストフィールドなど、GUI のほぼすべての可視要素がこのクラスから派生する*コンポーネント*です。JUCE でそのようなアプリを書く方法は、メインアプリケーションウィンドウが所有し、ウィンドウの*コンテンツ*である*メインコンポーネント*を作成することです。他のすべてのコンポーネントはこのメインコンポーネントの*子*になります（[チュートリアル：親コンポーネントと子コンポーネント](../../interface-design/tutorial_component_parents_children/)を参照）。`MainWindow`が派生している[DocumentWindow](https://docs.juce.com/master/classDocumentWindow.html "A resizable window with a title bar and maximise, minimise and close buttons.")クラスには、メインウィンドウがそのコンテンツ（メインコンポーネントとその子を含む）を正しく表示するために必要な機能が含まれています。

:::tip
覚えておいてください：JUCE のすべてのグラフィカル要素は[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスから派生しています。GUI を構築するために、異なるコンポーネントが*親*と*子*コンポーネントのネストされた階層に配置されます。最上位のコンポーネントは*メインコンテンツコンポーネント*と呼ばれます。詳細は[チュートリアル：親コンポーネントと子コンポーネント](../../interface-design/tutorial_component_parents_children/)を参照してください。
:::

## メインコンポーネントクラスの追加

### 新しいソースファイルの作成

では、メインコンポーネントクラスを作成しましょう。このためには、このクラスのソースコードが入る新しいファイルを作成する必要があります。[Projucer](https://juce.com/projucer)に戻り、そこでチュートリアルプロジェクトを開きます。左側で**Files**ブラウザが開いていることを確認します。次に、**Source**グループ（新しい C++ソースファイルは常にここに入れるべきファイルグループ）を右クリックし、**Add new Component class (split between CPP & header)..**を選択します。[Projucer](https://juce.com/projucer)は新しい[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")サブクラスの名前を尋ねます。ダイアログで**MainComponent**と入力し、**Create Files**をクリックします。[Projucer](https://juce.com/projucer)が 2 つの新しいファイル`MainComponent.cpp`と`MainComponent.h`を作成したことがわかります。プロジェクトを保存し、[IDE](https://en.wikipedia.org/wiki/Integrated_development_environment)で再度開きます。そこにも新しいファイルが表示されるはずです。[Projucer](https://juce.com/projucer)は新しいコンポーネントクラス用のコードを自動的に作成しており、次のセクションで検討します。

<CaptionImage
  src="/_images/tutorial_main_component_screenshot1.png"
  caption="Projucerで新しいコンポーネントクラスを追加"
/>

:::tip
覚えておいてください：新しいクラスを作成する場合、それらは独自のファイルに入れ、ファイル名はクラス名と一致させるべきです。常に[Projucer](https://juce.com/projucer)を使用して新しいファイルを作成してください。[IDE](https://en.wikipedia.org/wiki/Integrated_development_environment)からは絶対に作成しないでください（[Projucer](https://juce.com/projucer)は次にプロジェクトを保存するときにそのような変更を上書きします）。
:::

### 新しいコンポーネントクラス

ご覧のように、[Projucer](https://juce.com/projucer)は自動的に新しいクラスを[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")クラスから派生させ、以下のクラス宣言を追加しました：

```cpp
class MainComponent : public juce::Component
{
public:
    MainComponent();
    ~MainComponent();

    void paint (juce::Graphics&) override;
    void resized() override;

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent)
};
```

[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")基本クラスには、そこから派生するすべてのクラスでオーバーライドすべき 2 つの重要な仮想メンバー関数があります。[Projucer](https://juce.com/projucer)はすでにこれら 2 つのオーバーライドを作成しています：

- Component::paint()：このメンバー関数はコンポーネントが画面上にどのように描画されるべきかを決定し、すべてのコンポーネントクラスで実装する必要があります。
- Component::resized()：このメンバー関数はコンポーネントがリサイズされたときに何が起こるべきかを決定し、すべてのコンポーネントクラスで実装する必要があります（アプリでこのコンポーネントが決してリサイズ可能にならないことが確実な場合を除く）。

:::tip
基本クラスの関数をオーバーライドするすべてのクラスの関数には、常に`override`キーワードを追加してください。これにより、アプリでの予期しないエラーを防ぎ、[JUCE コーディング標準](http://www.juce.com/learn/coding-standards)の一部です。
:::

### paint 関数の実装

`paint()`関数は[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")オブジェクトが画面上にどのようにレンダリングされるかを決定します。ここで`MainComponent`クラスにカスタムの外観を追加します。

[Projucer](https://juce.com/projucer)は自動的にいくつかのデモコードを追加しました。`paint()`関数に独自のコードを入れましょう。

```cpp
void MainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::lightblue);

    g.setColour (juce::Colours::darkblue);
    g.setFont (20.0f);
    g.drawText ("Hello, World!", getLocalBounds(), juce::Justification::centred, true);
}
```

このコードの詳細にはあまり立ち入る必要はありません。ここで使用されている関数（およびそれ以上）については、次のチュートリアル[チュートリアル：Graphics クラス](../tutorial_graphics_class/)で詳しく学びます。今のところ、このデモコードがコンポーネントを水色の背景で塗りつぶし、次にコンポーネントの中央に青いフォントで**Hello, World!**というテキストをレンダリングすることはおそらく推測できるでしょう。ポイントは、`MainComponent`オブジェクトがどのように見えるべきかを決定するすべてのコードは、まさにここの`paint()`関数内に入るということです。

### メインコンポーネントを表示する

では、コードをコンパイルして実行してください。青い背景とテキストの代わりに、まだ空のアプリケーションウィンドウしか表示されていないことがわかります。なぜでしょうか？

実は、`MainWindow`オブジェクトにコンテンツを表示すべきだと伝えていなかったのです。まず、`MainWindow`クラスが`MainComponent`クラスについて知ることができるようにヘッダをインクルードする必要があります。`Main.cpp`ファイルの先頭、すでに存在するインクルードの下に以下のインクルードを追加します：

```cpp
#include "MainComponent.h"
```

次のステップは`MainComponent`オブジェクトを作成し、メインウィンドウの*コンテンツ*として追加することです。[DocumentWindow::setContentOwned()](https://docs.juce.com/master/classResizableWindow.html#a97940f07b6014bac018cbe9330abc769 "Changes the current content component.")関数を呼び出すことでこれを行えます。

:::tip
「Owned」とは、`MainWindow`オブジェクトが`MainComponent`オブジェクトのライフタイムを担当し、自身のデストラクタが呼ばれたときに自動的に破棄することを意味します。
:::

`MainWindow`クラスのコンストラクタに以下の行を追加します：

```cpp
setContentOwned (new MainComponent(), true);
```

`MainWindow`コンストラクタが以下のようになるようにします：

```cpp
MainWindow (juce::String name) : DocumentWindow (name,
                                     juce::Colours::lightgrey,
                                     DocumentWindow::allButtons)
{
    setUsingNativeTitleBar (true);
    setContentOwned (new MainComponent(), true);
    centreWithSize (getWidth(), getHeight());
    setVisible (true);
}
```

もう 1 つの詳細を変更したことに注意してください：Component::centreWithSize()関数への引数も変更されました。もう`MainWindow`オブジェクトのサイズを明示的に設定せず、そのコンテンツに基づいてサイズを判断するよう指示しています：

```cpp
centreWithSize (getWidth(), getHeight());
```

しかし、これが機能するためには、`centreWithSize()`関数呼び出しが発生する前に`MainComponent`オブジェクトのサイズが設定されている必要があります。これが行われていない場合、メインウィンドウは適切なウィンドウサイズがわかりません（実行するとアサーション失敗が発生します）。次のセクションでこれを達成する方法を説明します。

### コンポーネントのサイズの設定

原則として、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")オブジェクトのサイズを設定する方法は 2 つあります。コンポーネント自身のコンストラクタでサイズを設定するか、親コンポーネントのコンストラクタでサイズを設定するかです。メインコンポーネントの場合、通常はコンポーネント自身でサイズを設定します。`MainComponent`クラスのコンストラクタに以下の行を追加します：

```cpp
setSize (400, 300);
```

（もちろん、お好みで別のサイズを選択できます。）

:::warning
覚えておいてください：コンポーネントのサイズは常に設定してください。このステップを省略することは JUCE で非常によくあるバグの原因です。
:::

これが`MainWindow`クラスで Component::getWidth()と Component::getHeight()関数の呼び出しがウィンドウのサイズを把握し、メインコンポーネントが正しいサイズで表示される理由です。`MainComponent`オブジェクトのサイズは、`MainWindow`オブジェクトが配置されサイズ設定される前に、独自のコンストラクタで設定されます。

これで必要な部品がすべて揃いました。今アプリをコンパイルして実行すると、メインコンポーネントがアプリケーションウィンドウ内に正しく描画されているのが見えるはずです：

<CaptionImage
  src="/_images/tutorial_main_component_screenshot2.png"
  caption="新しいMainComponentオブジェクトが画面にレンダリングされる"
/>

:::note
演習：`setContentOwned()`関数の 2 番目の引数（ここでは`true`に設定）の意味と、変更した場合の動作を調べてください。ヒント：[ResizableWindow::setContentOwned()](https://docs.juce.com/master/classResizableWindow.html#a97940f07b6014bac018cbe9330abc769 "Changes the current content component.")関数のドキュメントを確認してください。
:::

## resize 関数の実装

`paint()`関数について説明したので、次に`MainComponent`クラスがリサイズに反応する方法を見てみましょう。

まず、メインウィンドウがリサイズ可能であるべきことを伝える必要があります。方法を忘れた場合は[チュートリアル：アプリケーションウィンドウ](../tutorial_main_window/)を参照してください。

では、アプリをコンパイルして実行し、マウスを使ってウィンドウをリサイズしてください。`MainComponent`オブジェクトがメインウィンドウのサイズに合わせて自身をリサイズすることがわかります --- これを行うために必要なすべてのコードは、[Component](https://docs.juce.com/master/classComponent.html "The base class for all JUCE user-interface objects.")基本クラスにすでに実装されています。

しかし、コンポーネントがリサイズされるたびにカスタム作業を行いたい場合はどうでしょうか？メインコンポーネントのサイズに応じて異なるレイアウトにする必要がある子コンポーネントがあるかもしれません。シンプルなデモアプリでは、メインコンポーネント内のテキストを変更して、コンポーネントの現在のサイズを表示するようにしましょう。

コンポーネントをリサイズするときに行う必要がある、または更新する必要があるものはすべて、コンポーネントの`resized()`関数に入ります。現在、この関数は空です。ここに機能を追加しましょう。

:::warning
Component::resized()関数は、コンポーネントのサイズ変更につながる何かが起こるたびに自動的に呼び出されます。この関数を自分で呼び出さないでください！
:::

コンポーネント内に表示されるテキストは現在、`paint()`関数内のリテラル文字列 --- 「Hello, World!」--- として与えられています。`MainComponent`クラスに新しいメンバー変数を導入してこれを変更しましょう。変数には常に説明的で意図を明らかにする名前を付けることが良い習慣です。これによりコードが読みやすく理解しやすくなり、追加のコードコメントの量が減ります。新しい変数にメインコンポーネントの現在のサイズを文字列として表現させたいので、`currentSizeAsString`と呼びましょう。

メンバー変数は常にクラスの private セクションで宣言します：

```cpp
class MainComponent : public juce::Component
{
    // ...

private:
    juce::String currentSizeAsString;
    // ...
};
```

では、`currentSizeAsString`オブジェクトの望ましい動作を実装しましょう。行うべきことは 2 つあります：

- `currentSizeAsString`オブジェクトの内容を画面にレンダリングする必要があります。
- `currentSizeAsString`オブジェクトはメインコンポーネントのサイズが変更されるたびに自身を更新する必要があります。

最初の部分を達成する方法はかなり簡単です：`paint()`関数内で`g.drawText()`関数が呼び出されるとき、そこのリテラル文字列を`currentSizeAsString`オブジェクトに置き換えるだけです：

```cpp
void MainComponent::paint (juce::Graphics& g)
{
    //...
    g.drawText (currentSizeAsString, getLocalBounds(), juce::Justification::centred, true);
}
```

2 番目の部分はより興味深いです。リサイズするたびに`resized()`関数が呼び出されることはすでに知っています。そこで`currentSizeAsString`オブジェクトの値を更新しましょう：

```cpp
void MainComponent::resized()
{
    currentSizeAsString = juce::String (getWidth()) + " x " + juce::String (getHeight());
}
```

Component::getWidth()と Component::getHeight()はコンポーネントの現在のサイズを照会できる便利な関数です。また、これらの整数を[String](https://docs.juce.com/master/classString.html "The JUCE String class!")オブジェクトに変換する必要があります。（[String](https://docs.juce.com/master/classString.html "The JUCE String class!")クラスの操作方法については、将来のチュートリアルで詳しく学べます。）

今アプリをコンパイルして実行すると、常に現在のサイズが表示されることがわかります：

<CaptionImage
  src="/_images/tutorial_main_component_screenshot3.png"
  caption="完成したデモアプリ"
/>

ここで 2 つの興味深い観察ができます。まず、表示は自動的に更新されます --- `paint()`関数は`resized()`関数が呼び出された後に自動的に呼び出されます。次に、ウィンドウを自分で最初にリサイズする前でも、アプリが起動したときにサイズはすでに正しく表示されています。`resized()`関数は、コンポーネントのサイズを変更する*何か*が起こるたびに常に呼び出されることを覚えておいてください。これには、アプリ起動後にコンポーネントのサイズが最初に設定されてコンポーネントが描画されるときも含まれます。

:::note
演習：`MainComponent::resize()`関数を変更して、リサイズするたびに`MainComponent`オブジェクトの背景色も変更されるようにしてください。
:::

チュートリアルプロジェクトの完成版はこちらからダウンロードできます：[PIP](https://docs.juce.com/tutorials/PIPs/MainComponentTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/MainComponentTutorial.zip)。自分のものと比較してみてください。

## まとめ

このチュートリアルでは、メインコンポーネントの概念、アプリへの追加方法、`paint()`と`resized()`関数の実装方法を説明しました。このチュートリアルを読んだ後、以下の重要なことに慣れているはずです：

- すべての JUCE アプリケーションウィンドウにはメインコンポーネントがあります。これはアプリの GUI を構成する他のすべてのコンポーネントの親です。
- メインコンポーネントを含むすべてのコンポーネントには、オーバーライドする必要がある 2 つの重要な関数があります：`paint()`と`resized()`。
- `paint()`関数には、コンポーネントを画面にレンダリングするコードを追加する必要があります。
- コンポーネントがサイズ変更に反応するための特別な動作が必要な場合は、`resized()`関数を実装する必要があります。
- `paint()`と`resized()`関数は、必要なときに自動的に呼び出される*コールバック*関数です。
- メインコンポーネントのサイズを設定し、メインウィンドウに追加して表示することを忘れないでください。

## 関連項目

- [チュートリアル：アプリケーションウィンドウ](../tutorial_main_window/)
- [チュートリアル：Graphics クラス](../tutorial_graphics_class/)
- [チュートリアル：親コンポーネントと子コンポーネント](../../interface-design/tutorial_component_parents_children/)
