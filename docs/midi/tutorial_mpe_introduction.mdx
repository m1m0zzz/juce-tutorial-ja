---
title: マルチポリフォニックシンセサイザーの構築
sidebar_position: 4
tags: [中級]
---

# チュートリアル: マルチポリフォニックシンセサイザーの構築

<SourcePageLink path="tutorial_mpe_introduction" />

MPE 規格の基本と、MPE に対応したシンセサイザーの実装方法を学びます。ROLI Seaboard Rise にアプリケーションを接続しましょう！

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [MPESynthesiser](https://docs.juce.com/master/classMPESynthesiser.html "Base class for an MPE-compatible musical device that can play sounds."), [MPEInstrument](https://docs.juce.com/master/classMPEInstrument.html "This class represents an instrument handling MPE."), [MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note."), [MPEValue](https://docs.juce.com/master/classMPEValue.html "This class represents a single value for any of the MPE dimensions of control."), [SmoothedValue](https://docs.juce.com/master/classSmoothedValue.html "A utility class for values that need smoothing to avoid audio glitches.")

## はじめに

このチュートリアルのデモプロジェクトをダウンロードしてください: [PIP](https://docs.juce.com/tutorials/PIPs/MPEIntroductionTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/MPEIntroductionTutorial.zip) 。プロジェクトを解凍し、最初のヘッダーファイルを Projucer で開きます。

この手順でヘルプが必要な場合は、[チュートリアル: Projucer Part 1: Projucer の使い方](../../getting-started/tutorial_new_projucer_project/)を参照してください。

:::tip
いくつかの箇所で参考にしているため、先に[チュートリアル: MIDI シンセサイザーの構築](../../synth/tutorial_synth_using_midi_input/)を読んでおくと役立ちます。
:::

## デモプロジェクト

デモプロジェクトは、`JUCE/examples` ディレクトリにある `MPEDemo` プロジェクトの簡略版です。このチュートリアルを最大限に活用するには、[MPE](https://support.roli.com/article/what-is-mpe/) 対応コントローラーが必要です。[MPE](https://support.roli.com/article/what-is-mpe/) は _MIDI Polyphonic Expression_ の略で、オーディオ製品間で多次元データを通信できるようにする新しい仕様です。

このような [MPE](https://support.roli.com/article/what-is-mpe/) 対応デバイスの例としては、ROLI の Seaboard シリーズ（[Seaboard RISE](https://roli.com/products/seaboard-rise) など）があります。

:::warning
コントローラーが [Seaboard RISE](https://roli.com/products/seaboard-rise) のように MIDI チャンネルプレッシャーとコンティニュアスコントローラー 74（_timbre_）を送信しない限り、シンセサイザーの音量が非常に小さく聞こえる場合があります。
:::

コンピューターに [Seaboard RISE](https://roli.com/products/seaboard-rise) を接続すると、デモアプリケーションのウィンドウは次のスクリーンショットのようになります:

<CaptionImage
  src="/_images/tutorial_mpe_introduction_screenshot1.png"
  caption="The demo application"
/>

MIDI 入力のいずれかを有効にする必要があります（ここでは [Seaboard RISE](https://roli.com/products/seaboard-rise) がオプションとして表示されています）。

### ビジュアライザー

[MPE](https://support.roli.com/article/what-is-mpe/) 対応デバイスで演奏されたノートは、ウィンドウの下部に表示されます。次のスクリーンショットに示されています:

<CaptionImage
  src="/_images/tutorial_mpe_introduction_screenshot2.png"
  caption="The visualiser"
/>

[MPE](https://support.roli.com/article/what-is-mpe/) の重要な特徴の 1 つは、特定のコントローラーキーボードからのすべてのノートが同じ MIDI チャンネルに割り当てられるのではなく、新しい MIDI ノートイベントごとに独自の MIDI チャンネルが割り当てられることです。これにより、コントロールチェンジメッセージ、ピッチベンドメッセージなどによって、各ノートを個別に制御できます。JUCE の [MPE](https://support.roli.com/article/what-is-mpe/) 実装では、演奏中のノートは [MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") オブジェクトで表されます。[MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") オブジェクトは、次のデータをカプセル化します:

- ノートの MIDI チャンネル。
- ノートの初期 MIDI ノート値。
- ノートオンベロシティ（または _strike_）。
- ノートのピッチベンド値: このノートの MIDI チャンネルで受信した MIDI ピッチベンドメッセージから導出されます。
- ノートのプレッシャー: このノートの MIDI チャンネルで受信した MIDI チャンネルプレッシャーメッセージから導出されます。
- ノートの _timbre_: 通常、このノートの MIDI チャンネルでコントローラー 74 のコントローラーメッセージから導出されます。
- ノートオフベロシティ（または _lift_）: これはノートオフイベントが受信された後、演奏音が停止するまでのみ有効です。

ノートが演奏されていない場合、ビジュアライザーは従来の MIDI キーボードレイアウトを表します。デモアプリケーションのビジュアライザーでは、各ノートは次のように表されます:

- グレーの塗りつぶされた円は、ノートオンベロシティを表します（ベロシティが高いほど円が大きくなります）。
- ノートの MIDI チャンネルは、この円内の「+」記号の上に表示されます;
- 初期 MIDI ノート名は「+」記号の下に表示されます。
- 重ねて表示される白い円は、このノートの現在のプレッシャーを表します（これも、プレッシャーが高いほど円が大きくなります）。
- ノートの水平位置は、元のノートとこのノートに適用されたピッチベンドから導出されます。
- ノートの垂直位置は、ノートの _timbre_ パラメーター（このノートの MIDI チャンネルの MIDI コントローラー 74 から）から導出されます。

### その他のセットアップ

このアプリケーションで実証されている [MPE](https://support.roli.com/article/what-is-mpe/) 仕様の他の側面をさらに掘り下げる前に、アプリケーションが使用している他のものを見てみましょう。

まず、`MainComponent` クラスは [AudioIODeviceCallback](https://docs.juce.com/master/classAudioIODeviceCallback.html "One of these is passed to an AudioIODevice object to stream the audio data in and out.") \[1\] と [MidiInputCallback](https://docs.juce.com/master/classMidiInputCallback.html "Receives incoming messages from a physical MIDI input device.") \[2\] クラスを継承しています:

```cpp
class MainComponent : public juce::Component,
                      private juce::AudioIODeviceCallback, // [1]
                      private juce::MidiInputCallback // [2]
{
public:
```

また、`MainComponent` クラスにはいくつかの重要なクラスメンバーがあります:

```cpp
juce::AudioDeviceManager audioDeviceManager; // [3]
juce::AudioDeviceSelectorComponent audioSetupComp; // [4]

Visualiser visualiserComp;
juce::Viewport visualiserViewport;

juce::MPEInstrument visualiserInstrument;
juce::MPESynthesiser synth;
juce::MidiMessageCollector midiCollector; // [5]

JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent)
};
```

[AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.") \[3\] クラスはコンピューター上のオーディオと MIDI の設定を処理し、[AudioDeviceSelectorComponent](https://docs.juce.com/master/classAudioDeviceSelectorComponent.html "A component containing controls to let the user change the audio settings of an AudioDeviceManager ob...") \[4\] クラスはグラフィカルユーザーインターフェースからこれを設定する手段を提供します（[チュートリアル: AudioDeviceManager クラス](../../audio/tutorial_audio_device_manager/)を参照）。[MidiMessageCollector](https://docs.juce.com/master/classMidiMessageCollector.html "Collects incoming realtime MIDI messages and turns them into blocks suitable for processing by a bloc...") \[5\] クラスを使用すると、オーディオコールバックでタイムスタンプ付き MIDI メッセージのブロックにメッセージを簡単に収集できます（[チュートリアル: MIDI シンセサイザーの構築](../../synth/tutorial_synth_using_midi_input/)を参照）。

[AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.") オブジェクトを最初にリストすることが重要です。これを [AudioDeviceSelectorComponent](https://docs.juce.com/master/classAudioDeviceSelectorComponent.html "A component containing controls to let the user change the audio settings of an AudioDeviceManager ob...") オブジェクトのコンストラクターに渡すためです:

```cpp
MainComponent()
    : audioSetupComp (audioDeviceManager, 0, 0, 0, 256,
          true, // showMidiInputOptions must be true
          true,
          true,
          false)
```

[AudioDeviceSelectorComponent](https://docs.juce.com/master/classAudioDeviceSelectorComponent.html "A component containing controls to let the user change the audio settings of an AudioDeviceManager ob...") コンストラクターに渡されるもう 1 つの重要な引数に注意してください: 利用可能な MIDI 入力を表示するには、`showMidiInputOptions` を `true` にする必要があります。

[チュートリアル: AudioDeviceManager クラス](../../audio/tutorial_audio_device_manager/)と同様の方法で [AudioDeviceManager](https://docs.juce.com/master/classAudioDeviceManager.html "Manages the state of some audio and midi i/o devices.") オブジェクトをセットアップしますが、MIDI 入力コールバック \[6\] も追加する必要があります:

```cpp
audioDeviceManager.initialise (0, 2, nullptr, true, {}, nullptr);
audioDeviceManager.addMidiInputDeviceCallback ({}, this); // [6]
audioDeviceManager.addAudioCallback (this);
```

#### MIDI 入力コールバック

`handleIncomingMidiMessage()` は、ユーザーインターフェースのアクティブな MIDI 入力のいずれかから各 MIDI メッセージが受信されたときに呼び出されます:

```cpp
void handleIncomingMidiMessage (juce::MidiInput* /*source*/,
    const juce::MidiMessage& message) override
{
    visualiserInstrument.processNextMidiEvent (message);
    midiCollector.addMessageToQueue (message);
}
```

ここでは、各 MIDI メッセージを以下の両方に渡します:

- `visualiserInstrument` メンバー --- ビジュアライザー表示を駆動するために使用されます; そして
- `midiCollector` メンバー --- オーディオコールバックでメッセージをシンセサイザーに渡します。

#### オーディオコールバック

オーディオコールバックが行われる前に、`audioDeviceAboutToStart()` 関数で `synth` と `midiCollector` メンバーにデバイスのサンプルレートを通知する必要があります:

```cpp
void audioDeviceAboutToStart (juce::AudioIODevice* device) override
{
    auto sampleRate = device->getCurrentSampleRate();
    midiCollector.reset (sampleRate);
    synth.setCurrentPlaybackSampleRate (sampleRate);
}
```

`audioDeviceIOCallbackWithContext()` 関数は、MPE 固有のことを何もしていないように見えます:

```cpp
void audioDeviceIOCallbackWithContext (const float* const* /*inputChannelData*/,
    int /*numInputChannels*/,
    float* const* outputChannelData,
    int numOutputChannels,
    int numSamples,
    const juce::AudioIODeviceCallbackContext& /*context*/) override
{
    // すべての出力チャンネルをクリア
    for (auto i = 0; i < numOutputChannels; ++i)
    {
        if (outputChannelData[i] != nullptr)
        {
            juce::FloatVectorOperations::clear (outputChannelData[i], numSamples);
        }
    }

    // MIDI メッセージをコレクターから取得
    juce::MidiBuffer incomingMidi;
    midiCollector.removeNextBlockOfMessages (incomingMidi, numSamples);

    // シンセサイザーにオーディオをレンダリングさせる
    synth.renderNextBlock (juce::AudioBuffer<float> (outputChannelData, numOutputChannels, numSamples),
                           incomingMidi, 0, numSamples);
}
```

オーディオコールバックの実装の詳細については、[チュートリアル: MIDI シンセサイザーの構築](../../synth/tutorial_synth_using_midi_input/)を参照してください。

## MPEInstrument クラス

前述のように、`visualiserInstrument` メンバーはビジュアライザーを駆動するために使用されます。このクラスは、再生中のノートの状態を維持するために [MPEInstrument](https://docs.juce.com/master/classMPEInstrument.html "This class represents an instrument handling MPE.") クラスを使用します。この状態は、[MPEInstrument::Listener](https://docs.juce.com/master/classMPEInstrument_1_1Listener.html "This listener will get called for any MPE-specific events that happen in the instrument.") インターフェースを実装することで、`Visualiser` クラスによって監視されます:

```cpp
class Visualiser : public juce::Component,
                   private juce::MPEInstrument::Listener
{
```

ここでは `Visualiser::noteAdded()`、`Visualiser::notePressureChanged()`、`Visualiser::notePitchbendChanged()`、`Visualiser::noteTimbreChanged()`、`Visualiser::noteKeyStateChanged()` 関数を実装する必要があります。[MPEInstrument::getMostRecentNote()](https://docs.juce.com/master/classMPEInstrument.html#a9f7fca25a84b8b65f1ae9dd7cc2ed46e) 関数と [MPEInstrument::getNote()](https://docs.juce.com/master/classMPEInstrument.html#a1869fa35d90eeb5a6ed91b5d3fdfd1e0) 関数を使用して、[MPEInstrument](https://docs.juce.com/master/classMPEInstrument.html "This class represents an instrument handling MPE.") オブジェクトから [MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") オブジェクトの参照を取得します。

:::note
演習: ビジュアライザーを更新して、ノートオフベロシティ（_lift_）が異なる色で表示されるようにします。速いリフトは明るい色で、遅いリフトは暗い色で表示する必要があります。
:::

## MPESynthesiser クラス

このアプリケーションで最も重要なことは、オーディオコールバックで `synth` メンバーを使用して実際のオーディオを生成することです。[MPESynthesiser](https://docs.juce.com/master/classMPESynthesiser.html "Base class for an MPE-compatible musical device that can play sounds.") クラスは [Synthesiser](https://docs.juce.com/master/classSynthesiser.html "Base class for a musical device that can play sounds.") クラスに似ています（[チュートリアル: MIDI シンセサイザーの構築](../../synth/tutorial_synth_using_midi_input/)を参照）が、[MPE](https://support.roli.com/article/what-is-mpe/) に対応するように調整されています。これを使用するには、[MPESynthesiserVoice](https://docs.juce.com/master/classMPESynthesiserVoice.html "Represents an MPE voice that an MPESynthesiser can use to play a sound.") クラスを継承するクラスを作成する必要があります。

このアプリケーションには `MPEDemoSynthVoice` クラスがあります:

```cpp
class MPEDemoSynthVoice : public juce::MPESynthesiserVoice
{
public:
```

`MainComponent` コンストラクターでは、いくつかの `MPEDemoSynthVoice` オブジェクトをシンセサイザーに追加して、ボイスがポリフォニーを実装できるようにする必要があります:

```cpp
for (auto i = 0; i < 15; ++i)
    synth.addVoice (new MPEDemoSynthVoice());

synth.setVoiceStealingEnabled (false);
```

:::tip
この数は通常、[MPE](https://support.roli.com/article/what-is-mpe/) デバイスがサポートする同時ノートの数を反映する必要があります。[Seaboard RISE](https://roli.com/products/seaboard-rise) の場合、これは 15 です。
:::

## MPESynthesiserVoice クラス

`MPEDemoSynthVoice` クラスは、いくつかのメンバー変数を宣言します。これらのほとんどは、[SmoothedValue](https://docs.juce.com/master/classSmoothedValue.html "A utility class for values that need smoothing to avoid audio glitches.") テンプレートクラスでラップされています（[チュートリアル: カスケードゲインクラスの構築](../../synth/tutorial_synth_level_control/)を参照）:

```cpp
private:
//==============================================================================
juce::SmoothedValue<double> level, timbre, frequency;

double phase = 0.0;
double phaseDelta = 0.0;
double tailOff = 0.0;

// 一部のパラメーター
static constexpr auto maxLevel = 0.05;
static constexpr auto maxLevelDb = 31.0;
static constexpr auto smoothingLengthInSeconds = 0.01;
```

`MPEDemoSynthVoice::prepare()` 関数は、現在のサンプルレートで [SmoothedValue](https://docs.juce.com/master/classSmoothedValue.html "A utility class for values that need smoothing to avoid audio glitches.") オブジェクトを初期化します:

```cpp
void prepare (const juce::dsp::ProcessSpec& spec)
{
    level     .reset (spec.sampleRate, smoothingLengthInSeconds);
    timbre    .reset (spec.sampleRate, smoothingLengthInSeconds);
    frequency .reset (spec.sampleRate, smoothingLengthInSeconds);
}
```

### ノートの開始

`MPEDemoSynthVoice::noteStarted()` 関数は、このボイスがノートを開始するときに呼び出されます:

```cpp
void noteStarted() override
{
    jassert (currentlyPlayingNote.isValid());
    jassert (currentlyPlayingNote.keyState == juce::MPENote::keyDown
             || currentlyPlayingNote.keyState == juce::MPENote::keyDownAndSustained);

    // MPENote の情報は currentlyPlayingNote メンバーで公開され、いつでもアクセスできます。
    // カスタムボイスでこれを使用できます。
    level     .setTargetValue (currentlyPlayingNote.pressure.asUnsignedFloat());
    frequency .setTargetValue (currentlyPlayingNote.getFrequencyInHertz());
    timbre    .setTargetValue (currentlyPlayingNote.timbre.asUnsignedFloat());

    phase = 0.0;
    auto cyclesPerSample = frequency.getNextValue() / currentSampleRate;
    phaseDelta = 2.0 * juce::MathConstants<double>::pi * cyclesPerSample;

    tailOff = 0.0;
}
```

ここでは、[MPESynthesiserVoice::currentlyPlayingNote](https://docs.juce.com/master/classMPESynthesiserVoice.html#aea34fcbdb3fa0961f73d5f9a1f34e255) メンバーにアクセスして、新しいノートの [MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") 情報を取得できます。すでに述べたように、[MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") クラスには [MPENote::pressure](https://docs.juce.com/master/structjuce_1_1MPENote.html#aaa3f79337f278df7cf5d1a213b98a1e4)、[MPENote::pitchbend](https://docs.juce.com/master/structjuce_1_1MPENote.html#ae95c9513c78b3e1fc5caf0f7f3e8c62a)、[MPENote::timbre](https://docs.juce.com/master/structjuce_1_1MPENote.html#a60f9d98a58a8e2cba8e6fe354a0a16d7) などのメンバーがあります。

[MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") クラスには、現在のノートの周波数を計算する便利な関数 [MPENote::getFrequencyInHertz()](https://docs.juce.com/master/structjuce_1_1MPENote.html#ad2e9c044e6b27b86d5ff3e842a7e1ffd) もあります。これには、ノートのピッチベンド値を考慮したものです。

### ノートの停止

`MPEDemoSynthVoice::noteStopped()` 関数は、ノートが停止するときに呼び出されます:

```cpp
void noteStopped (bool allowTailOff) override
{
    jassert (currentlyPlayingNote.keyState == juce::MPENote::off);

    if (allowTailOff)
    {
        // このフラグを設定してテールオフを開始します。レンダリングコールバックがこれを検出し、
        // フェードアウトを行い、完了したら clearCurrentNote() を呼び出します。

        if (tailOff == 0.0) // stopNote メソッドは複数回呼び出される可能性があるため、
            // まだテールオフを開始していない場合にのみ開始する必要があります。
            tailOff = 1.0;
    }
    else
    {
        // すぐに演奏を停止するように指示されているので、すべてをリセットします..
        clearCurrentNote();
        phaseDelta = 0.0;
    }
}
```

:::tip
これは、[チュートリアル: MIDI シンセサイザーの構築](../../synth/tutorial_synth_using_midi_input/)の `SineWaveVoice::stopNote()` 関数に非常に似ています。ここには MPE 固有のものはありません。
:::

<!-- -->

:::note
演習: ノートオフベロシティ（_lift_）がノートのリリースレートを変更できるように、`MainComponent::noteStopped()` 関数を変更します。速いリフトは、より短いリリースタイムになるはずです。
:::

### パラメーターの変更

このノートのプレッシャー、ピッチベンド、またはティンバーが変更されたときに通知するコールバックがあります:

```cpp
void notePressureChanged() override
{
    level.setTargetValue (currentlyPlayingNote.pressure.asUnsignedFloat());
}

void notePitchbendChanged() override
{
    frequency.setTargetValue (currentlyPlayingNote.getFrequencyInHertz());
}

void noteTimbreChanged() override
{
    timbre.setTargetValue (currentlyPlayingNote.timbre.asUnsignedFloat());
}
```

繰り返しになりますが、[MPESynthesiserVoice::currentlyPlayingNote](https://docs.juce.com/master/classMPESynthesiserVoice.html#aea34fcbdb3fa0961f73d5f9a1f34e255) メンバーにアクセスして、これらの各パラメーターの現在の値を取得します。

### オーディオの生成

`MainComponent::renderNextBlock()` は、実際にオーディオ信号を生成し、このボイスの信号を渡されたバッファーにミックスします:

```cpp
void renderNextBlock (juce::AudioBuffer<float>& outputBuffer,
    int startSample,
    int numSamples) override
{
    if (phaseDelta != 0.0)
    {
        if (tailOff > 0.0)
        {
            while (--numSamples >= 0)
            {
                auto currentSample = getNextSample() * (float) tailOff;

                for (auto i = outputBuffer.getNumChannels(); --i >= 0;)
                    outputBuffer.addSample (i, startSample, currentSample);

                ++startSample;

                tailOff *= 0.99;

                if (tailOff <= 0.005)
                {
                    clearCurrentNote();

                    phaseDelta = 0.0;
                    break;
                }
            }
        }
        else
        {
            while (--numSamples >= 0)
            {
                auto currentSample = getNextSample();

                for (auto i = outputBuffer.getNumChannels(); --i >= 0;)
                    outputBuffer.addSample (i, startSample, currentSample);

                ++startSample;
            }
        }
    }
}
```

`MainComponent::getNextSample()` を呼び出して波形を生成します:

```cpp
float getNextSample() noexcept
{
    auto levelDb = (level.getNextValue() - 1.0) * maxLevelDb;
    auto amplitude = std::pow (10.0f, 0.05f * levelDb) * maxLevel;

    // timbre は、サイン波とスクエア波の間のブレンドに使用されます。
    auto f1 = std::sin (phase);
    auto f2 = std::copysign (1.0, f1);
    auto a2 = timbre.getNextValue();
    auto a1 = 1.0 - a2;

    auto nextSample = float (amplitude * ((a1 * f1) + (a2 * f2)));

    auto cyclesPerSample = frequency.getNextValue() / currentSampleRate;
    phaseDelta = 2.0 * juce::MathConstants<double>::pi * cyclesPerSample;
    phase = std::fmod (phase + phaseDelta, 2.0 * juce::MathConstants<double>::pi);

    return nextSample;
}
```

endcode

これは、_timbre_ パラメーターの値に基づいて、サイン波と（バンドリミットされていない）スクエア波の間で単純にクロスフェードします。

:::note
演習: _timbre_ パラメーターに応じて、1 オクターブ離れた 2 つのサイン波の間でクロスフェードするように `MPEDemoSynthVoice` クラスを変更します。
:::

## まとめ

このチュートリアルでは、JUCE の [MPE](https://support.roli.com/article/what-is-mpe/) ベースのクラスのいくつかを紹介しました。次のことがわかったはずです:

- [MPE](https://support.roli.com/article/what-is-mpe/) とは何か。
- [MPE](https://support.roli.com/article/what-is-mpe/) 対応デバイスは、各ノートを独自の MIDI チャンネルに割り当てること。
- [MPENote](https://docs.juce.com/master/structjuce_1_1MPENote.html "This struct represents a playing MPE note.") クラスが、MIDI チャンネル、元のノート番号、ベロシティ、ピッチベンドなどのノートに関する情報を保存する方法。
- [MPEInstrument](https://docs.juce.com/master/classMPEInstrument.html "This class represents an instrument handling MPE.") クラスが現在再生中のノートの状態を維持すること。
- [MPESynthesiser](https://docs.juce.com/master/classMPESynthesiser.html "Base class for an MPE-compatible musical device that can play sounds.") クラスには、シンセサイザーを駆動するために使用する [MPEInstrument](https://docs.juce.com/master/classMPEInstrument.html "This class represents an instrument handling MPE.") オブジェクトが含まれていること。
- シンセサイザーのオーディオコードを実装するには、[MPESynthesiserVoice](https://docs.juce.com/master/classMPESynthesiserVoice.html "Represents an MPE voice that an MPESynthesiser can use to play a sound.") クラスを継承するクラスを実装する必要があること。

## 関連項目

- [チュートリアル: MPE ゾーンを理解する](../tutorial_mpe_zones/)
- [チュートリアル: MIDI イベントの処理](../tutorial_handling_midi_events/)
- [チュートリアル: MIDI データの作成](../tutorial_midi_message/)
- [チュートリアル: MIDI シンセサイザーの構築](../../synth/tutorial_synth_using_midi_input/)
