---
title: AudioSampleBufferクラスを使ったオーディオのループ再生(上級編)
sidebar_position: 4
tags: [上級]
---

# チュートリアル: AudioSampleBufferクラスを使ったオーディオのループ再生(上級編)

<SourcePageLink path="tutorial_looping_audio_sample_buffer_advanced" />

このチュートリアルでは、スレッドセーフな技術を使用して、[AudioSampleBuffer](group__juce__audio__basics-buffers.html#gab339ebab0d3b10c91c0d47c8fd2e50d2)オブジェクトに格納された音声を再生およびループする方法を説明します。また、バックグラウンドスレッドで音声データを読み込む技術も紹介します。

**レベル:** 上級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting."), [ReferenceCountedArray](https://docs.juce.com/master/classReferenceCountedArray.html "Holds a list of objects derived from ReferenceCountedObject, or which implement basic reference-count..."), [Thread](https://docs.juce.com/master/classThread.html "Encapsulates a thread."), [AudioBuffer](https://docs.juce.com/master/classAudioBuffer.html "A multi-channel buffer containing floating point audio samples.")

## はじめに

このチュートリアルは、[Tutorial: Looping audio using the AudioSampleBuffer class](../tutorial_looping_audio_sample_buffer/)から続きます。まだ読んでいない場合は、先にそのチュートリアルをお読みください。

このチュートリアルのデモプロジェクトをダウンロードしてください: [PIP](https://docs.juce.com/tutorials/PIPs/LoopingAudioSampleBufferAdvancedTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/LoopingAudioSampleBufferAdvancedTutorial.zip)。プロジェクトを解凍し、Projucerで最初のヘッダーファイルを開いてください。

この手順でヘルプが必要な場合は、[Tutorial: Projucer Part 1: Getting started with the Projucer](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

このデモプロジェクトは、[Tutorial: Looping audio using the AudioSampleBuffer class](../tutorial_looping_audio_sample_buffer/)のデモプロジェクトと同様の動作を実装しています。ユーザーは音声ファイルを開くことができ、そのファイルはバッファに読み込まれてループ再生されます。このチュートリアルの大きな違いの1つは、ファイルを参照するたびにオーディオシステムをシャットダウンするのではなく、オーディオシステムを実行し続けることです。これは、スレッド間でスレッドセーフな方法で通信するための便利なクラスを使用することで実現されています。

## スレッドセーフな技術

[Tutorial: Looping audio using the AudioSampleBuffer class](../tutorial_looping_audio_sample_buffer/)で、オーディオスレッドとメッセージスレッドが不完全または破損したデータにアクセスする可能性がある問題をどのように解決したかを思い出してください。ファイルを参照する直前にオーディオシステムをシャットダウンしました。その後、ファイルが選択されると、ファイルを開いてオーディオシステムを再起動しました。これは明らかに実際のアプリケーションでは非実用的で面倒な方法です!

### 参照カウントオブジェクト

[ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting.")クラスは、スレッド間でメッセージやデータを渡すための便利なツールです。ここでは、[AudioSampleBuffer](group__juce__audio__basics-buffers.html#gab339ebab0d3b10c91c0d47c8fd2e50d2)オブジェクトと再生位置を[ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting.")クラスに格納します。デバッグを支援し、クラスの動作を説明するために、`name`メンバーも含めています(ただし、これはクラスが機能するために厳密には必要ありません):

```cpp
class ReferenceCountedBuffer : public juce::ReferenceCountedObject
{
public:
    typedef juce::ReferenceCountedObjectPtr<ReferenceCountedBuffer> Ptr;

    ReferenceCountedBuffer (const juce::String& nameToUse,
        int numChannels,
        int numSamples)
        : name (nameToUse),
          buffer (numChannels, numSamples)
    {
        DBG (juce::String ("Buffer named '") + name + "' constructed. numChannels = " + juce::String (numChannels) + ", numSamples = " + juce::String (numSamples));
    }

    ~ReferenceCountedBuffer()
    {
        DBG (juce::String ("Buffer named '") + name + "' destroyed");
    }

    juce::AudioSampleBuffer* getAudioSampleBuffer()
    {
        return &buffer;
    }

    int position = 0;

private:
    juce::String name;
    juce::AudioSampleBuffer buffer;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ReferenceCountedBuffer)
};
```

クラスの先頭にある`typedef`は、[ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting.")サブクラスを実装する上で重要な部分です。`ReferenceCountedBuffer`オブジェクトを生のポインタに格納するのではなく、`ReferenceCountedBuffer::Ptr`型に格納します。これがオブジェクトの参照カウント(必要に応じてインクリメントおよびデクリメント)とその寿命(参照カウントがゼロに達したときにオブジェクトを削除する)を管理します。[ReferenceCountedArray](https://docs.juce.com/master/classReferenceCountedArray.html "Holds a list of objects derived from ReferenceCountedObject, or which implement basic reference-count...")クラスを使用して、`ReferenceCountedBuffer`オブジェクトの配列を格納することもできます。

`MainContentComponent`クラスでは、配列と単一のインスタンスの両方を格納します:

```cpp
juce::SpinLock mutex;
juce::ReferenceCountedArray<ReferenceCountedBuffer> buffers;
ReferenceCountedBuffer::Ptr currentBuffer;
```

`buffers`メンバーは、オーディオスレッドがもう必要としないことが確実になるまで、配列内のバッファを保持します。`currentBuffer`メンバーは、現在選択されているバッファを保持します。

### バックグラウンドスレッドの実装

`MainContentComponent`クラスは[Thread](https://docs.juce.com/master/classThread.html "Encapsulates a thread.")クラスを継承しています:

```cpp
class MainContentComponent : public juce::AudioAppComponent,
                             private juce::Thread
{
public:
```

これは、バックグラウンドスレッドを実装するために使用されます。オーバーライドした[Thread::run()](https://docs.juce.com/master/classThread.html#aae90dfabab3e1776cf01a26e7ee3a620 "Must be implemented to perform the thread's actual code.")関数は次のとおりです:

```cpp
void run() override
{
    while (!threadShouldExit())
    {
        checkForBuffersToFree();
        wait (500);
    }
}
```

ここでは、解放すべきバッファがあるかどうかをチェックし、その後スレッドは500msまたは起こされるまで([Thread::notify()](https://docs.juce.com/master/classThread.html#a0b4d5a1ffaa35cc13f323a0524012a2b "Wakes up the thread.")関数を使用して)待機します。基本的に、これは少なくとも500msごとにチェックが行われることを意味します。`checkForBuffersToFree()`関数は、`buffers`配列を検索して、解放できるバッファがあるかどうかを確認します:

```cpp
void checkForBuffersToFree()
{
    for (auto i = buffers.size(); --i >= 0;) // [1]
    {
        ReferenceCountedBuffer::Ptr buffer (buffers.getUnchecked (i)); // [2]

        if (buffer->getReferenceCount() == 2) // [3]
            buffers.remove (i);
    }
}
```

- \[1\]: これらの状況では、配列を逆順に反復処理することを覚えておくと便利です。配列を反復処理しながらアイテムを削除する場合、配列インデックスアクセスの破損を避けやすくなります。
- \[2\]: これは、指定されたインデックスのバッファのコピーを保持します。
- \[3\]: この時点で参照カウントが2に等しい場合、オーディオスレッドがバッファを使用していないことがわかり、配列から削除できます。これら2つの参照のうち1つは`buffers`にあり、もう1つはローカルの`buffer`変数にあります。削除されたバッファは、`buffer`変数がスコープを外れると(これが残っている最後の参照になるため)自動的に削除されます。

もちろん、アプリケーションの起動時にスレッドを開始する必要があり、これは`MainContentComponent`コンストラクタで行います:

```cpp
startThread();
}
```

### ファイルを開く

`openButtonClicked()`関数は、[Tutorial: Looping audio using the AudioSampleBuffer class](../tutorial_looping_audio_sample_buffer/)の`openButtonClicked()`関数と似ていますが、いくつかの小さな違いがあります:

```cpp
void openButtonClicked()
{
    chooser = std::make_unique<juce::FileChooser> ("Select a Wave file shorter than 2 seconds to play...",
        juce::File {},
        "*.wav");
    auto chooserFlags = juce::FileBrowserComponent::openMode
                        | juce::FileBrowserComponent::canSelectFiles;

    chooser->launchAsync (chooserFlags, [this] (const juce::FileChooser& fc) {
        auto file = fc.getResult();

        if (file == juce::File {})
            return;

        std::unique_ptr<juce::AudioFormatReader> reader (formatManager.createReaderFor (file));

        if (reader != nullptr)
        {
            auto duration = (float) reader->lengthInSamples / reader->sampleRate;

            if (duration < 2)
            {
                ReferenceCountedBuffer::Ptr newBuffer = new ReferenceCountedBuffer (file.getFileName(),
                    (int) reader->numChannels,
                    (int) reader->lengthInSamples);

                reader->read (newBuffer->getAudioSampleBuffer(), 0, (int) reader->lengthInSamples, 0, true, true);

                {
                    const juce::SpinLock::ScopedLockType lock (mutex);
                    currentBuffer = newBuffer;
                }

                buffers.add (newBuffer);
            }
            else
            {
                // handle the error that the file is 2 seconds or longer..
            }
        }
    });
}
```

## getNextAudioBlock()関数の実装

オーディオコールバックでは、`currentBuffer`メンバーのコピーを保持する必要があります。これはスレッドセーフな方法で実行できます。この方法では、音声出力中に`currentBuffer`メンバーが変更されても問題ありません。完全な`getNextAudioBlock()`関数は次のとおりです:

```cpp
void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override
{
    ReferenceCountedBuffer::Ptr retainedCurrentBuffer (currentBuffer); // [4]

    if (retainedCurrentBuffer == nullptr) // [5]
    {
        bufferToFill.clearActiveBufferRegion();
        return;
    }

    auto* currentAudioSampleBuffer = retainedCurrentBuffer->getAudioSampleBuffer(); // [6]
    auto position = retainedCurrentBuffer->position; // [7]

    auto numInputChannels = currentAudioSampleBuffer->getNumChannels();
    auto numOutputChannels = bufferToFill.buffer->getNumChannels();

    auto outputSamplesRemaining = bufferToFill.numSamples;
    auto outputSamplesOffset = 0;

    while (outputSamplesRemaining > 0)
    {
        auto bufferSamplesRemaining = currentAudioSampleBuffer->getNumSamples() - position;
        auto samplesThisTime = juce::jmin (outputSamplesRemaining, bufferSamplesRemaining);

        for (auto channel = 0; channel < numOutputChannels; ++channel)
        {
            bufferToFill.buffer->copyFrom (channel,
                bufferToFill.startSample + outputSamplesOffset,
                *currentAudioSampleBuffer,
                channel % numInputChannels,
                position,
                samplesThisTime);
        }

        outputSamplesRemaining -= samplesThisTime;
        outputSamplesOffset += samplesThisTime;
        position += samplesThisTime;

        if (position == currentAudioSampleBuffer->getNumSamples())
            position = 0;
    }

    retainedCurrentBuffer->position = position; // [8]
}
```

重要な変更点は次のとおりです:

- \[4\]: `currentBuffer`メンバーのコピーを保持します。この関数のこの時点以降、別のスレッドで`currentBuffer`メンバーが変更されても問題ありません。ここではトライロックを使用しているため、別のスレッドが現在変更している場合に、オーディオスレッドが`currentBuffer`へのアクセスを待機してブロックされることはありません。
- \[5\]: コピーを取得したときに`currentBuffer`メンバーがnullだった場合、無音を出力します。
- \[6\]: `ReferenceCountedBuffer`オブジェクト内の[AudioSampleBuffer](group__juce__audio__basics-buffers.html#gab339ebab0d3b10c91c0d47c8fd2e50d2)オブジェクトにアクセスします。
- \[7\]: バッファの現在の再生位置を取得します。
- \[8\]: 現在の再生位置を変更した後、`ReferenceCountedBuffer`オブジェクトに保存し直します。

このアルゴリズムにより、`ReferenceCountedBuffer`オブジェクトがオーディオスレッド上で削除されないことが保証されます。オーディオスレッド上でメモリを割り当てたり解放したりすることは良い考えではありません。`ReferenceCountedBuffer`オブジェクトは、バックグラウンドスレッド上でのみ削除されます。

## バックグラウンドスレッドでの音声読み込み

このアプリケーションは、まだメッセージスレッドで音声データを読み込んでいます。これはメッセージスレッドをブロックし、大きなファイルの読み込みに時間がかかる可能性があるため、理想的ではありません。実際には、バックグラウンドスレッドを使用してこのタスクを実行することもできます。

### ファイルパスをバックグラウンドスレッドに渡す

まず、`MainContentComponent`クラスに次のメンバーを追加します:

```cpp
juce::CriticalSection pathMutex;
juce::String chosenPath;
```

次に、`openButtonClicked()`関数を変更して、ファイルのフルパスをこのメンバーに*スワップ*します。文字列のスワップは厳密にはスレッドセーフではないため、このスレッドが使用している間に他のスレッドが`chosenPath`を変更しようとしないようにロックを取得する必要があります。

```cpp
void openButtonClicked()
{
    chooser = std::make_unique<juce::FileChooser> ("Select a Wave file shorter than 2 seconds to play...",
        juce::File {},
        "*.wav");
    auto chooserFlags = juce::FileBrowserComponent::openMode
                        | juce::FileBrowserComponent::canSelectFiles;

    chooser->launchAsync (chooserFlags, [this] (const juce::FileChooser& fc) {
        auto file = fc.getResult();

        if (file == juce::File {})
            return;

        auto path = file.getFullPathName();

        {
            const juce::ScopedLock lock (pathMutex);
            chosenPath.swapWith (path);
        }

        notify();
    });
}
```

ここでは、バックグラウンドスレッドで関数を呼び出してファイルを開く予定があるため、バックグラウンドスレッドを起こします。

### バックグラウンドスレッドからパスにアクセスする

`run()`関数は次のように更新する必要があります:

```cpp
void run() override
{
    while (!threadShouldExit())
    {
        checkForPathToOpen();
        checkForBuffersToFree();
        wait (500);
    }
}
```

`checkForPathToOpen()`関数は、`chosenPath`メンバーをローカル変数にスワップしてチェックします。繰り返しになりますが、スワップはスレッドセーフではないため、`chosenPath`にアクセスする前にロックを取得する必要があります。

```cpp
void checkForPathToOpen()
{
    juce::String pathToOpen;

    {
        const juce::ScopedLock lock (pathMutex);
        pathToOpen.swapWith (chosenPath);
    }

    if (pathToOpen.isNotEmpty())
    {
        juce::File file (pathToOpen);
        std::unique_ptr<juce::AudioFormatReader> reader (formatManager.createReaderFor (file));

        if (reader.get() != nullptr)
        {
            auto duration = (float) reader->lengthInSamples / reader->sampleRate;

            if (duration < 2)
            {
                ReferenceCountedBuffer::Ptr newBuffer = new ReferenceCountedBuffer (file.getFileName(),
                    (int) reader->numChannels,
                    (int) reader->lengthInSamples);

                reader->read (newBuffer->getAudioSampleBuffer(), 0, (int) reader->lengthInSamples, 0, true, true);

                {
                    const juce::SpinLock::ScopedLockType lock (mutex);
                    currentBuffer = newBuffer;
                }

                buffers.add (newBuffer);
            }
            else
            {
                // handle the error that the file is 2 seconds or longer..
            }
        }
    }
}
```

`pathToOpen`変数が空の文字列の場合、開くべき新しいファイルがないことがわかります。この関数の残りのコードは見慣れたものでしょう。

アプリケーションを再度実行すると、正しく機能するはずです。

:::tip
このセクションの最終コードは、デモプロジェクトの`LoopingAudioSampleBufferAdvancedTutorial_02.h`ファイルにあります。
:::

## まとめ

このチュートリアルでは、特にオーディオアプリケーションにおいて、スレッド間でデータを渡すための便利な技術をいくつか紹介しました。このチュートリアルを読んだ後、次のことができるようになります:

- [ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting.")クラスのサブクラスを実装する。
- マルチスレッドアプリケーションで[ReferenceCountedObject](https://docs.juce.com/master/classReferenceCountedObject.html "A base class which provides methods for reference-counting.")の寿命を管理する。
- 不要になったオブジェクトの削除やファイル読み込み操作などのタスクを実行するバックグラウンドスレッドを実装する。

## 関連項目

- [Tutorial: Build an audio player](../tutorial_playing_sound_files/)
- [Tutorial: Processing audio input](../tutorial_processing_audio_input/)
- [Tutorial: Draw audio waveforms](../tutorial_audio_thumbnail/)
- [Tutorial: Looping audio using the AudioSampleBuffer class](../tutorial_looping_audio_sample_buffer/)
