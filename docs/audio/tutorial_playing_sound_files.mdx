---
title: オーディオプレーヤーの構築
sidebar_position: 1
tags: [中級]
---

# チュートリアル: オーディオプレーヤーの構築

<SourcePageLink path="tutorial_playing_sound_files" />

このチュートリアルでは、サウンドファイルを開いて再生する方法について説明します。JUCEでサウンドファイルを扱うための重要なクラスをいくつか紹介します。

**レベル:** 中級<br/>
**プラットフォーム:** Windows, macOS, Linux<br/>
**クラス:** [AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi..."), [AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream."), [AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader."), [AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,..."), [FileChooser](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save."), [ChangeListener](https://docs.juce.com/master/classChangeListener.html "Receives change event callbacks that are sent out by a ChangeBroadcaster."), [File](https://docs.juce.com/master/classFile.html "Represents a local file or directory."), [FileChooser](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")

## はじめに

このチュートリアルのデモプロジェクトをここからダウンロードしてください: [PIP](https://docs.juce.com/tutorials/PIPs/PlayingSoundFilesTutorial.zip) \| [ZIP](https://docs.juce.com/tutorials/ZIPs/PlayingSoundFilesTutorial.zip)。プロジェクトを解凍し、Projucerで最初のヘッダーファイルを開きます。

このステップに関するヘルプが必要な場合は、[Tutorial: Projucer Part 1: Getting started with the Projucer](../../getting-started/tutorial_new_projucer_project/)を参照してください。

## デモプロジェクト

デモプロジェクトは、サウンドファイルの再生を制御するための3つのボタンのインターフェースを提供します。3つのボタンは次のとおりです:

- サウンドファイルを選択するためのファイルチューザーをユーザーに提示するボタン
- サウンドを再生するボタン
- サウンドを停止するボタン

インターフェースを次のスクリーンショットに示します:

<CaptionImage
  src="/_images/tutorial_playing_sound_files_screenshot1.png"
  caption="サウンドファイルの再生を制御する3つのボタンのインターフェース。"
/>

## 便利なクラス

### AudioSourceクラス

Audio Applicationテンプレートの`getNextAudioBlock()`でオーディオをサンプル単位で生成することもできますが、オーディオを生成および処理するための組み込みツールがいくつかあります。これらにより、アプリケーションコード内でオーディオの各サンプルを処理することなく、高レベルのビルディングブロックをリンクして強力なオーディオアプリケーションを形成できます(JUCEが代わりにこれを行います)。これらのビルディングブロックは、[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスに基づいています。実際、[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")クラスに基づくチュートリアル---例えば、[Tutorial: Build a white noise generator](../../synth/tutorial_simple_synth_noise/)---のいずれかに従っている場合、すでに[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスを使用しています。[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")クラス自体は[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスから継承しており、重要なことに、[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")とオーディオハードウェアデバイス間でオーディオをストリーミングする[AudioSourcePlayer](https://docs.juce.com/master/classAudioSourcePlayer.html "Wrapper class to continuously stream audio from an audio source to an AudioIODevice.")オブジェクトを含んでいます。`getNextAudioBlock()`関数で直接オーディオサンプルを生成することもできますが、代わりに複数の[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")オブジェクトを連鎖させて一連のプロセスを形成することもできます。このチュートリアルではこの機能を利用します。

### オーディオフォーマット

JUCEは、さまざまなフォーマットでサウンドファイルを読み書きするための多数のツールを提供します。このチュートリアルでは、これらのいくつかを使用します。特に、次のクラスを使用します:

- [AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi..."): このクラスは、オーディオフォーマット(WAV、AIFF、Ogg Vorbisなど)のリストを含み、これらのフォーマットからオーディオデータを読み取るための適切なオブジェクトを作成できます。
- [AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream."): このクラスは、オーディオファイルの低レベルのファイル読み取り操作を処理し、一貫したフォーマット(一般的には`float`値の配列)でオーディオを読み取ることができます。[AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi...")オブジェクトが特定のファイルを開くように要求されると、このクラスのインスタンスが作成されます。
- [AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader."): これは[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスのサブクラスです。[AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream.")オブジェクトからオーディオデータを読み取り、`getNextAudioBlock()`関数を介してオーディオをレンダリングできます。
- [AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,..."): このクラスは、[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスの別のサブクラスです。[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトの再生を制御できます。この制御には、[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトの再生の開始と停止が含まれます。また、サンプルレート変換を実行したり、必要に応じて事前にオーディオをバッファリングしたりすることもできます。

## まとめる

これらのクラスを適切なユーザーインターフェースクラスと組み合わせて、サウンドファイル再生アプリケーションを作成します。この時点で、オーディオファイルを再生するさまざまなフェーズ---または_トランスポート状態_---について考えることが役立ちます。オーディオファイルが読み込まれると、次の4つの可能な状態が考えられます:

- _Stopped_: オーディオ再生が停止されており、開始する準備ができています。
- _Starting_: オーディオ再生はまだ開始されていませんが、開始するように指示されています。
- _Playing_: オーディオが再生中です。
- _Stopping_: オーディオが再生中ですが、再生が停止するように指示されており、その後_Stopped_状態に戻ります。

これらの状態を表すために、`MainContentComponent`クラス内に`enum`を作成します:
```cpp
enum TransportState {
    Stopped,
    Starting,
    Playing,
    Stopping
};
```

### インターフェースの初期化

`MainContentComponent`クラスのコンストラクタで、3つのボタンを設定します:
```cpp
MainContentComponent()
    : state (Stopped)
{
    addAndMakeVisible (&openButton);
    openButton.setButtonText ("Open...");
    openButton.onClick = [this] { openButtonClicked(); };

    addAndMakeVisible (&playButton);
    playButton.setButtonText ("Play");
    playButton.onClick = [this] { playButtonClicked(); };
    playButton.setColour (juce::TextButton::buttonColourId, juce::Colours::green);
    playButton.setEnabled (false);

    addAndMakeVisible (&stopButton);
    stopButton.setButtonText ("Stop");
    stopButton.onClick = [this] { stopButtonClicked(); };
    stopButton.setColour (juce::TextButton::buttonColourId, juce::Colours::red);
    stopButton.setEnabled (false);
```

特に、最初に**Play**ボタンと**Stop**ボタンを無効にしていることに注目してください。**Play**ボタンは、有効なファイルが読み込まれると有効になります。ここでは、これら3つのボタンのそれぞれに対して[Button::onClick](https://docs.juce.com/master/classButton.html#a30b76ab312dc7f66e67596ae20540ec2 "You can assign a lambda to this callback object to have it called when the button is clicked.")ヘルパーオブジェクトにラムダ関数を割り当てていることがわかります([Tutorial: Listeners and Broadcasters](../../interface-design/tutorial_listeners_and_broadcasters/)を参照)。また、コンストラクタの初期化リストでトランスポート状態を初期化します。

### その他の初期化

3つの[TextButton](https://docs.juce.com/master/classTextButton.html "A button that uses the standard lozenge-shaped background with a line of text on it.")オブジェクトに加えて、`MainContentComponent`クラスには他に4つのメンバーがあります:
```cpp
juce::AudioFormatManager formatManager;
std::unique_ptr<juce::AudioFormatReaderSource> readerSource;
juce::AudioTransportSource transportSource;
TransportState state;
```

ここでは、前述の[AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi...")、[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")、[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")クラスが表示されます。

`MainContentComponent`コンストラクタでは、標準フォーマットのリストを登録するために[AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi...")オブジェクトを初期化する必要があります \[1\]:
```cpp
formatManager.registerBasicFormats(); // [1]
```

最低限、これにより[AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi...")オブジェクトがWAVおよびAIFFフォーマットのリーダーを作成できるようになります。他のフォーマットは、次のスクリーンショットに示すように、プラットフォームとProjucerプロジェクト内の`juce_audio_formats`モジュールで有効になっているオプションによって利用可能になる場合があります:

<CaptionImage
  src="/_images/tutorial_playing_sound_files_screenshot2.png"
  caption="オーディオフォーマットオプションを示すjuce_audio_formatsモジュールオプション。"
/>

`MainContentComponent`コンストラクタでは、`MainContentComponent`オブジェクトを[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトにリスナー [2] として追加して、その状態の変化(例えば、停止したとき)に応答できるようにします:
```cpp
transportSource.addChangeListener (this); // [2]
```

:::tip
この場合、関数名は、JUCEの他の多くのリスナークラスのように単に`addListener()`ではなく、`addChangeListener()`です。
:::

### AudioTransportSourceの変更への応答

トランスポートの変更が報告されると、`changeListenerCallback()`関数が呼び出されます。これは、メッセージスレッドで非同期に呼び出されます:
```cpp
void changeListenerCallback (juce::ChangeBroadcaster* source) override
{
    if (source == &transportSource)
    {
        if (transportSource.isPlaying())
            changeState (Playing);
        else
            changeState (Stopped);
    }
}
```

これは、単にメンバー関数`changeState()`を呼び出すだけです。

### 状態の変更

トランスポート状態の変更は、この単一の関数`changeState()`にローカライズされます。これにより、この機能のすべてのロジックを1か所に保つことができます。この関数は、`state`メンバーを更新し、この新しい状態になったときに発生する必要がある他のオブジェクトへの変更をトリガーします。

:::tip
より経験豊富な読者は、このコードを構造化する別の方法として、[ステートデザインパターン](https://en.wikipedia.org/wiki/State_pattern)を使用することをお勧めします。
:::
```cpp
void changeState (TransportState newState)
{
    if (state != newState)
    {
        state = newState;

        switch (state)
        {
            case Stopped: // [3]
                stopButton.setEnabled (false);
                playButton.setEnabled (true);
                transportSource.setPosition (0.0);
                break;

            case Starting: // [4]
                playButton.setEnabled (false);
                transportSource.start();
                break;

            case Playing: // [5]
                stopButton.setEnabled (true);
                break;

            case Stopping: // [6]
                transportSource.stop();
                break;
        }
    }
}
```

- \[3\]: トランスポートが_Stopped_状態に戻ると、**Stop**ボタンを無効にし、**Play**ボタンを有効にし、トランスポート位置をファイルの先頭にリセットします。
- \[4\]: _Starting_状態は、ユーザーが**Play**ボタンをクリックすることによってトリガーされ、これにより[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトに再生を開始するように指示します。この時点で、**Play**ボタンも無効にします。
- \[5\]: _Playing_状態は、[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトが`changeListenerCallback()`関数を介して変更を報告することによってトリガーされます。ここでは、**Stop**ボタンを有効にします。
- \[6\]: _Stopping_状態は、ユーザーが**Stop**ボタンをクリックすることによってトリガーされるため、[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトに停止するように指示します。

### オーディオの処理

このデモプロジェクトのオーディオ処理は非常に簡単です:[AudioAppComponent](https://docs.juce.com/master/classAudioAppComponent.html "A base class for writing audio apps that stream from the audio i/o devices.")クラスを介して渡された[AudioSourceChannelInfo](# "Used by AudioSource::getNextAudioBlock().")構造体を[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトに渡すことで、処理を委譲するだけです:
```cpp
void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override
{
    if (readerSource.get() == nullptr)
    {
        bufferToFill.clearActiveBufferRegion();
        return;
    }

    transportSource.getNextAudioBlock (bufferToFill);
}
```

有効な[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトがあるかどうかを最初にチェックし、そうでない場合は出力を単にゼロにします(便利な[AudioSourceChannelInfo::clearActiveBufferRegion()](# "Convenient method to clear the buffer if the source is not producing any data.")関数を使用)。[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")メンバーはstd::unique_ptrオブジェクトに格納されています。これは、ユーザーのアクションに基づいてこれらのオブジェクトを動的に作成する必要があるためです。また、無効なオブジェクトに対して`nullptr`をチェックすることもできます。

また、使用している他の[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")オブジェクトに`prepareToPlay()`コールバックを渡すことも忘れないでください:
```cpp
void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override
{
    transportSource.prepareToPlay (samplesPerBlockExpected, sampleRate);
}
```

そして、`releaseResources()`コールバックも:
```cpp
void releaseResources() override
{
    transportSource.releaseResources();
}
```

### ファイルを開く

ファイルを開くには、**Open...**ボタンがクリックされたときに[FileChooser](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")オブジェクトをポップアップします:
```cpp
void openButtonClicked()
{
    chooser = std::make_unique<juce::FileChooser> ("Select a Wave file to play...",
        juce::File {},
        "*.wav"); // [7]
    auto chooserFlags = juce::FileBrowserComponent::openMode
                        | juce::FileBrowserComponent::canSelectFiles;

    chooser->launchAsync (chooserFlags, [this] (const juce::FileChooser& fc) // [8]
        {
            auto file = fc.getResult();

            if (file != juce::File {}) // [9]
            {
                auto* reader = formatManager.createReaderFor (file); // [10]

                if (reader != nullptr)
                {
                    auto newSource = std::make_unique<juce::AudioFormatReaderSource> (reader, true); // [11]
                    transportSource.setSource (newSource.get(), 0, nullptr, reader->sampleRate); // [12]
                    playButton.setEnabled (true); // [13]
                    readerSource.reset (newSource.release()); // [14]
                }
            }
        });
}
```

- \[7\]: 短いメッセージで[FileChooser](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")オブジェクトを作成し、ユーザーが`.wav`ファイルのみを選択できるようにします。
- \[8\]: [FileChooser](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")オブジェクトをポップアップします。
- \[9\]: ユーザーが実際にファイルを選択した場合(キャンセルではなく)、この`if()`は成功します。
- \[10\]: [AudioFormatManager::createReaderFor()](https://docs.juce.com/master/classAudioFormatManager.html#a4eed7ecbb353d3d85154182de5057221 "Searches through the known formats to try to create a suitable reader for this file.")関数を使用して、この特定のファイルのリーダーを作成しようとします。これは、失敗した場合(例えば、ファイルが[AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi...")オブジェクトが処理できるオーディオフォーマットでない場合)、`nullptr`値を返します。
- \[11\]: 先ほど作成したリーダーを使用して、新しい[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを作成します。2番目の引数`true`は、[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトに[AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream.")オブジェクトを管理し、不要になったときに削除するように指示します。以前に割り当てられた[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")を後続のファイルを開くコマンドで早期に削除しないように、[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを一時的なstd::unique_ptrオブジェクトに格納します。
- \[12\]: [AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトは、`getNextAudioBlock()`関数で使用されている[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトに接続されます。ファイルのサンプルレートがハードウェアのサンプルレートと一致しない場合に備えて、[AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream.")オブジェクトから取得したこれを4番目の引数として渡します。2番目と3番目の引数の詳細については、[注意事項](#tutorial_playing_sound_files_notes)を参照してください。[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")ソースは、必要なサンプルレート変換を処理します。
- \[13\]: **Play**ボタンが有効になり、ユーザーがクリックできるようになります。
- \[14\]: [AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")が新しく割り当てられた[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを使用しているはずなので、[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを`readerSource`メンバーに安全に格納できます。(上記の[オーディオの処理](#tutorial_playing_sound_files_processing_the_audio)で述べたとおり。)これを行うには、std::unique_ptr::release()を使用してローカル変数`newSource`から所有権を譲渡する必要があります。

:::tip
新しく割り当てられた[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを一時的なstd::unique_ptrオブジェクトに格納することには、例外セーフであるという追加の利点があります。[AudioTransportSource::setSource()](https://docs.juce.com/master/classAudioTransportSource.html#a20a6a91c4505e77207cadef7ddc4dc5c "Sets the reader that is being used as the input source.")関数呼び出し中に例外がスローされる可能性があり、その場合、std::unique_ptrオブジェクトは不要になった[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを削除します。この時点で生ポインタが使用されていた場合、[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトを格納するために、例外がスローされるとポインタが宙ぶらりんのままになるため、メモリリークが発生する可能性があります。
:::

### ファイルの再生と停止

ファイルを実際に再生するコードをすでに設定しているので、適切な引数で`changeState()`関数を呼び出すだけでファイルを再生できます。**Play**ボタンがクリックされたら、次のようにします:
```cpp
void playButtonClicked()
{
    changeState (Starting);
}
```

ファイルの停止も同様に簡単です。**Stop**ボタンがクリックされたとき:
```cpp
void stopButtonClicked()
{
    changeState (Stopping);
}
```

:::note
演習: [FileChooser](https://docs.juce.com/master/classFileChooser.html "Creates a dialog box to choose a file or directory to load or save.")オブジェクトを作成するときの3番目の引数(`filePatternsAllowed`)を変更して、アプリケーションがAIFFファイルも読み込めるようにします。ファイルパターンはセミコロンで区切ることができるため、このフォーマットの2つの一般的なファイル拡張子を許可するには`"*.wav;*.aif;*.aiff"`にする必要があります。
:::

## ポーズ機能の追加

それでは、アプリケーションに_ポーズ_機能を追加する手順を説明します。ここでは、ファイルの再生中に**Play**ボタンを**Pause**ボタンにします(単に無効にするのではなく)。また、サウンドファイルが一時停止されている間、**Stop**ボタンを**Return to zero**ボタンにします。

まず、`TransportState`列挙型に_Pausing_と_Paused_の2つの状態を追加する必要があります:

```cpp
enum TransportState {
    Stopped,
    Starting,
    Playing,
    Pausing,
    Paused,
    Stopping
};
```

`changeState()`関数は2つの新しい状態を処理する必要があり、他の状態のコードも更新する必要があります:

```cpp
void changeState (TransportState newState)
{
    if (state != newState)
    {
        state = newState;

        switch (state)
        {
            case Stopped:
                playButton.setButtonText ("Play");
                stopButton.setButtonText ("Stop");
                stopButton.setEnabled (false);
                transportSource.setPosition (0.0);
                break;

            case Starting:
                transportSource.start();
                break;

            case Playing:
                playButton.setButtonText ("Pause");
                stopButton.setButtonText ("Stop");
                stopButton.setEnabled (true);
                break;

            case Pausing:
                transportSource.stop();
                break;

            case Paused:
                playButton.setButtonText ("Resume");
                stopButton.setButtonText ("Return to Zero");
                break;

            case Stopping:
                transportSource.stop();
                break;
        }
    }
}
```

各状態でボタンを適切に有効/無効にし、ボタンのテキストを正しく更新します。

_Pausing_状態で一時停止を求められたときに、実際にトランスポートを停止していることに注意してください。`changeListenerCallback()`関数では、一時停止または停止リクエストが行われたかどうかに応じて、正しい状態に移動するようにロジックを変更する必要があります:

```cpp
void changeListenerCallback (juce::ChangeBroadcaster* source) override
{
    if (source == &transportSource)
    {
        if (transportSource.isPlaying())
            changeState (Playing);
        else if ((state == Stopping) || (state == Playing))
            changeState (Stopped);
        else if (Pausing == state)
            changeState (Paused);
    }
}
```

**Play**ボタンがクリックされたときのコードを変更する必要があります:

```cpp
void playButtonClicked()
{
    if ((state == Stopped) || (state == Paused))
        changeState (Starting);
    else if (state == Playing)
        changeState (Pausing);
}
```

そして、**Stop**ボタンがクリックされたとき:

```cpp
void stopButtonClicked()
{
    if (state == Paused)
        changeState (Stopped);
    else
        changeState (Stopping);
}
```

以上です。これで、アプリケーションをビルドして実行できるはずです。

:::tip
このアプリケーションの変更されたバージョンのソースコードは、デモプロジェクトの`PlayingSoundFilesTutorial_02.h`ファイルにあります。
:::

:::note
演習: [AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")オブジェクトの現在の時間位置を表示する[Label](https://docs.juce.com/master/classLabel.html "A component that displays a text string, and can optionally become a text editor when clicked.")オブジェクトをインターフェースに追加します。この位置を取得するには、[AudioTransportSource::getCurrentPosition()](https://docs.juce.com/master/classAudioTransportSource.html#a1984ac3a6eafb12d5312c3eab5615810 "Returns the position that the next data block will be read from.")関数を使用できます。また、`MainContentComponent`クラスを[Timer](https://docs.juce.com/master/classTimer.html "Makes repeated callbacks to a virtual method at a specified time interval.")クラスから継承させ、`timerCallback()`関数で定期的な更新を実行してラベルを更新する必要があります。[RelativeTime](https://docs.juce.com/master/classRelativeTime.html "A relative measure of time.")クラスを使用して、秒単位の生の時間を分、秒、ミリ秒のより便利なフォーマットに変換することもできます。
:::

:::tip
この演習のソースコードは、デモプロジェクトの`PlayingSoundFilesTutorial_03.h`ファイルにあります。
:::

## まとめ

このチュートリアルでは、サウンドファイルの読み取りと再生について紹介しました。特に、次のことを扱いました:

- [AudioFormatManager](https://docs.juce.com/master/classAudioFormatManager.html "A class for keeping a list of available audio formats, and for deciding which one to use to open a gi...")クラスを使用して、一般的なオーディオフォーマット用の[AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream.")オブジェクトを作成する。
- さまざまな[AudioSource](https://docs.juce.com/master/classAudioSource.html "Base class for objects that can produce a continuous stream of audio.")クラスを使用して、それらを作成して接続する。特に:
  - [AudioFormatReader](https://docs.juce.com/master/classAudioFormatReader.html "Reads samples from an audio file stream.")オブジェクトからオーディオを読み取って再生するための[AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")クラス、および
  - [AudioFormatReaderSource](https://docs.juce.com/master/classAudioFormatReaderSource.html "A type of AudioSource that will read from an AudioFormatReader.")オブジェクトの再生を制御するための[AudioTransportSource](https://docs.juce.com/master/classAudioTransportSource.html "An AudioSource that takes a PositionableAudioSource and allows it to be played, stopped,...")クラス。
- オーディオファイル再生の状態を管理する1つの方法についても見ました。

## 注意事項

[AudioTransportSource::setSource()](https://docs.juce.com/master/classAudioTransportSource.html#a20a6a91c4505e77207cadef7ddc4dc5c "Sets the reader that is being used as the input source.")関数の2番目と3番目の引数を使用すると、バックグラウンドスレッドでの先読みバッファリングを制御できます。2番目の引数は使用するバッファサイズで、3番目の引数はバックグラウンド処理に使用される[TimeSliceThread](https://docs.juce.com/master/classTimeSliceThread.html "A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...")オブジェクトへのポインタです。この例では、バッファサイズとしてゼロを使用し、スレッドオブジェクトには`nullptr`値を使用しています。これがデフォルトです。

## 参照

- [Tutorial: Listeners and Broadcasters](../../interface-design/tutorial_listeners_and_broadcasters/)
- [Tutorial: Build a white noise generator](../../synth/tutorial_simple_synth_noise/)
- [Tutorial: Build a sine wave synthesiser](../../synth/tutorial_sine_synth/)
- [Tutorial: Draw audio waveforms](../tutorial_audio_thumbnail/)
